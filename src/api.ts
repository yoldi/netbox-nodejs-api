/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Action
 */
export interface Action {
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    label: ActionLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Action
     */
    value: ActionValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ActionLabelEnum {
    Created = 'Created',
    Updated = 'Updated',
    Deleted = 'Deleted'
}
/**
    * @export
    * @enum {string}
    */
export enum ActionValueEnum {
    Create = 'create',
    Update = 'update',
    Delete = 'delete'
}

/**
 * 
 * @export
 * @interface Aggregate
 */
export interface Aggregate {
    /**
     * 
     * @type {number}
     * @memberof Aggregate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    url?: string;
    /**
     * 
     * @type {Family}
     * @memberof Aggregate
     */
    family?: Family;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    prefix: string;
    /**
     * 
     * @type {NestedRIR}
     * @memberof Aggregate
     */
    rir: NestedRIR;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Aggregate
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    date_added?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Aggregate
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Aggregate
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Aggregate
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface AvailableIP
 */
export interface AvailableIP {
    /**
     * 
     * @type {number}
     * @memberof AvailableIP
     */
    family?: number;
    /**
     * 
     * @type {string}
     * @memberof AvailableIP
     */
    address?: string;
    /**
     * 
     * @type {NestedVRF}
     * @memberof AvailableIP
     */
    vrf?: NestedVRF | null;
}
/**
 * 
 * @export
 * @interface AvailablePrefix
 */
export interface AvailablePrefix {
    /**
     * 
     * @type {number}
     * @memberof AvailablePrefix
     */
    family?: number;
    /**
     * 
     * @type {string}
     * @memberof AvailablePrefix
     */
    prefix?: string;
    /**
     * 
     * @type {NestedVRF}
     * @memberof AvailablePrefix
     */
    vrf?: NestedVRF | null;
}
/**
 * 
 * @export
 * @interface Cable
 */
export interface Cable {
    /**
     * 
     * @type {number}
     * @memberof Cable
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    termination_a_type: string;
    /**
     * 
     * @type {number}
     * @memberof Cable
     */
    termination_a_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Cable
     */
    termination_a?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    termination_b_type: string;
    /**
     * 
     * @type {number}
     * @memberof Cable
     */
    termination_b_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Cable
     */
    termination_b?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    type?: CableTypeEnum;
    /**
     * 
     * @type {Status1}
     * @memberof Cable
     */
    status?: Status1;
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof Cable
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof Cable
     */
    length?: number | null;
    /**
     * 
     * @type {LengthUnit}
     * @memberof Cable
     */
    length_unit?: LengthUnit;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Cable
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Cable
     */
    custom_fields?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum CableTypeEnum {
    Cat3 = 'cat3',
    Cat5 = 'cat5',
    Cat5e = 'cat5e',
    Cat6 = 'cat6',
    Cat6a = 'cat6a',
    Cat7 = 'cat7',
    DacActive = 'dac-active',
    DacPassive = 'dac-passive',
    Mrj21Trunk = 'mrj21-trunk',
    Coaxial = 'coaxial',
    Mmf = 'mmf',
    MmfOm1 = 'mmf-om1',
    MmfOm2 = 'mmf-om2',
    MmfOm3 = 'mmf-om3',
    MmfOm4 = 'mmf-om4',
    Smf = 'smf',
    SmfOs1 = 'smf-os1',
    SmfOs2 = 'smf-os2',
    Aoc = 'aoc',
    Power = 'power'
}

/**
 * 
 * @export
 * @interface Circuit
 */
export interface Circuit {
    /**
     * 
     * @type {number}
     * @memberof Circuit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    cid: string;
    /**
     * 
     * @type {NestedProvider}
     * @memberof Circuit
     */
    provider: NestedProvider;
    /**
     * 
     * @type {NestedCircuitType}
     * @memberof Circuit
     */
    type: NestedCircuitType;
    /**
     * 
     * @type {Status}
     * @memberof Circuit
     */
    status?: Status;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Circuit
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    install_date?: string | null;
    /**
     * 
     * @type {number}
     * @memberof Circuit
     */
    commit_rate?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    description?: string;
    /**
     * 
     * @type {CircuitCircuitTermination}
     * @memberof Circuit
     */
    termination_a?: CircuitCircuitTermination;
    /**
     * 
     * @type {CircuitCircuitTermination}
     * @memberof Circuit
     */
    termination_z?: CircuitCircuitTermination;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Circuit
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Circuit
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Circuit
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface CircuitCircuitTermination
 */
export interface CircuitCircuitTermination {
    /**
     * 
     * @type {number}
     * @memberof CircuitCircuitTermination
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CircuitCircuitTermination
     */
    url?: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof CircuitCircuitTermination
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedInterface}
     * @memberof CircuitCircuitTermination
     */
    connected_endpoint: NestedInterface;
    /**
     * 
     * @type {number}
     * @memberof CircuitCircuitTermination
     */
    port_speed?: number | null;
    /**
     * Upstream speed, if different from port speed
     * @type {number}
     * @memberof CircuitCircuitTermination
     */
    upstream_speed?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CircuitCircuitTermination
     */
    xconnect_id?: string;
}
/**
 * 
 * @export
 * @interface CircuitTermination
 */
export interface CircuitTermination {
    /**
     * 
     * @type {number}
     * @memberof CircuitTermination
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    url?: string;
    /**
     * 
     * @type {NestedCircuit}
     * @memberof CircuitTermination
     */
    circuit: NestedCircuit;
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    term_side: CircuitTerminationTermSideEnum;
    /**
     * 
     * @type {NestedSite}
     * @memberof CircuitTermination
     */
    site: NestedSite;
    /**
     * 
     * @type {number}
     * @memberof CircuitTermination
     */
    port_speed?: number | null;
    /**
     * Upstream speed, if different from port speed
     * @type {number}
     * @memberof CircuitTermination
     */
    upstream_speed?: number | null;
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    xconnect_id?: string;
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    pp_info?: string;
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof CircuitTermination
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof CircuitTermination
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof CircuitTermination
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof CircuitTermination
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CircuitTermination
     */
    connected_endpoint_reachable?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum CircuitTerminationTermSideEnum {
    A = 'A',
    Z = 'Z'
}

/**
 * 
 * @export
 * @interface CircuitType
 */
export interface CircuitType {
    /**
     * 
     * @type {number}
     * @memberof CircuitType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CircuitType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof CircuitType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof CircuitType
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof CircuitType
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof CircuitType
     */
    circuit_count?: number;
}
/**
 * 
 * @export
 * @interface Cluster
 */
export interface Cluster {
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    name: string;
    /**
     * 
     * @type {NestedClusterType}
     * @memberof Cluster
     */
    type: NestedClusterType;
    /**
     * 
     * @type {NestedClusterGroup}
     * @memberof Cluster
     */
    group?: NestedClusterGroup;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Cluster
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {NestedSite}
     * @memberof Cluster
     */
    site?: NestedSite;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Cluster
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Cluster
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Cluster
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Cluster
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface ClusterGroup
 */
export interface ClusterGroup {
    /**
     * 
     * @type {number}
     * @memberof ClusterGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGroup
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterGroup
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface ClusterType
 */
export interface ClusterType {
    /**
     * 
     * @type {number}
     * @memberof ClusterType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ClusterType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterType
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof ClusterType
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof ClusterType
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface ConfigContext
 */
export interface ConfigContext {
    /**
     * 
     * @type {number}
     * @memberof ConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ConfigContext
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConfigContext
     */
    is_active?: boolean;
    /**
     * 
     * @type {Set<NestedRegion>}
     * @memberof ConfigContext
     */
    regions?: Set<NestedRegion>;
    /**
     * 
     * @type {Set<NestedSite>}
     * @memberof ConfigContext
     */
    sites?: Set<NestedSite>;
    /**
     * 
     * @type {Set<NestedDeviceRole>}
     * @memberof ConfigContext
     */
    roles?: Set<NestedDeviceRole>;
    /**
     * 
     * @type {Set<NestedPlatform>}
     * @memberof ConfigContext
     */
    platforms?: Set<NestedPlatform>;
    /**
     * 
     * @type {Set<NestedClusterGroup>}
     * @memberof ConfigContext
     */
    cluster_groups?: Set<NestedClusterGroup>;
    /**
     * 
     * @type {Set<NestedCluster>}
     * @memberof ConfigContext
     */
    clusters?: Set<NestedCluster>;
    /**
     * 
     * @type {Set<NestedTenantGroup>}
     * @memberof ConfigContext
     */
    tenant_groups?: Set<NestedTenantGroup>;
    /**
     * 
     * @type {Set<NestedTenant>}
     * @memberof ConfigContext
     */
    tenants?: Set<NestedTenant>;
    /**
     * 
     * @type {Set<string>}
     * @memberof ConfigContext
     */
    tags?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof ConfigContext
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface ConsolePort
 */
export interface ConsolePort {
    /**
     * 
     * @type {number}
     * @memberof ConsolePort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsolePort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof ConsolePort
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof ConsolePort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof ConsolePort
     */
    label?: string;
    /**
     * 
     * @type {Type}
     * @memberof ConsolePort
     */
    type?: Type;
    /**
     * 
     * @type {string}
     * @memberof ConsolePort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof ConsolePort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof ConsolePort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ConsolePort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof ConsolePort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ConsolePort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConsolePort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof ConsolePort
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface ConsolePortTemplate
 */
export interface ConsolePortTemplate {
    /**
     * 
     * @type {number}
     * @memberof ConsolePortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsolePortTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof ConsolePortTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof ConsolePortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof ConsolePortTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type}
     * @memberof ConsolePortTemplate
     */
    type?: Type;
    /**
     * 
     * @type {string}
     * @memberof ConsolePortTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ConsoleServerPort
 */
export interface ConsoleServerPort {
    /**
     * 
     * @type {number}
     * @memberof ConsoleServerPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof ConsoleServerPort
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof ConsoleServerPort
     */
    label?: string;
    /**
     * 
     * @type {Type}
     * @memberof ConsoleServerPort
     */
    type?: Type;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof ConsoleServerPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof ConsoleServerPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof ConsoleServerPort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ConsoleServerPort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof ConsoleServerPort
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface ConsoleServerPortTemplate
 */
export interface ConsoleServerPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof ConsoleServerPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof ConsoleServerPortTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof ConsoleServerPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type}
     * @memberof ConsoleServerPortTemplate
     */
    type?: Type;
    /**
     * 
     * @type {string}
     * @memberof ConsoleServerPortTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface ContentType
 */
export interface ContentType {
    /**
     * 
     * @type {number}
     * @memberof ContentType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    app_label: string;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof ContentType
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface CustomField
 */
export interface CustomField {
    /**
     * 
     * @type {number}
     * @memberof CustomField
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    url?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof CustomField
     */
    content_types: Set<string>;
    /**
     * 
     * @type {Type7}
     * @memberof CustomField
     */
    type: Type7;
    /**
     * Internal field name
     * @type {string}
     * @memberof CustomField
     */
    name: string;
    /**
     * Name of the field as displayed to users (if not provided, the field\'s name will be used)
     * @type {string}
     * @memberof CustomField
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomField
     */
    description?: string;
    /**
     * If true, this field is required when creating new objects or editing an existing object.
     * @type {boolean}
     * @memberof CustomField
     */
    required?: boolean;
    /**
     * 
     * @type {FilterLogic}
     * @memberof CustomField
     */
    filter_logic?: FilterLogic;
    /**
     * Default value for the field (must be a JSON value). Encapsulate strings with double quotes (e.g. \"Foo\").
     * @type {string}
     * @memberof CustomField
     */
    _default?: string | null;
    /**
     * Fields with higher weights appear lower in a form.
     * @type {number}
     * @memberof CustomField
     */
    weight?: number;
    /**
     * Minimum allowed value (for numeric fields)
     * @type {number}
     * @memberof CustomField
     */
    validation_minimum?: number | null;
    /**
     * Maximum allowed value (for numeric fields)
     * @type {number}
     * @memberof CustomField
     */
    validation_maximum?: number | null;
    /**
     * Regular expression to enforce on text field values. Use ^ and $ to force matching of entire string. For example, <code>^[A-Z]{3}$</code> will limit values to exactly three uppercase letters.
     * @type {string}
     * @memberof CustomField
     */
    validation_regex?: string;
    /**
     * Comma-separated list of available choices (for selection fields)
     * @type {Array<string>}
     * @memberof CustomField
     */
    choices?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface Device
 */
export interface Device {
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    display_name?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof Device
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {NestedDeviceRole}
     * @memberof Device
     */
    device_role: NestedDeviceRole;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Device
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {NestedPlatform}
     * @memberof Device
     */
    platform?: NestedPlatform | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    serial?: string;
    /**
     * A unique tag used to identify this device
     * @type {string}
     * @memberof Device
     */
    asset_tag?: string | null;
    /**
     * 
     * @type {NestedSite}
     * @memberof Device
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedRack}
     * @memberof Device
     */
    rack?: NestedRack | null;
    /**
     * The lowest-numbered unit occupied by the device
     * @type {number}
     * @memberof Device
     */
    position?: number | null;
    /**
     * 
     * @type {Face}
     * @memberof Device
     */
    face?: Face;
    /**
     * 
     * @type {NestedDevice}
     * @memberof Device
     */
    parent_device?: NestedDevice;
    /**
     * 
     * @type {Status2}
     * @memberof Device
     */
    status?: Status2;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof Device
     */
    primary_ip?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof Device
     */
    primary_ip4?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof Device
     */
    primary_ip6?: NestedIPAddress;
    /**
     * 
     * @type {NestedCluster}
     * @memberof Device
     */
    cluster?: NestedCluster | null;
    /**
     * 
     * @type {NestedVirtualChassis}
     * @memberof Device
     */
    virtual_chassis?: NestedVirtualChassis | null;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    vc_position?: number | null;
    /**
     * 
     * @type {number}
     * @memberof Device
     */
    vc_priority?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    local_context_data?: string | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Device
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Device
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Device
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface DeviceBay
 */
export interface DeviceBay {
    /**
     * 
     * @type {number}
     * @memberof DeviceBay
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceBay
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof DeviceBay
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof DeviceBay
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof DeviceBay
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceBay
     */
    description?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof DeviceBay
     */
    installed_device?: NestedDevice;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof DeviceBay
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface DeviceBayTemplate
 */
export interface DeviceBayTemplate {
    /**
     * 
     * @type {number}
     * @memberof DeviceBayTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceBayTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof DeviceBayTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof DeviceBayTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof DeviceBayTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceBayTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface DeviceNAPALM
 */
export interface DeviceNAPALM {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DeviceNAPALM
     */
    method: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface DeviceRole
 */
export interface DeviceRole {
    /**
     * 
     * @type {number}
     * @memberof DeviceRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRole
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceRole
     */
    color?: string;
    /**
     * Virtual machines may be assigned to this role
     * @type {boolean}
     * @memberof DeviceRole
     */
    vm_role?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DeviceRole
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceRole
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof DeviceRole
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface DeviceType
 */
export interface DeviceType {
    /**
     * 
     * @type {number}
     * @memberof DeviceType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    url?: string;
    /**
     * 
     * @type {NestedManufacturer}
     * @memberof DeviceType
     */
    manufacturer: NestedManufacturer;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    display_name?: string;
    /**
     * Discrete part number (optional)
     * @type {string}
     * @memberof DeviceType
     */
    part_number?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceType
     */
    u_height?: number;
    /**
     * Device consumes both front and rear rack faces
     * @type {boolean}
     * @memberof DeviceType
     */
    is_full_depth?: boolean;
    /**
     * 
     * @type {SubdeviceRole}
     * @memberof DeviceType
     */
    subdevice_role?: SubdeviceRole;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    front_image?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    rear_image?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof DeviceType
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof DeviceType
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceType
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof DeviceType
     */
    device_count?: number;
}
/**
 * 
 * @export
 * @interface DeviceWithConfigContext
 */
export interface DeviceWithConfigContext {
    /**
     * 
     * @type {number}
     * @memberof DeviceWithConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    display_name?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof DeviceWithConfigContext
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {NestedDeviceRole}
     * @memberof DeviceWithConfigContext
     */
    device_role: NestedDeviceRole;
    /**
     * 
     * @type {NestedTenant}
     * @memberof DeviceWithConfigContext
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {NestedPlatform}
     * @memberof DeviceWithConfigContext
     */
    platform?: NestedPlatform | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    serial?: string;
    /**
     * A unique tag used to identify this device
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    asset_tag?: string | null;
    /**
     * 
     * @type {NestedSite}
     * @memberof DeviceWithConfigContext
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedRack}
     * @memberof DeviceWithConfigContext
     */
    rack?: NestedRack | null;
    /**
     * The lowest-numbered unit occupied by the device
     * @type {number}
     * @memberof DeviceWithConfigContext
     */
    position?: number | null;
    /**
     * 
     * @type {Face}
     * @memberof DeviceWithConfigContext
     */
    face?: Face;
    /**
     * 
     * @type {NestedDevice}
     * @memberof DeviceWithConfigContext
     */
    parent_device?: NestedDevice;
    /**
     * 
     * @type {Status2}
     * @memberof DeviceWithConfigContext
     */
    status?: Status2;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof DeviceWithConfigContext
     */
    primary_ip?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof DeviceWithConfigContext
     */
    primary_ip4?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof DeviceWithConfigContext
     */
    primary_ip6?: NestedIPAddress;
    /**
     * 
     * @type {NestedCluster}
     * @memberof DeviceWithConfigContext
     */
    cluster?: NestedCluster | null;
    /**
     * 
     * @type {NestedVirtualChassis}
     * @memberof DeviceWithConfigContext
     */
    virtual_chassis?: NestedVirtualChassis | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithConfigContext
     */
    vc_position?: number | null;
    /**
     * 
     * @type {number}
     * @memberof DeviceWithConfigContext
     */
    vc_priority?: number | null;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    local_context_data?: string | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof DeviceWithConfigContext
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof DeviceWithConfigContext
     */
    custom_fields?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof DeviceWithConfigContext
     */
    config_context?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof DeviceWithConfigContext
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface ExportTemplate
 */
export interface ExportTemplate {
    /**
     * 
     * @type {number}
     * @memberof ExportTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ExportTemplate
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportTemplate
     */
    content_type: string;
    /**
     * 
     * @type {string}
     * @memberof ExportTemplate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ExportTemplate
     */
    description?: string;
    /**
     * The list of objects being exported is passed as a context variable named <code>queryset</code>.
     * @type {string}
     * @memberof ExportTemplate
     */
    template_code: string;
    /**
     * Defaults to <code>text/plain</code>
     * @type {string}
     * @memberof ExportTemplate
     */
    mime_type?: string;
    /**
     * Extension to append to the rendered filename
     * @type {string}
     * @memberof ExportTemplate
     */
    file_extension?: string;
}
/**
 * 
 * @export
 * @interface Face
 */
export interface Face {
    /**
     * 
     * @type {string}
     * @memberof Face
     */
    label: FaceLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Face
     */
    value: FaceValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FaceLabelEnum {
    Front = 'Front',
    Rear = 'Rear'
}
/**
    * @export
    * @enum {string}
    */
export enum FaceValueEnum {
    Front = 'front',
    Rear = 'rear'
}

/**
 * 
 * @export
 * @interface Face1
 */
export interface Face1 {
    /**
     * 
     * @type {string}
     * @memberof Face1
     */
    label: Face1LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Face1
     */
    value: Face1ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Face1LabelEnum {
    Front = 'Front',
    Rear = 'Rear'
}
/**
    * @export
    * @enum {string}
    */
export enum Face1ValueEnum {
    Front = 'front',
    Rear = 'rear'
}

/**
 * 
 * @export
 * @interface Family
 */
export interface Family {
    /**
     * 
     * @type {string}
     * @memberof Family
     */
    label: FamilyLabelEnum;
    /**
     * 
     * @type {number}
     * @memberof Family
     */
    value: number;
}

/**
    * @export
    * @enum {string}
    */
export enum FamilyLabelEnum {
    Ipv4 = 'IPv4',
    Ipv6 = 'IPv6'
}

/**
 * 
 * @export
 * @interface FeedLeg
 */
export interface FeedLeg {
    /**
     * 
     * @type {string}
     * @memberof FeedLeg
     */
    label: FeedLegLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof FeedLeg
     */
    value: FeedLegValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FeedLegLabelEnum {
    A = 'A',
    B = 'B',
    C = 'C'
}
/**
    * @export
    * @enum {string}
    */
export enum FeedLegValueEnum {
    A = 'A',
    B = 'B',
    C = 'C'
}

/**
 * 
 * @export
 * @interface FilterLogic
 */
export interface FilterLogic {
    /**
     * 
     * @type {string}
     * @memberof FilterLogic
     */
    label: FilterLogicLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof FilterLogic
     */
    value: FilterLogicValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum FilterLogicLabelEnum {
    Disabled = 'Disabled',
    Loose = 'Loose',
    Exact = 'Exact'
}
/**
    * @export
    * @enum {string}
    */
export enum FilterLogicValueEnum {
    Disabled = 'disabled',
    Loose = 'loose',
    Exact = 'exact'
}

/**
 * 
 * @export
 * @interface FrontPort
 */
export interface FrontPort {
    /**
     * 
     * @type {number}
     * @memberof FrontPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FrontPort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof FrontPort
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof FrontPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof FrontPort
     */
    label?: string;
    /**
     * 
     * @type {Type1}
     * @memberof FrontPort
     */
    type: Type1;
    /**
     * 
     * @type {FrontPortRearPort}
     * @memberof FrontPort
     */
    rear_port: FrontPortRearPort;
    /**
     * 
     * @type {number}
     * @memberof FrontPort
     */
    rear_port_position?: number;
    /**
     * 
     * @type {string}
     * @memberof FrontPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof FrontPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof FrontPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof FrontPort
     */
    cable_peer_type?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof FrontPort
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface FrontPortRearPort
 */
export interface FrontPortRearPort {
    /**
     * 
     * @type {number}
     * @memberof FrontPortRearPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FrontPortRearPort
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof FrontPortRearPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof FrontPortRearPort
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface FrontPortTemplate
 */
export interface FrontPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof FrontPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof FrontPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof FrontPortTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof FrontPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof FrontPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type1}
     * @memberof FrontPortTemplate
     */
    type: Type1;
    /**
     * 
     * @type {NestedRearPortTemplate}
     * @memberof FrontPortTemplate
     */
    rear_port: NestedRearPortTemplate;
    /**
     * 
     * @type {number}
     * @memberof FrontPortTemplate
     */
    rear_port_position?: number;
    /**
     * 
     * @type {string}
     * @memberof FrontPortTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Group
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof Group
     */
    user_count?: number;
}
/**
 * 
 * @export
 * @interface IPAddress
 */
export interface IPAddress {
    /**
     * 
     * @type {number}
     * @memberof IPAddress
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof IPAddress
     */
    url?: string;
    /**
     * 
     * @type {Family}
     * @memberof IPAddress
     */
    family?: Family;
    /**
     * IPv4 or IPv6 address (with mask)
     * @type {string}
     * @memberof IPAddress
     */
    address: string;
    /**
     * 
     * @type {NestedVRF}
     * @memberof IPAddress
     */
    vrf?: NestedVRF | null;
    /**
     * 
     * @type {NestedTenant}
     * @memberof IPAddress
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {Status7}
     * @memberof IPAddress
     */
    status?: Status7;
    /**
     * 
     * @type {Role1}
     * @memberof IPAddress
     */
    role?: Role1;
    /**
     * 
     * @type {string}
     * @memberof IPAddress
     */
    assigned_object_type?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IPAddress
     */
    assigned_object_id?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof IPAddress
     */
    assigned_object?: { [key: string]: string; };
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof IPAddress
     */
    nat_inside?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof IPAddress
     */
    nat_outside?: NestedIPAddress;
    /**
     * Hostname or FQDN (not case-sensitive)
     * @type {string}
     * @memberof IPAddress
     */
    dns_name?: string;
    /**
     * 
     * @type {string}
     * @memberof IPAddress
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof IPAddress
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof IPAddress
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof IPAddress
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof IPAddress
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface ImageAttachment
 */
export interface ImageAttachment {
    /**
     * 
     * @type {number}
     * @memberof ImageAttachment
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    content_type: string;
    /**
     * 
     * @type {number}
     * @memberof ImageAttachment
     */
    object_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ImageAttachment
     */
    parent?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    image?: string;
    /**
     * 
     * @type {number}
     * @memberof ImageAttachment
     */
    image_height: number;
    /**
     * 
     * @type {number}
     * @memberof ImageAttachment
     */
    image_width: number;
    /**
     * 
     * @type {string}
     * @memberof ImageAttachment
     */
    created?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse200
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CircuitTermination>}
     * @memberof InlineResponse200
     */
    results: Array<CircuitTermination>;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2001
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2001
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CircuitType>}
     * @memberof InlineResponse2001
     */
    results: Array<CircuitType>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20010
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceBay>}
     * @memberof InlineResponse20010
     */
    results: Array<DeviceBay>;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20011
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceRole>}
     * @memberof InlineResponse20011
     */
    results: Array<DeviceRole>;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20012
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceType>}
     * @memberof InlineResponse20012
     */
    results: Array<DeviceType>;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20013
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceWithConfigContext>}
     * @memberof InlineResponse20013
     */
    results: Array<DeviceWithConfigContext>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20014
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FrontPortTemplate>}
     * @memberof InlineResponse20014
     */
    results: Array<FrontPortTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20015
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20015
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<FrontPort>}
     * @memberof InlineResponse20015
     */
    results: Array<FrontPort>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20016
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20016
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InterfaceConnection>}
     * @memberof InlineResponse20016
     */
    results: Array<InterfaceConnection>;
}
/**
 * 
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20017
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20017
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InterfaceTemplate>}
     * @memberof InlineResponse20017
     */
    results: Array<InterfaceTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20018
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20018
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Interface>}
     * @memberof InlineResponse20018
     */
    results: Array<Interface>;
}
/**
 * 
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20019
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20019
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<InventoryItem>}
     * @memberof InlineResponse20019
     */
    results: Array<InventoryItem>;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2002
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Circuit>}
     * @memberof InlineResponse2002
     */
    results: Array<Circuit>;
}
/**
 * 
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20020
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20020
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Manufacturer>}
     * @memberof InlineResponse20020
     */
    results: Array<Manufacturer>;
}
/**
 * 
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20021
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20021
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Platform>}
     * @memberof InlineResponse20021
     */
    results: Array<Platform>;
}
/**
 * 
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20022
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20022
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20022
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerPort>}
     * @memberof InlineResponse20022
     */
    results: Array<PowerPort>;
}
/**
 * 
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20023
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20023
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerFeed>}
     * @memberof InlineResponse20023
     */
    results: Array<PowerFeed>;
}
/**
 * 
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20024
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20024
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerOutletTemplate>}
     * @memberof InlineResponse20024
     */
    results: Array<PowerOutletTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20025
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20025
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20025
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerOutlet>}
     * @memberof InlineResponse20025
     */
    results: Array<PowerOutlet>;
}
/**
 * 
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20026
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20026
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerPanel>}
     * @memberof InlineResponse20026
     */
    results: Array<PowerPanel>;
}
/**
 * 
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20027
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20027
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<PowerPortTemplate>}
     * @memberof InlineResponse20027
     */
    results: Array<PowerPortTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20028
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20028
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RackGroup>}
     * @memberof InlineResponse20028
     */
    results: Array<RackGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20029
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20029
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RackReservation>}
     * @memberof InlineResponse20029
     */
    results: Array<RackReservation>;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2003
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Provider>}
     * @memberof InlineResponse2003
     */
    results: Array<Provider>;
}
/**
 * 
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20030
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20030
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RackRole>}
     * @memberof InlineResponse20030
     */
    results: Array<RackRole>;
}
/**
 * 
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20031
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20031
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Rack>}
     * @memberof InlineResponse20031
     */
    results: Array<Rack>;
}
/**
 * 
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20032
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20032
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RearPortTemplate>}
     * @memberof InlineResponse20032
     */
    results: Array<RearPortTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20033
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20033
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RearPort>}
     * @memberof InlineResponse20033
     */
    results: Array<RearPort>;
}
/**
 * 
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20034
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20034
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Region>}
     * @memberof InlineResponse20034
     */
    results: Array<Region>;
}
/**
 * 
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20035
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20035
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Site>}
     * @memberof InlineResponse20035
     */
    results: Array<Site>;
}
/**
 * 
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20036
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20036
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VirtualChassis>}
     * @memberof InlineResponse20036
     */
    results: Array<VirtualChassis>;
}
/**
 * 
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20037
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20037
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ConfigContext>}
     * @memberof InlineResponse20037
     */
    results: Array<ConfigContext>;
}
/**
 * 
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20038
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20038
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ContentType>}
     * @memberof InlineResponse20038
     */
    results: Array<ContentType>;
}
/**
 * 
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20039
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20039
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20039
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<CustomField>}
     * @memberof InlineResponse20039
     */
    results: Array<CustomField>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2004
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Cable>}
     * @memberof InlineResponse2004
     */
    results: Array<Cable>;
}
/**
 * 
 * @export
 * @interface InlineResponse20040
 */
export interface InlineResponse20040 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20040
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20040
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ExportTemplate>}
     * @memberof InlineResponse20040
     */
    results: Array<ExportTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20041
 */
export interface InlineResponse20041 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20041
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20041
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ImageAttachment>}
     * @memberof InlineResponse20041
     */
    results: Array<ImageAttachment>;
}
/**
 * 
 * @export
 * @interface InlineResponse20042
 */
export interface InlineResponse20042 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20042
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20042
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<JobResult>}
     * @memberof InlineResponse20042
     */
    results: Array<JobResult>;
}
/**
 * 
 * @export
 * @interface InlineResponse20043
 */
export interface InlineResponse20043 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20043
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20043
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ObjectChange>}
     * @memberof InlineResponse20043
     */
    results: Array<ObjectChange>;
}
/**
 * 
 * @export
 * @interface InlineResponse20044
 */
export interface InlineResponse20044 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20044
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20044
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InlineResponse20044
     */
    results: Array<Tag>;
}
/**
 * 
 * @export
 * @interface InlineResponse20045
 */
export interface InlineResponse20045 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20045
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20045
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Aggregate>}
     * @memberof InlineResponse20045
     */
    results: Array<Aggregate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20046
 */
export interface InlineResponse20046 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20046
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20046
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20046
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<IPAddress>}
     * @memberof InlineResponse20046
     */
    results: Array<IPAddress>;
}
/**
 * 
 * @export
 * @interface InlineResponse20047
 */
export interface InlineResponse20047 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20047
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20047
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Prefix>}
     * @memberof InlineResponse20047
     */
    results: Array<Prefix>;
}
/**
 * 
 * @export
 * @interface InlineResponse20048
 */
export interface InlineResponse20048 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20048
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20048
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RIR>}
     * @memberof InlineResponse20048
     */
    results: Array<RIR>;
}
/**
 * 
 * @export
 * @interface InlineResponse20049
 */
export interface InlineResponse20049 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20049
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20049
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20049
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Role>}
     * @memberof InlineResponse20049
     */
    results: Array<Role>;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ConsolePort>}
     * @memberof InlineResponse2005
     */
    results: Array<ConsolePort>;
}
/**
 * 
 * @export
 * @interface InlineResponse20050
 */
export interface InlineResponse20050 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20050
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20050
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<RouteTarget>}
     * @memberof InlineResponse20050
     */
    results: Array<RouteTarget>;
}
/**
 * 
 * @export
 * @interface InlineResponse20051
 */
export interface InlineResponse20051 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20051
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20051
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Service>}
     * @memberof InlineResponse20051
     */
    results: Array<Service>;
}
/**
 * 
 * @export
 * @interface InlineResponse20052
 */
export interface InlineResponse20052 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20052
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20052
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VLANGroup>}
     * @memberof InlineResponse20052
     */
    results: Array<VLANGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse20053
 */
export interface InlineResponse20053 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20053
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20053
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VLAN>}
     * @memberof InlineResponse20053
     */
    results: Array<VLAN>;
}
/**
 * 
 * @export
 * @interface InlineResponse20054
 */
export interface InlineResponse20054 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20054
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20054
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VRF>}
     * @memberof InlineResponse20054
     */
    results: Array<VRF>;
}
/**
 * 
 * @export
 * @interface InlineResponse20055
 */
export interface InlineResponse20055 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20055
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20055
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20055
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<SecretRole>}
     * @memberof InlineResponse20055
     */
    results: Array<SecretRole>;
}
/**
 * 
 * @export
 * @interface InlineResponse20056
 */
export interface InlineResponse20056 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20056
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20056
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Secret>}
     * @memberof InlineResponse20056
     */
    results: Array<Secret>;
}
/**
 * 
 * @export
 * @interface InlineResponse20057
 */
export interface InlineResponse20057 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20057
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20057
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<TenantGroup>}
     * @memberof InlineResponse20057
     */
    results: Array<TenantGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse20058
 */
export interface InlineResponse20058 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20058
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20058
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Tenant>}
     * @memberof InlineResponse20058
     */
    results: Array<Tenant>;
}
/**
 * 
 * @export
 * @interface InlineResponse20059
 */
export interface InlineResponse20059 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20059
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20059
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Group>}
     * @memberof InlineResponse20059
     */
    results: Array<Group>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2006
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ConsolePortTemplate>}
     * @memberof InlineResponse2006
     */
    results: Array<ConsolePortTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse20060
 */
export interface InlineResponse20060 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20060
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20060
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ObjectPermission>}
     * @memberof InlineResponse20060
     */
    results: Array<ObjectPermission>;
}
/**
 * 
 * @export
 * @interface InlineResponse20061
 */
export interface InlineResponse20061 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20061
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20061
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<User>}
     * @memberof InlineResponse20061
     */
    results: Array<User>;
}
/**
 * 
 * @export
 * @interface InlineResponse20062
 */
export interface InlineResponse20062 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20062
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20062
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ClusterGroup>}
     * @memberof InlineResponse20062
     */
    results: Array<ClusterGroup>;
}
/**
 * 
 * @export
 * @interface InlineResponse20063
 */
export interface InlineResponse20063 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20063
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20063
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ClusterType>}
     * @memberof InlineResponse20063
     */
    results: Array<ClusterType>;
}
/**
 * 
 * @export
 * @interface InlineResponse20064
 */
export interface InlineResponse20064 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20064
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20064
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20064
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<Cluster>}
     * @memberof InlineResponse20064
     */
    results: Array<Cluster>;
}
/**
 * 
 * @export
 * @interface InlineResponse20065
 */
export interface InlineResponse20065 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20065
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20065
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VMInterface>}
     * @memberof InlineResponse20065
     */
    results: Array<VMInterface>;
}
/**
 * 
 * @export
 * @interface InlineResponse20066
 */
export interface InlineResponse20066 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse20066
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20066
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<VirtualMachineWithConfigContext>}
     * @memberof InlineResponse20066
     */
    results: Array<VirtualMachineWithConfigContext>;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ConsoleServerPortTemplate>}
     * @memberof InlineResponse2007
     */
    results: Array<ConsoleServerPortTemplate>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2008
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<ConsoleServerPort>}
     * @memberof InlineResponse2008
     */
    results: Array<ConsoleServerPort>;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2009
     */
    count: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    next?: string | null;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009
     */
    previous?: string | null;
    /**
     * 
     * @type {Array<DeviceBayTemplate>}
     * @memberof InlineResponse2009
     */
    results: Array<DeviceBayTemplate>;
}
/**
 * 
 * @export
 * @interface Interface
 */
export interface Interface {
    /**
     * 
     * @type {number}
     * @memberof Interface
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof Interface
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof Interface
     */
    label?: string;
    /**
     * 
     * @type {Type2}
     * @memberof Interface
     */
    type: Type2;
    /**
     * 
     * @type {boolean}
     * @memberof Interface
     */
    enabled?: boolean;
    /**
     * 
     * @type {NestedInterface}
     * @memberof Interface
     */
    lag?: NestedInterface;
    /**
     * 
     * @type {number}
     * @memberof Interface
     */
    mtu?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    mac_address?: string | null;
    /**
     * This interface is used only for out-of-band management
     * @type {boolean}
     * @memberof Interface
     */
    mgmt_only?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    description?: string;
    /**
     * 
     * @type {Mode}
     * @memberof Interface
     */
    mode?: Mode;
    /**
     * 
     * @type {NestedVLAN}
     * @memberof Interface
     */
    untagged_vlan?: NestedVLAN | null;
    /**
     * 
     * @type {Set<NestedVLAN>}
     * @memberof Interface
     */
    tagged_vlans?: Set<NestedVLAN>;
    /**
     * 
     * @type {NestedCable}
     * @memberof Interface
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof Interface
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof Interface
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Interface
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Interface
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Interface
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {number}
     * @memberof Interface
     */
    count_ipaddresses?: number;
}
/**
 * 
 * @export
 * @interface InterfaceConnection
 */
export interface InterfaceConnection {
    /**
     * 
     * @type {NestedInterface}
     * @memberof InterfaceConnection
     */
    interface_a?: NestedInterface;
    /**
     * 
     * @type {NestedInterface}
     * @memberof InterfaceConnection
     */
    interface_b: NestedInterface;
    /**
     * 
     * @type {boolean}
     * @memberof InterfaceConnection
     */
    connected_endpoint_reachable?: boolean;
}
/**
 * 
 * @export
 * @interface InterfaceTemplate
 */
export interface InterfaceTemplate {
    /**
     * 
     * @type {number}
     * @memberof InterfaceTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InterfaceTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof InterfaceTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof InterfaceTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof InterfaceTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type2}
     * @memberof InterfaceTemplate
     */
    type: Type2;
    /**
     * 
     * @type {boolean}
     * @memberof InterfaceTemplate
     */
    mgmt_only?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InterfaceTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface InventoryItem
 */
export interface InventoryItem {
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof InventoryItem
     */
    device: NestedDevice;
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    parent?: number | null;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof InventoryItem
     */
    label?: string;
    /**
     * 
     * @type {NestedManufacturer}
     * @memberof InventoryItem
     */
    manufacturer?: NestedManufacturer;
    /**
     * Manufacturer-assigned part identifier
     * @type {string}
     * @memberof InventoryItem
     */
    part_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    serial?: string;
    /**
     * A unique tag used to identify this item
     * @type {string}
     * @memberof InventoryItem
     */
    asset_tag?: string | null;
    /**
     * This item was automatically discovered
     * @type {boolean}
     * @memberof InventoryItem
     */
    discovered?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InventoryItem
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof InventoryItem
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {number}
     * @memberof InventoryItem
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface JobResult
 */
export interface JobResult {
    /**
     * 
     * @type {number}
     * @memberof JobResult
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    completed?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    obj_type?: string;
    /**
     * 
     * @type {Status6}
     * @memberof JobResult
     */
    status?: Status6;
    /**
     * 
     * @type {NestedUser}
     * @memberof JobResult
     */
    user?: NestedUser;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    data?: string | null;
    /**
     * 
     * @type {string}
     * @memberof JobResult
     */
    job_id: string;
}
/**
 * 
 * @export
 * @interface LengthUnit
 */
export interface LengthUnit {
    /**
     * 
     * @type {string}
     * @memberof LengthUnit
     */
    label: LengthUnitLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof LengthUnit
     */
    value: LengthUnitValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LengthUnitLabelEnum {
    Meters = 'Meters',
    Centimeters = 'Centimeters',
    Feet = 'Feet',
    Inches = 'Inches'
}
/**
    * @export
    * @enum {string}
    */
export enum LengthUnitValueEnum {
    M = 'm',
    Cm = 'cm',
    Ft = 'ft',
    In = 'in'
}

/**
 * 
 * @export
 * @interface Manufacturer
 */
export interface Manufacturer {
    /**
     * 
     * @type {number}
     * @memberof Manufacturer
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof Manufacturer
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Manufacturer
     */
    devicetype_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Manufacturer
     */
    inventoryitem_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Manufacturer
     */
    platform_count?: number;
}
/**
 * 
 * @export
 * @interface Mode
 */
export interface Mode {
    /**
     * 
     * @type {string}
     * @memberof Mode
     */
    label: ModeLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Mode
     */
    value: ModeValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ModeLabelEnum {
    Access = 'Access',
    Tagged = 'Tagged',
    TaggedAll = 'Tagged (All)'
}
/**
    * @export
    * @enum {string}
    */
export enum ModeValueEnum {
    Access = 'access',
    Tagged = 'tagged',
    TaggedAll = 'tagged-all'
}

/**
 * 
 * @export
 * @interface NestedCable
 */
export interface NestedCable {
    /**
     * 
     * @type {number}
     * @memberof NestedCable
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedCable
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedCable
     */
    label?: string;
}
/**
 * 
 * @export
 * @interface NestedCircuit
 */
export interface NestedCircuit {
    /**
     * 
     * @type {number}
     * @memberof NestedCircuit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedCircuit
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedCircuit
     */
    cid: string;
}
/**
 * 
 * @export
 * @interface NestedCircuitType
 */
export interface NestedCircuitType {
    /**
     * 
     * @type {number}
     * @memberof NestedCircuitType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedCircuitType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedCircuitType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedCircuitType
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedCircuitType
     */
    circuit_count?: number;
}
/**
 * 
 * @export
 * @interface NestedCluster
 */
export interface NestedCluster {
    /**
     * 
     * @type {number}
     * @memberof NestedCluster
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedCluster
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedCluster
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof NestedCluster
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface NestedClusterGroup
 */
export interface NestedClusterGroup {
    /**
     * 
     * @type {number}
     * @memberof NestedClusterGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedClusterGroup
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface NestedClusterType
 */
export interface NestedClusterType {
    /**
     * 
     * @type {number}
     * @memberof NestedClusterType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterType
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterType
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedClusterType
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedClusterType
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface NestedDevice
 */
export interface NestedDevice {
    /**
     * 
     * @type {number}
     * @memberof NestedDevice
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedDevice
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedDevice
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedDevice
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface NestedDeviceRole
 */
export interface NestedDeviceRole {
    /**
     * 
     * @type {number}
     * @memberof NestedDeviceRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceRole
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedDeviceRole
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedDeviceRole
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface NestedDeviceType
 */
export interface NestedDeviceType {
    /**
     * 
     * @type {number}
     * @memberof NestedDeviceType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceType
     */
    url?: string;
    /**
     * 
     * @type {NestedManufacturer}
     * @memberof NestedDeviceType
     */
    manufacturer?: NestedManufacturer;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceType
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceType
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof NestedDeviceType
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof NestedDeviceType
     */
    device_count?: number;
}
/**
 * 
 * @export
 * @interface NestedGroup
 */
export interface NestedGroup {
    /**
     * 
     * @type {number}
     * @memberof NestedGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedGroup
     */
    name: string;
}
/**
 * 
 * @export
 * @interface NestedIPAddress
 */
export interface NestedIPAddress {
    /**
     * 
     * @type {number}
     * @memberof NestedIPAddress
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedIPAddress
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof NestedIPAddress
     */
    family?: number;
    /**
     * IPv4 or IPv6 address (with mask)
     * @type {string}
     * @memberof NestedIPAddress
     */
    address: string;
}
/**
 * 
 * @export
 * @interface NestedInterface
 */
export interface NestedInterface {
    /**
     * 
     * @type {number}
     * @memberof NestedInterface
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedInterface
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof NestedInterface
     */
    device?: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof NestedInterface
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof NestedInterface
     */
    cable?: number | null;
}
/**
 * 
 * @export
 * @interface NestedManufacturer
 */
export interface NestedManufacturer {
    /**
     * 
     * @type {number}
     * @memberof NestedManufacturer
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedManufacturer
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedManufacturer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedManufacturer
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedManufacturer
     */
    devicetype_count?: number;
}
/**
 * 
 * @export
 * @interface NestedPlatform
 */
export interface NestedPlatform {
    /**
     * 
     * @type {number}
     * @memberof NestedPlatform
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedPlatform
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedPlatform
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedPlatform
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedPlatform
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedPlatform
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface NestedPowerPanel
 */
export interface NestedPowerPanel {
    /**
     * 
     * @type {number}
     * @memberof NestedPowerPanel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPanel
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPanel
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof NestedPowerPanel
     */
    powerfeed_count?: number;
}
/**
 * 
 * @export
 * @interface NestedPowerPort
 */
export interface NestedPowerPort {
    /**
     * 
     * @type {number}
     * @memberof NestedPowerPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof NestedPowerPort
     */
    device?: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPort
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof NestedPowerPort
     */
    cable?: number | null;
}
/**
 * 
 * @export
 * @interface NestedPowerPortTemplate
 */
export interface NestedPowerPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof NestedPowerPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedPowerPortTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface NestedProvider
 */
export interface NestedProvider {
    /**
     * 
     * @type {number}
     * @memberof NestedProvider
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedProvider
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedProvider
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedProvider
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedProvider
     */
    circuit_count?: number;
}
/**
 * 
 * @export
 * @interface NestedRIR
 */
export interface NestedRIR {
    /**
     * 
     * @type {number}
     * @memberof NestedRIR
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRIR
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRIR
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRIR
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRIR
     */
    aggregate_count?: number;
}
/**
 * 
 * @export
 * @interface NestedRack
 */
export interface NestedRack {
    /**
     * 
     * @type {number}
     * @memberof NestedRack
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRack
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRack
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRack
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRack
     */
    device_count?: number;
}
/**
 * 
 * @export
 * @interface NestedRackGroup
 */
export interface NestedRackGroup {
    /**
     * 
     * @type {number}
     * @memberof NestedRackGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRackGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRackGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRackGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRackGroup
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRackGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface NestedRackRole
 */
export interface NestedRackRole {
    /**
     * 
     * @type {number}
     * @memberof NestedRackRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRackRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRackRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRackRole
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRackRole
     */
    rack_count?: number;
}
/**
 * 
 * @export
 * @interface NestedRearPortTemplate
 */
export interface NestedRearPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof NestedRearPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRearPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRearPortTemplate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface NestedRegion
 */
export interface NestedRegion {
    /**
     * 
     * @type {number}
     * @memberof NestedRegion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRegion
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRegion
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRegion
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRegion
     */
    site_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRegion
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface NestedRole
 */
export interface NestedRole {
    /**
     * 
     * @type {number}
     * @memberof NestedRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedRole
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedRole
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedRole
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface NestedRouteTarget
 */
export interface NestedRouteTarget {
    /**
     * 
     * @type {number}
     * @memberof NestedRouteTarget
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedRouteTarget
     */
    url?: string;
    /**
     * Route target value (formatted in accordance with RFC 4360)
     * @type {string}
     * @memberof NestedRouteTarget
     */
    name: string;
}
/**
 * 
 * @export
 * @interface NestedSecretRole
 */
export interface NestedSecretRole {
    /**
     * 
     * @type {number}
     * @memberof NestedSecretRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedSecretRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedSecretRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedSecretRole
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedSecretRole
     */
    secret_count?: number;
}
/**
 * 
 * @export
 * @interface NestedSite
 */
export interface NestedSite {
    /**
     * 
     * @type {number}
     * @memberof NestedSite
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedSite
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedSite
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedSite
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface NestedTag
 */
export interface NestedTag {
    /**
     * 
     * @type {number}
     * @memberof NestedTag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedTag
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTag
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTag
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTag
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface NestedTenant
 */
export interface NestedTenant {
    /**
     * 
     * @type {number}
     * @memberof NestedTenant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedTenant
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTenant
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTenant
     */
    slug: string;
}
/**
 * 
 * @export
 * @interface NestedTenantGroup
 */
export interface NestedTenantGroup {
    /**
     * 
     * @type {number}
     * @memberof NestedTenantGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedTenantGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTenantGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedTenantGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedTenantGroup
     */
    tenant_count?: number;
    /**
     * 
     * @type {number}
     * @memberof NestedTenantGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface NestedUser
 */
export interface NestedUser {
    /**
     * 
     * @type {number}
     * @memberof NestedUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedUser
     */
    url?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof NestedUser
     */
    username: string;
}
/**
 * 
 * @export
 * @interface NestedVLAN
 */
export interface NestedVLAN {
    /**
     * 
     * @type {number}
     * @memberof NestedVLAN
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVLAN
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof NestedVLAN
     */
    vid: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVLAN
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVLAN
     */
    display_name?: string;
}
/**
 * 
 * @export
 * @interface NestedVLANGroup
 */
export interface NestedVLANGroup {
    /**
     * 
     * @type {number}
     * @memberof NestedVLANGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVLANGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVLANGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVLANGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof NestedVLANGroup
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface NestedVRF
 */
export interface NestedVRF {
    /**
     * 
     * @type {number}
     * @memberof NestedVRF
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVRF
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVRF
     */
    name: string;
    /**
     * Unique route distinguisher (as defined in RFC 4364)
     * @type {string}
     * @memberof NestedVRF
     */
    rd?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NestedVRF
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof NestedVRF
     */
    prefix_count?: number;
}
/**
 * 
 * @export
 * @interface NestedVirtualChassis
 */
export interface NestedVirtualChassis {
    /**
     * 
     * @type {number}
     * @memberof NestedVirtualChassis
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVirtualChassis
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVirtualChassis
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof NestedVirtualChassis
     */
    master: NestedDevice;
    /**
     * 
     * @type {number}
     * @memberof NestedVirtualChassis
     */
    member_count?: number;
}
/**
 * 
 * @export
 * @interface NestedVirtualMachine
 */
export interface NestedVirtualMachine {
    /**
     * 
     * @type {number}
     * @memberof NestedVirtualMachine
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof NestedVirtualMachine
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof NestedVirtualMachine
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ObjectChange
 */
export interface ObjectChange {
    /**
     * 
     * @type {number}
     * @memberof ObjectChange
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    time?: string;
    /**
     * 
     * @type {NestedUser}
     * @memberof ObjectChange
     */
    user?: NestedUser;
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    user_name?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    request_id?: string;
    /**
     * 
     * @type {Action}
     * @memberof ObjectChange
     */
    action?: Action;
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    changed_object_type?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectChange
     */
    changed_object_id: number;
    /**
     *  Serialize a nested representation of the changed object. 
     * @type {{ [key: string]: string; }}
     * @memberof ObjectChange
     */
    changed_object?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof ObjectChange
     */
    object_data?: string;
}
/**
 * 
 * @export
 * @interface ObjectPermission
 */
export interface ObjectPermission {
    /**
     * 
     * @type {number}
     * @memberof ObjectPermission
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ObjectPermission
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectPermission
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ObjectPermission
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ObjectPermission
     */
    enabled?: boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof ObjectPermission
     */
    object_types: Set<string>;
    /**
     * 
     * @type {Set<NestedGroup>}
     * @memberof ObjectPermission
     */
    groups?: Set<NestedGroup>;
    /**
     * 
     * @type {Set<NestedUser>}
     * @memberof ObjectPermission
     */
    users?: Set<NestedUser>;
    /**
     * The list of actions granted by this permission
     * @type {Array<string>}
     * @memberof ObjectPermission
     */
    actions: Array<string>;
    /**
     * Queryset filter matching the applicable objects of the selected type(s)
     * @type {string}
     * @memberof ObjectPermission
     */
    constraints?: string | null;
}
/**
 * 
 * @export
 * @interface OuterUnit
 */
export interface OuterUnit {
    /**
     * 
     * @type {string}
     * @memberof OuterUnit
     */
    label: OuterUnitLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof OuterUnit
     */
    value: OuterUnitValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum OuterUnitLabelEnum {
    Millimeters = 'Millimeters',
    Inches = 'Inches'
}
/**
    * @export
    * @enum {string}
    */
export enum OuterUnitValueEnum {
    Mm = 'mm',
    In = 'in'
}

/**
 * 
 * @export
 * @interface Phase
 */
export interface Phase {
    /**
     * 
     * @type {string}
     * @memberof Phase
     */
    label: PhaseLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Phase
     */
    value: PhaseValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PhaseLabelEnum {
    SinglePhase = 'Single phase',
    ThreePhase = 'Three-phase'
}
/**
    * @export
    * @enum {string}
    */
export enum PhaseValueEnum {
    SinglePhase = 'single-phase',
    ThreePhase = 'three-phase'
}

/**
 * 
 * @export
 * @interface Platform
 */
export interface Platform {
    /**
     * 
     * @type {number}
     * @memberof Platform
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    slug: string;
    /**
     * 
     * @type {NestedManufacturer}
     * @memberof Platform
     */
    manufacturer?: NestedManufacturer;
    /**
     * The name of the NAPALM driver to use when interacting with devices
     * @type {string}
     * @memberof Platform
     */
    napalm_driver?: string;
    /**
     * Additional arguments to pass when initiating the NAPALM driver (JSON format)
     * @type {string}
     * @memberof Platform
     */
    napalm_args?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Platform
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Platform
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Platform
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface PowerFeed
 */
export interface PowerFeed {
    /**
     * 
     * @type {number}
     * @memberof PowerFeed
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    url?: string;
    /**
     * 
     * @type {NestedPowerPanel}
     * @memberof PowerFeed
     */
    power_panel: NestedPowerPanel;
    /**
     * 
     * @type {NestedRack}
     * @memberof PowerFeed
     */
    rack?: NestedRack | null;
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    name: string;
    /**
     * 
     * @type {Status3}
     * @memberof PowerFeed
     */
    status?: Status3;
    /**
     * 
     * @type {Type4}
     * @memberof PowerFeed
     */
    type?: Type4;
    /**
     * 
     * @type {Supply}
     * @memberof PowerFeed
     */
    supply?: Supply;
    /**
     * 
     * @type {Phase}
     * @memberof PowerFeed
     */
    phase?: Phase;
    /**
     * 
     * @type {number}
     * @memberof PowerFeed
     */
    voltage?: number;
    /**
     * 
     * @type {number}
     * @memberof PowerFeed
     */
    amperage?: number;
    /**
     * Maximum permissible draw (percentage)
     * @type {number}
     * @memberof PowerFeed
     */
    max_utilization?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    comments?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof PowerFeed
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerFeed
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerFeed
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PowerFeed
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof PowerFeed
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof PowerFeed
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof PowerFeed
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface PowerOutlet
 */
export interface PowerOutlet {
    /**
     * 
     * @type {number}
     * @memberof PowerOutlet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerOutlet
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof PowerOutlet
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof PowerOutlet
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof PowerOutlet
     */
    label?: string;
    /**
     * 
     * @type {Type5}
     * @memberof PowerOutlet
     */
    type?: Type5;
    /**
     * 
     * @type {NestedPowerPort}
     * @memberof PowerOutlet
     */
    power_port?: NestedPowerPort;
    /**
     * 
     * @type {FeedLeg}
     * @memberof PowerOutlet
     */
    feed_leg?: FeedLeg;
    /**
     * 
     * @type {string}
     * @memberof PowerOutlet
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof PowerOutlet
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerOutlet
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerOutlet
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerOutlet
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerOutlet
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PowerOutlet
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof PowerOutlet
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface PowerOutletTemplate
 */
export interface PowerOutletTemplate {
    /**
     * 
     * @type {number}
     * @memberof PowerOutletTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerOutletTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof PowerOutletTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof PowerOutletTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof PowerOutletTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type5}
     * @memberof PowerOutletTemplate
     */
    type?: Type5;
    /**
     * 
     * @type {NestedPowerPortTemplate}
     * @memberof PowerOutletTemplate
     */
    power_port?: NestedPowerPortTemplate;
    /**
     * 
     * @type {FeedLeg}
     * @memberof PowerOutletTemplate
     */
    feed_leg?: FeedLeg;
    /**
     * 
     * @type {string}
     * @memberof PowerOutletTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface PowerPanel
 */
export interface PowerPanel {
    /**
     * 
     * @type {number}
     * @memberof PowerPanel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerPanel
     */
    url?: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof PowerPanel
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedRackGroup}
     * @memberof PowerPanel
     */
    rack_group?: NestedRackGroup | null;
    /**
     * 
     * @type {string}
     * @memberof PowerPanel
     */
    name: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof PowerPanel
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof PowerPanel
     */
    custom_fields?: object;
    /**
     * 
     * @type {number}
     * @memberof PowerPanel
     */
    powerfeed_count?: number;
}
/**
 * 
 * @export
 * @interface PowerPort
 */
export interface PowerPort {
    /**
     * 
     * @type {number}
     * @memberof PowerPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerPort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof PowerPort
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof PowerPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof PowerPort
     */
    label?: string;
    /**
     * 
     * @type {Type3}
     * @memberof PowerPort
     */
    type?: Type3;
    /**
     * Maximum power draw (watts)
     * @type {number}
     * @memberof PowerPort
     */
    maximum_draw?: number | null;
    /**
     * Allocated power draw (watts)
     * @type {number}
     * @memberof PowerPort
     */
    allocated_draw?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PowerPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof PowerPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerPort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof PowerPort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PowerPort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PowerPort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof PowerPort
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface PowerPortTemplate
 */
export interface PowerPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof PowerPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof PowerPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof PowerPortTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof PowerPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof PowerPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type3}
     * @memberof PowerPortTemplate
     */
    type?: Type3;
    /**
     * Maximum power draw (watts)
     * @type {number}
     * @memberof PowerPortTemplate
     */
    maximum_draw?: number | null;
    /**
     * Allocated power draw (watts)
     * @type {number}
     * @memberof PowerPortTemplate
     */
    allocated_draw?: number | null;
    /**
     * 
     * @type {string}
     * @memberof PowerPortTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Prefix
 */
export interface Prefix {
    /**
     * 
     * @type {number}
     * @memberof Prefix
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Prefix
     */
    url?: string;
    /**
     * 
     * @type {Family}
     * @memberof Prefix
     */
    family?: Family;
    /**
     * IPv4 or IPv6 network with mask
     * @type {string}
     * @memberof Prefix
     */
    prefix: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof Prefix
     */
    site?: NestedSite;
    /**
     * 
     * @type {NestedVRF}
     * @memberof Prefix
     */
    vrf?: NestedVRF | null;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Prefix
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {NestedVLAN}
     * @memberof Prefix
     */
    vlan?: NestedVLAN | null;
    /**
     * 
     * @type {Status8}
     * @memberof Prefix
     */
    status?: Status8;
    /**
     * 
     * @type {NestedRole}
     * @memberof Prefix
     */
    role?: NestedRole | null;
    /**
     * All IP addresses within this prefix are considered usable
     * @type {boolean}
     * @memberof Prefix
     */
    is_pool?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Prefix
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Prefix
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Prefix
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Prefix
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Prefix
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface PrefixLength
 */
export interface PrefixLength {
    /**
     * 
     * @type {number}
     * @memberof PrefixLength
     */
    prefix_length: number;
}
/**
 * 
 * @export
 * @interface Protocol
 */
export interface Protocol {
    /**
     * 
     * @type {string}
     * @memberof Protocol
     */
    label: ProtocolLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Protocol
     */
    value: ProtocolValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ProtocolLabelEnum {
    Tcp = 'TCP',
    Udp = 'UDP'
}
/**
    * @export
    * @enum {string}
    */
export enum ProtocolValueEnum {
    Tcp = 'tcp',
    Udp = 'udp'
}

/**
 * 
 * @export
 * @interface Provider
 */
export interface Provider {
    /**
     * 
     * @type {number}
     * @memberof Provider
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    slug: string;
    /**
     * 32-bit autonomous system number
     * @type {number}
     * @memberof Provider
     */
    asn?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    account?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    portal_url?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    noc_contact?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    admin_contact?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Provider
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Provider
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Provider
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof Provider
     */
    circuit_count?: number;
}
/**
 * 
 * @export
 * @interface RIR
 */
export interface RIR {
    /**
     * 
     * @type {number}
     * @memberof RIR
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RIR
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof RIR
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RIR
     */
    slug: string;
    /**
     * IP space managed by this RIR is considered private
     * @type {boolean}
     * @memberof RIR
     */
    is_private?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RIR
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof RIR
     */
    aggregate_count?: number;
}
/**
 * 
 * @export
 * @interface Rack
 */
export interface Rack {
    /**
     * 
     * @type {number}
     * @memberof Rack
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    name: string;
    /**
     * Locally-assigned identifier
     * @type {string}
     * @memberof Rack
     */
    facility_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    display_name?: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof Rack
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedRackGroup}
     * @memberof Rack
     */
    group?: NestedRackGroup | null;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Rack
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {Status4}
     * @memberof Rack
     */
    status?: Status4;
    /**
     * 
     * @type {NestedRackRole}
     * @memberof Rack
     */
    role?: NestedRackRole | null;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    serial?: string;
    /**
     * A unique tag used to identify this rack
     * @type {string}
     * @memberof Rack
     */
    asset_tag?: string | null;
    /**
     * 
     * @type {Type6}
     * @memberof Rack
     */
    type?: Type6;
    /**
     * 
     * @type {Width}
     * @memberof Rack
     */
    width?: Width;
    /**
     * Height in rack units
     * @type {number}
     * @memberof Rack
     */
    u_height?: number;
    /**
     * Units are numbered top-to-bottom
     * @type {boolean}
     * @memberof Rack
     */
    desc_units?: boolean;
    /**
     * Outer dimension of rack (width)
     * @type {number}
     * @memberof Rack
     */
    outer_width?: number | null;
    /**
     * Outer dimension of rack (depth)
     * @type {number}
     * @memberof Rack
     */
    outer_depth?: number | null;
    /**
     * 
     * @type {OuterUnit}
     * @memberof Rack
     */
    outer_unit?: OuterUnit;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Rack
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Rack
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Rack
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof Rack
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Rack
     */
    powerfeed_count?: number;
}
/**
 * 
 * @export
 * @interface RackGroup
 */
export interface RackGroup {
    /**
     * 
     * @type {number}
     * @memberof RackGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RackGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof RackGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RackGroup
     */
    slug: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof RackGroup
     */
    site: NestedSite;
    /**
     * 
     * @type {NestedRackGroup}
     * @memberof RackGroup
     */
    parent?: NestedRackGroup | null;
    /**
     * 
     * @type {string}
     * @memberof RackGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof RackGroup
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof RackGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface RackReservation
 */
export interface RackReservation {
    /**
     * 
     * @type {number}
     * @memberof RackReservation
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RackReservation
     */
    url?: string;
    /**
     * 
     * @type {NestedRack}
     * @memberof RackReservation
     */
    rack: NestedRack | null;
    /**
     * 
     * @type {Array<number>}
     * @memberof RackReservation
     */
    units: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof RackReservation
     */
    created?: string;
    /**
     * 
     * @type {NestedUser}
     * @memberof RackReservation
     */
    user: NestedUser;
    /**
     * 
     * @type {NestedTenant}
     * @memberof RackReservation
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {string}
     * @memberof RackReservation
     */
    description: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof RackReservation
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof RackReservation
     */
    custom_fields?: object;
}
/**
 * 
 * @export
 * @interface RackRole
 */
export interface RackRole {
    /**
     * 
     * @type {number}
     * @memberof RackRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RackRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof RackRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RackRole
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof RackRole
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof RackRole
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof RackRole
     */
    rack_count?: number;
}
/**
 * 
 * @export
 * @interface RackUnit
 */
export interface RackUnit {
    /**
     * 
     * @type {number}
     * @memberof RackUnit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RackUnit
     */
    name?: string;
    /**
     * 
     * @type {Face1}
     * @memberof RackUnit
     */
    face?: Face1;
    /**
     * 
     * @type {NestedDevice}
     * @memberof RackUnit
     */
    device?: NestedDevice;
    /**
     * 
     * @type {boolean}
     * @memberof RackUnit
     */
    occupied?: boolean;
}
/**
 * 
 * @export
 * @interface RearPort
 */
export interface RearPort {
    /**
     * 
     * @type {number}
     * @memberof RearPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RearPort
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof RearPort
     */
    device: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof RearPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof RearPort
     */
    label?: string;
    /**
     * 
     * @type {Type1}
     * @memberof RearPort
     */
    type: Type1;
    /**
     * 
     * @type {number}
     * @memberof RearPort
     */
    positions?: number;
    /**
     * 
     * @type {string}
     * @memberof RearPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof RearPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof RearPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof RearPort
     */
    cable_peer_type?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof RearPort
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface RearPortTemplate
 */
export interface RearPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof RearPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RearPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {NestedDeviceType}
     * @memberof RearPortTemplate
     */
    device_type: NestedDeviceType;
    /**
     * 
     * @type {string}
     * @memberof RearPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof RearPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {Type1}
     * @memberof RearPortTemplate
     */
    type: Type1;
    /**
     * 
     * @type {number}
     * @memberof RearPortTemplate
     */
    positions?: number;
    /**
     * 
     * @type {string}
     * @memberof RearPortTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    slug: string;
    /**
     * 
     * @type {NestedRegion}
     * @memberof Region
     */
    parent?: NestedRegion | null;
    /**
     * 
     * @type {string}
     * @memberof Region
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    site_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Region
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Role
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface Role1
 */
export interface Role1 {
    /**
     * 
     * @type {string}
     * @memberof Role1
     */
    label: Role1LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Role1
     */
    value: Role1ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Role1LabelEnum {
    Loopback = 'Loopback',
    Secondary = 'Secondary',
    Anycast = 'Anycast',
    Vip = 'VIP',
    Vrrp = 'VRRP',
    Hsrp = 'HSRP',
    Glbp = 'GLBP',
    Carp = 'CARP'
}
/**
    * @export
    * @enum {string}
    */
export enum Role1ValueEnum {
    Loopback = 'loopback',
    Secondary = 'secondary',
    Anycast = 'anycast',
    Vip = 'vip',
    Vrrp = 'vrrp',
    Hsrp = 'hsrp',
    Glbp = 'glbp',
    Carp = 'carp'
}

/**
 * 
 * @export
 * @interface RouteTarget
 */
export interface RouteTarget {
    /**
     * 
     * @type {number}
     * @memberof RouteTarget
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof RouteTarget
     */
    url?: string;
    /**
     * Route target value (formatted in accordance with RFC 4360)
     * @type {string}
     * @memberof RouteTarget
     */
    name: string;
    /**
     * 
     * @type {NestedTenant}
     * @memberof RouteTarget
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {string}
     * @memberof RouteTarget
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof RouteTarget
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof RouteTarget
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof RouteTarget
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof RouteTarget
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface Secret
 */
export interface Secret {
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    assigned_object_type: string;
    /**
     * 
     * @type {number}
     * @memberof Secret
     */
    assigned_object_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Secret
     */
    assigned_object?: { [key: string]: string; };
    /**
     * 
     * @type {NestedSecretRole}
     * @memberof Secret
     */
    role: NestedSecretRole;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    plaintext: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    hash?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Secret
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Secret
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Secret
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface SecretRole
 */
export interface SecretRole {
    /**
     * 
     * @type {number}
     * @memberof SecretRole
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof SecretRole
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretRole
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SecretRole
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof SecretRole
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof SecretRole
     */
    secret_count?: number;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {number}
     * @memberof Service
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    url?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof Service
     */
    device?: NestedDevice;
    /**
     * 
     * @type {NestedVirtualMachine}
     * @memberof Service
     */
    virtual_machine?: NestedVirtualMachine | null;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof Service
     */
    ports: Array<number>;
    /**
     * 
     * @type {Protocol}
     * @memberof Service
     */
    protocol?: Protocol;
    /**
     * 
     * @type {Set<NestedIPAddress>}
     * @memberof Service
     */
    ipaddresses?: Set<NestedIPAddress>;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Service
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Service
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface Site
 */
export interface Site {
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    slug: string;
    /**
     * 
     * @type {Status5}
     * @memberof Site
     */
    status?: Status5;
    /**
     * 
     * @type {NestedRegion}
     * @memberof Site
     */
    region?: NestedRegion | null;
    /**
     * 
     * @type {NestedTenant}
     * @memberof Site
     */
    tenant?: NestedTenant | null;
    /**
     * Local facility ID or description
     * @type {string}
     * @memberof Site
     */
    facility?: string;
    /**
     * 32-bit autonomous system number
     * @type {number}
     * @memberof Site
     */
    asn?: number | null;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    time_zone?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    physical_address?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    shipping_address?: string;
    /**
     * GPS coordinate (latitude)
     * @type {string}
     * @memberof Site
     */
    latitude?: string | null;
    /**
     * GPS coordinate (longitude)
     * @type {string}
     * @memberof Site
     */
    longitude?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    contact_name?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    contact_phone?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    contact_email?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Site
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Site
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Site
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    circuit_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    virtualmachine_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Site
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    label: StatusLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    value: StatusValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum StatusLabelEnum {
    Planned = 'Planned',
    Provisioning = 'Provisioning',
    Active = 'Active',
    Offline = 'Offline',
    Deprovisioning = 'Deprovisioning',
    Decommissioned = 'Decommissioned'
}
/**
    * @export
    * @enum {string}
    */
export enum StatusValueEnum {
    Planned = 'planned',
    Provisioning = 'provisioning',
    Active = 'active',
    Offline = 'offline',
    Deprovisioning = 'deprovisioning',
    Decommissioned = 'decommissioned'
}

/**
 * 
 * @export
 * @interface Status1
 */
export interface Status1 {
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    label: Status1LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status1
     */
    value: Status1ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status1LabelEnum {
    Connected = 'Connected',
    Planned = 'Planned',
    Decommissioning = 'Decommissioning'
}
/**
    * @export
    * @enum {string}
    */
export enum Status1ValueEnum {
    Connected = 'connected',
    Planned = 'planned',
    Decommissioning = 'decommissioning'
}

/**
 * 
 * @export
 * @interface Status10
 */
export interface Status10 {
    /**
     * 
     * @type {string}
     * @memberof Status10
     */
    label: Status10LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status10
     */
    value: Status10ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status10LabelEnum {
    Offline = 'Offline',
    Active = 'Active',
    Planned = 'Planned',
    Staged = 'Staged',
    Failed = 'Failed',
    Decommissioning = 'Decommissioning'
}
/**
    * @export
    * @enum {string}
    */
export enum Status10ValueEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Staged = 'staged',
    Failed = 'failed',
    Decommissioning = 'decommissioning'
}

/**
 * 
 * @export
 * @interface Status2
 */
export interface Status2 {
    /**
     * 
     * @type {string}
     * @memberof Status2
     */
    label: Status2LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status2
     */
    value: Status2ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status2LabelEnum {
    Offline = 'Offline',
    Active = 'Active',
    Planned = 'Planned',
    Staged = 'Staged',
    Failed = 'Failed',
    Inventory = 'Inventory',
    Decommissioning = 'Decommissioning'
}
/**
    * @export
    * @enum {string}
    */
export enum Status2ValueEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Staged = 'staged',
    Failed = 'failed',
    Inventory = 'inventory',
    Decommissioning = 'decommissioning'
}

/**
 * 
 * @export
 * @interface Status3
 */
export interface Status3 {
    /**
     * 
     * @type {string}
     * @memberof Status3
     */
    label: Status3LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status3
     */
    value: Status3ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status3LabelEnum {
    Offline = 'Offline',
    Active = 'Active',
    Planned = 'Planned',
    Failed = 'Failed'
}
/**
    * @export
    * @enum {string}
    */
export enum Status3ValueEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface Status4
 */
export interface Status4 {
    /**
     * 
     * @type {string}
     * @memberof Status4
     */
    label: Status4LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status4
     */
    value: Status4ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status4LabelEnum {
    Reserved = 'Reserved',
    Available = 'Available',
    Planned = 'Planned',
    Active = 'Active',
    Deprecated = 'Deprecated'
}
/**
    * @export
    * @enum {string}
    */
export enum Status4ValueEnum {
    Reserved = 'reserved',
    Available = 'available',
    Planned = 'planned',
    Active = 'active',
    Deprecated = 'deprecated'
}

/**
 * 
 * @export
 * @interface Status5
 */
export interface Status5 {
    /**
     * 
     * @type {string}
     * @memberof Status5
     */
    label: Status5LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status5
     */
    value: Status5ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status5LabelEnum {
    Planned = 'Planned',
    Staging = 'Staging',
    Active = 'Active',
    Decommissioning = 'Decommissioning',
    Retired = 'Retired'
}
/**
    * @export
    * @enum {string}
    */
export enum Status5ValueEnum {
    Planned = 'planned',
    Staging = 'staging',
    Active = 'active',
    Decommissioning = 'decommissioning',
    Retired = 'retired'
}

/**
 * 
 * @export
 * @interface Status6
 */
export interface Status6 {
    /**
     * 
     * @type {string}
     * @memberof Status6
     */
    label: Status6LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status6
     */
    value: Status6ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status6LabelEnum {
    Pending = 'Pending',
    Running = 'Running',
    Completed = 'Completed',
    Errored = 'Errored',
    Failed = 'Failed'
}
/**
    * @export
    * @enum {string}
    */
export enum Status6ValueEnum {
    Pending = 'pending',
    Running = 'running',
    Completed = 'completed',
    Errored = 'errored',
    Failed = 'failed'
}

/**
 * 
 * @export
 * @interface Status7
 */
export interface Status7 {
    /**
     * 
     * @type {string}
     * @memberof Status7
     */
    label: Status7LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status7
     */
    value: Status7ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status7LabelEnum {
    Active = 'Active',
    Reserved = 'Reserved',
    Deprecated = 'Deprecated',
    Dhcp = 'DHCP',
    Slaac = 'SLAAC'
}
/**
    * @export
    * @enum {string}
    */
export enum Status7ValueEnum {
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated',
    Dhcp = 'dhcp',
    Slaac = 'slaac'
}

/**
 * 
 * @export
 * @interface Status8
 */
export interface Status8 {
    /**
     * 
     * @type {string}
     * @memberof Status8
     */
    label: Status8LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status8
     */
    value: Status8ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status8LabelEnum {
    Container = 'Container',
    Active = 'Active',
    Reserved = 'Reserved',
    Deprecated = 'Deprecated'
}
/**
    * @export
    * @enum {string}
    */
export enum Status8ValueEnum {
    Container = 'container',
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated'
}

/**
 * 
 * @export
 * @interface Status9
 */
export interface Status9 {
    /**
     * 
     * @type {string}
     * @memberof Status9
     */
    label: Status9LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Status9
     */
    value: Status9ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Status9LabelEnum {
    Active = 'Active',
    Reserved = 'Reserved',
    Deprecated = 'Deprecated'
}
/**
    * @export
    * @enum {string}
    */
export enum Status9ValueEnum {
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated'
}

/**
 * 
 * @export
 * @interface SubdeviceRole
 */
export interface SubdeviceRole {
    /**
     * 
     * @type {string}
     * @memberof SubdeviceRole
     */
    label: SubdeviceRoleLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof SubdeviceRole
     */
    value: SubdeviceRoleValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SubdeviceRoleLabelEnum {
    Parent = 'Parent',
    Child = 'Child'
}
/**
    * @export
    * @enum {string}
    */
export enum SubdeviceRoleValueEnum {
    Parent = 'parent',
    Child = 'child'
}

/**
 * 
 * @export
 * @interface Supply
 */
export interface Supply {
    /**
     * 
     * @type {string}
     * @memberof Supply
     */
    label: SupplyLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Supply
     */
    value: SupplyValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum SupplyLabelEnum {
    Ac = 'AC',
    Dc = 'DC'
}
/**
    * @export
    * @enum {string}
    */
export enum SupplyValueEnum {
    Ac = 'ac',
    Dc = 'dc'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    tagged_items?: number;
}
/**
 * 
 * @export
 * @interface Tenant
 */
export interface Tenant {
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    slug: string;
    /**
     * 
     * @type {NestedTenantGroup}
     * @memberof Tenant
     */
    group?: NestedTenantGroup;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof Tenant
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof Tenant
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof Tenant
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    circuit_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    ipaddress_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    site_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    virtualmachine_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    vlan_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    vrf_count?: number;
    /**
     * 
     * @type {number}
     * @memberof Tenant
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface TenantGroup
 */
export interface TenantGroup {
    /**
     * 
     * @type {number}
     * @memberof TenantGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof TenantGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof TenantGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TenantGroup
     */
    slug: string;
    /**
     * 
     * @type {NestedTenantGroup}
     * @memberof TenantGroup
     */
    parent?: NestedTenantGroup;
    /**
     * 
     * @type {string}
     * @memberof TenantGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof TenantGroup
     */
    tenant_count?: number;
    /**
     * 
     * @type {number}
     * @memberof TenantGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface Type
 */
export interface Type {
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    label: TypeLabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type
     */
    value: TypeValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum TypeLabelEnum {
    De9 = 'DE-9',
    Db25 = 'DB-25',
    Rj11 = 'RJ-11',
    Rj12 = 'RJ-12',
    Rj45 = 'RJ-45',
    UsbTypeA = 'USB Type A',
    UsbTypeB = 'USB Type B',
    UsbTypeC = 'USB Type C',
    UsbMiniA = 'USB Mini A',
    UsbMiniB = 'USB Mini B',
    UsbMicroA = 'USB Micro A',
    UsbMicroB = 'USB Micro B',
    Other = 'Other'
}
/**
    * @export
    * @enum {string}
    */
export enum TypeValueEnum {
    De9 = 'de-9',
    Db25 = 'db-25',
    Rj11 = 'rj-11',
    Rj12 = 'rj-12',
    Rj45 = 'rj-45',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface Type1
 */
export interface Type1 {
    /**
     * 
     * @type {string}
     * @memberof Type1
     */
    label: Type1LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type1
     */
    value: Type1ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type1LabelEnum {
    _8P8C = '8P8C',
    _8P6C = '8P6C',
    _8P4C = '8P4C',
    _8P2C = '8P2C',
    _110Punch = '110 Punch',
    Bnc = 'BNC',
    Mrj21 = 'MRJ21',
    Fc = 'FC',
    Lc = 'LC',
    LcApc = 'LC/APC',
    Lsh = 'LSH',
    LshApc = 'LSH/APC',
    Mpo = 'MPO',
    Mtrj = 'MTRJ',
    Sc = 'SC',
    ScApc = 'SC/APC',
    St = 'ST',
    Cs = 'CS',
    Sn = 'SN',
    Splice = 'Splice'
}
/**
    * @export
    * @enum {string}
    */
export enum Type1ValueEnum {
    _8p8c = '8p8c',
    _8p6c = '8p6c',
    _8p4c = '8p4c',
    _8p2c = '8p2c',
    _110Punch = '110-punch',
    Bnc = 'bnc',
    Mrj21 = 'mrj21',
    Fc = 'fc',
    Lc = 'lc',
    LcApc = 'lc-apc',
    Lsh = 'lsh',
    LshApc = 'lsh-apc',
    Mpo = 'mpo',
    Mtrj = 'mtrj',
    Sc = 'sc',
    ScApc = 'sc-apc',
    St = 'st',
    Cs = 'cs',
    Sn = 'sn',
    Splice = 'splice'
}

/**
 * 
 * @export
 * @interface Type2
 */
export interface Type2 {
    /**
     * 
     * @type {string}
     * @memberof Type2
     */
    label: Type2LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type2
     */
    value: Type2ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type2LabelEnum {
    Virtual = 'Virtual',
    LinkAggregationGroupLag = 'Link Aggregation Group (LAG)',
    _100BaseTx10100Me = '100BASE-TX (10/100ME)',
    _1000BaseT1Ge = '1000BASE-T (1GE)',
    _25GbaseT25Ge = '2.5GBASE-T (2.5GE)',
    _5GbaseT5Ge = '5GBASE-T (5GE)',
    _10GbaseT10Ge = '10GBASE-T (10GE)',
    _10GbaseCx410Ge = '10GBASE-CX4 (10GE)',
    Gbic1Ge = 'GBIC (1GE)',
    Sfp1Ge = 'SFP (1GE)',
    Sfp10Ge = 'SFP+ (10GE)',
    Xfp10Ge = 'XFP (10GE)',
    Xenpak10Ge = 'XENPAK (10GE)',
    X210Ge = 'X2 (10GE)',
    Sfp2825Ge = 'SFP28 (25GE)',
    Qsfp40Ge = 'QSFP+ (40GE)',
    Qsfp2850Ge = 'QSFP28 (50GE)',
    Cfp100Ge = 'CFP (100GE)',
    Cfp2100Ge = 'CFP2 (100GE)',
    Cfp2200Ge = 'CFP2 (200GE)',
    Cfp4100Ge = 'CFP4 (100GE)',
    CiscoCpak100Ge = 'Cisco CPAK (100GE)',
    Qsfp28100Ge = 'QSFP28 (100GE)',
    Qsfp56200Ge = 'QSFP56 (200GE)',
    QsfpDd400Ge = 'QSFP-DD (400GE)',
    Osfp400Ge = 'OSFP (400GE)',
    Ieee80211a = 'IEEE 802.11a',
    Ieee80211bG = 'IEEE 802.11b/g',
    Ieee80211n = 'IEEE 802.11n',
    Ieee80211ac = 'IEEE 802.11ac',
    Ieee80211ad = 'IEEE 802.11ad',
    Ieee80211ax = 'IEEE 802.11ax',
    Gsm = 'GSM',
    Cdma = 'CDMA',
    Lte = 'LTE',
    Oc3Stm1 = 'OC-3/STM-1',
    Oc12Stm4 = 'OC-12/STM-4',
    Oc48Stm16 = 'OC-48/STM-16',
    Oc192Stm64 = 'OC-192/STM-64',
    Oc768Stm256 = 'OC-768/STM-256',
    Oc1920Stm640 = 'OC-1920/STM-640',
    Oc3840Stm1234 = 'OC-3840/STM-1234',
    Sfp1Gfc = 'SFP (1GFC)',
    Sfp2Gfc = 'SFP (2GFC)',
    Sfp4Gfc = 'SFP (4GFC)',
    Sfp8Gfc = 'SFP+ (8GFC)',
    Sfp16Gfc = 'SFP+ (16GFC)',
    Sfp2832Gfc = 'SFP28 (32GFC)',
    Qsfp28128Gfc = 'QSFP28 (128GFC)',
    Sdr2Gbps = 'SDR (2 Gbps)',
    Ddr4Gbps = 'DDR (4 Gbps)',
    Qdr8Gbps = 'QDR (8 Gbps)',
    Fdr1010Gbps = 'FDR10 (10 Gbps)',
    Fdr135Gbps = 'FDR (13.5 Gbps)',
    Edr25Gbps = 'EDR (25 Gbps)',
    Hdr50Gbps = 'HDR (50 Gbps)',
    Ndr100Gbps = 'NDR (100 Gbps)',
    Xdr250Gbps = 'XDR (250 Gbps)',
    T11544Mbps = 'T1 (1.544 Mbps)',
    E12048Mbps = 'E1 (2.048 Mbps)',
    T345Mbps = 'T3 (45 Mbps)',
    E334Mbps = 'E3 (34 Mbps)',
    CiscoStackWise = 'Cisco StackWise',
    CiscoStackWisePlus = 'Cisco StackWise Plus',
    CiscoFlexStack = 'Cisco FlexStack',
    CiscoFlexStackPlus = 'Cisco FlexStack Plus',
    JuniperVcp = 'Juniper VCP',
    ExtremeSummitStack = 'Extreme SummitStack',
    ExtremeSummitStack128 = 'Extreme SummitStack-128',
    ExtremeSummitStack256 = 'Extreme SummitStack-256',
    ExtremeSummitStack512 = 'Extreme SummitStack-512',
    Other = 'Other'
}
/**
    * @export
    * @enum {string}
    */
export enum Type2ValueEnum {
    Virtual = 'virtual',
    Lag = 'lag',
    _100baseTx = '100base-tx',
    _1000baseT = '1000base-t',
    _25gbaseT = '2.5gbase-t',
    _5gbaseT = '5gbase-t',
    _10gbaseT = '10gbase-t',
    _10gbaseCx4 = '10gbase-cx4',
    _1000baseXGbic = '1000base-x-gbic',
    _1000baseXSfp = '1000base-x-sfp',
    _10gbaseXSfpp = '10gbase-x-sfpp',
    _10gbaseXXfp = '10gbase-x-xfp',
    _10gbaseXXenpak = '10gbase-x-xenpak',
    _10gbaseXX2 = '10gbase-x-x2',
    _25gbaseXSfp28 = '25gbase-x-sfp28',
    _40gbaseXQsfpp = '40gbase-x-qsfpp',
    _50gbaseXSfp28 = '50gbase-x-sfp28',
    _100gbaseXCfp = '100gbase-x-cfp',
    _100gbaseXCfp2 = '100gbase-x-cfp2',
    _200gbaseXCfp2 = '200gbase-x-cfp2',
    _100gbaseXCfp4 = '100gbase-x-cfp4',
    _100gbaseXCpak = '100gbase-x-cpak',
    _100gbaseXQsfp28 = '100gbase-x-qsfp28',
    _200gbaseXQsfp56 = '200gbase-x-qsfp56',
    _400gbaseXQsfpdd = '400gbase-x-qsfpdd',
    _400gbaseXOsfp = '400gbase-x-osfp',
    Ieee80211a = 'ieee802.11a',
    Ieee80211g = 'ieee802.11g',
    Ieee80211n = 'ieee802.11n',
    Ieee80211ac = 'ieee802.11ac',
    Ieee80211ad = 'ieee802.11ad',
    Ieee80211ax = 'ieee802.11ax',
    Gsm = 'gsm',
    Cdma = 'cdma',
    Lte = 'lte',
    SonetOc3 = 'sonet-oc3',
    SonetOc12 = 'sonet-oc12',
    SonetOc48 = 'sonet-oc48',
    SonetOc192 = 'sonet-oc192',
    SonetOc768 = 'sonet-oc768',
    SonetOc1920 = 'sonet-oc1920',
    SonetOc3840 = 'sonet-oc3840',
    _1gfcSfp = '1gfc-sfp',
    _2gfcSfp = '2gfc-sfp',
    _4gfcSfp = '4gfc-sfp',
    _8gfcSfpp = '8gfc-sfpp',
    _16gfcSfpp = '16gfc-sfpp',
    _32gfcSfp28 = '32gfc-sfp28',
    _128gfcSfp28 = '128gfc-sfp28',
    InfinibandSdr = 'infiniband-sdr',
    InfinibandDdr = 'infiniband-ddr',
    InfinibandQdr = 'infiniband-qdr',
    InfinibandFdr10 = 'infiniband-fdr10',
    InfinibandFdr = 'infiniband-fdr',
    InfinibandEdr = 'infiniband-edr',
    InfinibandHdr = 'infiniband-hdr',
    InfinibandNdr = 'infiniband-ndr',
    InfinibandXdr = 'infiniband-xdr',
    T1 = 't1',
    E1 = 'e1',
    T3 = 't3',
    E3 = 'e3',
    CiscoStackwise = 'cisco-stackwise',
    CiscoStackwisePlus = 'cisco-stackwise-plus',
    CiscoFlexstack = 'cisco-flexstack',
    CiscoFlexstackPlus = 'cisco-flexstack-plus',
    JuniperVcp = 'juniper-vcp',
    ExtremeSummitstack = 'extreme-summitstack',
    ExtremeSummitstack128 = 'extreme-summitstack-128',
    ExtremeSummitstack256 = 'extreme-summitstack-256',
    ExtremeSummitstack512 = 'extreme-summitstack-512',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface Type3
 */
export interface Type3 {
    /**
     * 
     * @type {string}
     * @memberof Type3
     */
    label: Type3LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type3
     */
    value: Type3ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type3LabelEnum {
    C6 = 'C6',
    C8 = 'C8',
    C14 = 'C14',
    C16 = 'C16',
    C20 = 'C20',
    Pne4H = 'P+N+E 4H',
    Pne6H = 'P+N+E 6H',
    Pne9H = 'P+N+E 9H',
    _2Pe4H = '2P+E 4H',
    _2Pe6H = '2P+E 6H',
    _2Pe9H = '2P+E 9H',
    _3Pe4H = '3P+E 4H',
    _3Pe6H = '3P+E 6H',
    _3Pe9H = '3P+E 9H',
    _3Pne4H = '3P+N+E 4H',
    _3Pne6H = '3P+N+E 6H',
    _3Pne9H = '3P+N+E 9H',
    Nema115P = 'NEMA 1-15P',
    Nema515P = 'NEMA 5-15P',
    Nema520P = 'NEMA 5-20P',
    Nema530P = 'NEMA 5-30P',
    Nema550P = 'NEMA 5-50P',
    Nema615P = 'NEMA 6-15P',
    Nema620P = 'NEMA 6-20P',
    Nema630P = 'NEMA 6-30P',
    Nema650P = 'NEMA 6-50P',
    Nema1030P = 'NEMA 10-30P',
    Nema1050P = 'NEMA 10-50P',
    Nema1420P = 'NEMA 14-20P',
    Nema1430P = 'NEMA 14-30P',
    Nema1450P = 'NEMA 14-50P',
    Nema1460P = 'NEMA 14-60P',
    Nema1515P = 'NEMA 15-15P',
    Nema1520P = 'NEMA 15-20P',
    Nema1530P = 'NEMA 15-30P',
    Nema1550P = 'NEMA 15-50P',
    Nema1560P = 'NEMA 15-60P',
    NemaL115P = 'NEMA L1-15P',
    NemaL515P = 'NEMA L5-15P',
    NemaL520P = 'NEMA L5-20P',
    NemaL530P = 'NEMA L5-30P',
    NemaL550P = 'NEMA L5-50P',
    NemaL615P = 'NEMA L6-15P',
    NemaL620P = 'NEMA L6-20P',
    NemaL630P = 'NEMA L6-30P',
    NemaL650P = 'NEMA L6-50P',
    NemaL1030P = 'NEMA L10-30P',
    NemaL1420P = 'NEMA L14-20P',
    NemaL1430P = 'NEMA L14-30P',
    NemaL1450P = 'NEMA L14-50P',
    NemaL1460P = 'NEMA L14-60P',
    NemaL1520P = 'NEMA L15-20P',
    NemaL1530P = 'NEMA L15-30P',
    NemaL1550P = 'NEMA L15-50P',
    NemaL1560P = 'NEMA L15-60P',
    NemaL2120P = 'NEMA L21-20P',
    NemaL2130P = 'NEMA L21-30P',
    Cs6361C = 'CS6361C',
    Cs6365C = 'CS6365C',
    Cs8165C = 'CS8165C',
    Cs8265C = 'CS8265C',
    Cs8365C = 'CS8365C',
    Cs8465C = 'CS8465C',
    ItaTypeECee75 = 'ITA Type E (CEE 7/5)',
    ItaTypeFCee74 = 'ITA Type F (CEE 7/4)',
    ItaTypeEFCee77 = 'ITA Type E/F (CEE 7/7)',
    ItaTypeGBs1363 = 'ITA Type G (BS 1363)',
    ItaTypeH = 'ITA Type H',
    ItaTypeI = 'ITA Type I',
    ItaTypeJ = 'ITA Type J',
    ItaTypeK = 'ITA Type K',
    ItaTypeLCei2350 = 'ITA Type L (CEI 23-50)',
    ItaTypeMBs546 = 'ITA Type M (BS 546)',
    ItaTypeN = 'ITA Type N',
    ItaTypeO = 'ITA Type O',
    UsbTypeA = 'USB Type A',
    UsbTypeB = 'USB Type B',
    UsbTypeC = 'USB Type C',
    UsbMiniA = 'USB Mini A',
    UsbMiniB = 'USB Mini B',
    UsbMicroA = 'USB Micro A',
    UsbMicroB = 'USB Micro B',
    Usb30TypeB = 'USB 3.0 Type B',
    Usb30MicroB = 'USB 3.0 Micro B'
}
/**
    * @export
    * @enum {string}
    */
export enum Type3ValueEnum {
    Iec60320C6 = 'iec-60320-c6',
    Iec60320C8 = 'iec-60320-c8',
    Iec60320C14 = 'iec-60320-c14',
    Iec60320C16 = 'iec-60320-c16',
    Iec60320C20 = 'iec-60320-c20',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115p = 'nema-1-15p',
    Nema515p = 'nema-5-15p',
    Nema520p = 'nema-5-20p',
    Nema530p = 'nema-5-30p',
    Nema550p = 'nema-5-50p',
    Nema615p = 'nema-6-15p',
    Nema620p = 'nema-6-20p',
    Nema630p = 'nema-6-30p',
    Nema650p = 'nema-6-50p',
    Nema1030p = 'nema-10-30p',
    Nema1050p = 'nema-10-50p',
    Nema1420p = 'nema-14-20p',
    Nema1430p = 'nema-14-30p',
    Nema1450p = 'nema-14-50p',
    Nema1460p = 'nema-14-60p',
    Nema1515p = 'nema-15-15p',
    Nema1520p = 'nema-15-20p',
    Nema1530p = 'nema-15-30p',
    Nema1550p = 'nema-15-50p',
    Nema1560p = 'nema-15-60p',
    NemaL115p = 'nema-l1-15p',
    NemaL515p = 'nema-l5-15p',
    NemaL520p = 'nema-l5-20p',
    NemaL530p = 'nema-l5-30p',
    NemaL550p = 'nema-l5-50p',
    NemaL615p = 'nema-l6-15p',
    NemaL620p = 'nema-l6-20p',
    NemaL630p = 'nema-l6-30p',
    NemaL650p = 'nema-l6-50p',
    NemaL1030p = 'nema-l10-30p',
    NemaL1420p = 'nema-l14-20p',
    NemaL1430p = 'nema-l14-30p',
    NemaL1450p = 'nema-l14-50p',
    NemaL1460p = 'nema-l14-60p',
    NemaL1520p = 'nema-l15-20p',
    NemaL1530p = 'nema-l15-30p',
    NemaL1550p = 'nema-l15-50p',
    NemaL1560p = 'nema-l15-60p',
    NemaL2120p = 'nema-l21-20p',
    NemaL2130p = 'nema-l21-30p',
    Cs6361c = 'cs6361c',
    Cs6365c = 'cs6365c',
    Cs8165c = 'cs8165c',
    Cs8265c = 'cs8265c',
    Cs8365c = 'cs8365c',
    Cs8465c = 'cs8465c',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaEf = 'ita-ef',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Usb3B = 'usb-3-b',
    Usb3MicroB = 'usb-3-micro-b'
}

/**
 * 
 * @export
 * @interface Type4
 */
export interface Type4 {
    /**
     * 
     * @type {string}
     * @memberof Type4
     */
    label: Type4LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type4
     */
    value: Type4ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type4LabelEnum {
    Primary = 'Primary',
    Redundant = 'Redundant'
}
/**
    * @export
    * @enum {string}
    */
export enum Type4ValueEnum {
    Primary = 'primary',
    Redundant = 'redundant'
}

/**
 * 
 * @export
 * @interface Type5
 */
export interface Type5 {
    /**
     * 
     * @type {string}
     * @memberof Type5
     */
    label: Type5LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type5
     */
    value: Type5ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type5LabelEnum {
    C5 = 'C5',
    C7 = 'C7',
    C13 = 'C13',
    C15 = 'C15',
    C19 = 'C19',
    Pne4H = 'P+N+E 4H',
    Pne6H = 'P+N+E 6H',
    Pne9H = 'P+N+E 9H',
    _2Pe4H = '2P+E 4H',
    _2Pe6H = '2P+E 6H',
    _2Pe9H = '2P+E 9H',
    _3Pe4H = '3P+E 4H',
    _3Pe6H = '3P+E 6H',
    _3Pe9H = '3P+E 9H',
    _3Pne4H = '3P+N+E 4H',
    _3Pne6H = '3P+N+E 6H',
    _3Pne9H = '3P+N+E 9H',
    Nema115R = 'NEMA 1-15R',
    Nema515R = 'NEMA 5-15R',
    Nema520R = 'NEMA 5-20R',
    Nema530R = 'NEMA 5-30R',
    Nema550R = 'NEMA 5-50R',
    Nema615R = 'NEMA 6-15R',
    Nema620R = 'NEMA 6-20R',
    Nema630R = 'NEMA 6-30R',
    Nema650R = 'NEMA 6-50R',
    Nema1030R = 'NEMA 10-30R',
    Nema1050R = 'NEMA 10-50R',
    Nema1420R = 'NEMA 14-20R',
    Nema1430R = 'NEMA 14-30R',
    Nema1450R = 'NEMA 14-50R',
    Nema1460R = 'NEMA 14-60R',
    Nema1515R = 'NEMA 15-15R',
    Nema1520R = 'NEMA 15-20R',
    Nema1530R = 'NEMA 15-30R',
    Nema1550R = 'NEMA 15-50R',
    Nema1560R = 'NEMA 15-60R',
    NemaL115R = 'NEMA L1-15R',
    NemaL515R = 'NEMA L5-15R',
    NemaL520R = 'NEMA L5-20R',
    NemaL530R = 'NEMA L5-30R',
    NemaL550R = 'NEMA L5-50R',
    NemaL615R = 'NEMA L6-15R',
    NemaL620R = 'NEMA L6-20R',
    NemaL630R = 'NEMA L6-30R',
    NemaL650R = 'NEMA L6-50R',
    NemaL1030R = 'NEMA L10-30R',
    NemaL1420R = 'NEMA L14-20R',
    NemaL1430R = 'NEMA L14-30R',
    NemaL1450R = 'NEMA L14-50R',
    NemaL1460R = 'NEMA L14-60R',
    NemaL1520R = 'NEMA L15-20R',
    NemaL1530R = 'NEMA L15-30R',
    NemaL1550R = 'NEMA L15-50R',
    NemaL1560R = 'NEMA L15-60R',
    NemaL2120R = 'NEMA L21-20R',
    NemaL2130R = 'NEMA L21-30R',
    Cs6360C = 'CS6360C',
    Cs6364C = 'CS6364C',
    Cs8164C = 'CS8164C',
    Cs8264C = 'CS8264C',
    Cs8364C = 'CS8364C',
    Cs8464C = 'CS8464C',
    ItaTypeECee75 = 'ITA Type E (CEE7/5)',
    ItaTypeFCee73 = 'ITA Type F (CEE7/3)',
    ItaTypeGBs1363 = 'ITA Type G (BS 1363)',
    ItaTypeH = 'ITA Type H',
    ItaTypeI = 'ITA Type I',
    ItaTypeJ = 'ITA Type J',
    ItaTypeK = 'ITA Type K',
    ItaTypeLCei2350 = 'ITA Type L (CEI 23-50)',
    ItaTypeMBs546 = 'ITA Type M (BS 546)',
    ItaTypeN = 'ITA Type N',
    ItaTypeO = 'ITA Type O',
    UsbTypeA = 'USB Type A',
    UsbMicroB = 'USB Micro B',
    UsbTypeC = 'USB Type C',
    HdotCx = 'HDOT Cx'
}
/**
    * @export
    * @enum {string}
    */
export enum Type5ValueEnum {
    Iec60320C5 = 'iec-60320-c5',
    Iec60320C7 = 'iec-60320-c7',
    Iec60320C13 = 'iec-60320-c13',
    Iec60320C15 = 'iec-60320-c15',
    Iec60320C19 = 'iec-60320-c19',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115r = 'nema-1-15r',
    Nema515r = 'nema-5-15r',
    Nema520r = 'nema-5-20r',
    Nema530r = 'nema-5-30r',
    Nema550r = 'nema-5-50r',
    Nema615r = 'nema-6-15r',
    Nema620r = 'nema-6-20r',
    Nema630r = 'nema-6-30r',
    Nema650r = 'nema-6-50r',
    Nema1030r = 'nema-10-30r',
    Nema1050r = 'nema-10-50r',
    Nema1420r = 'nema-14-20r',
    Nema1430r = 'nema-14-30r',
    Nema1450r = 'nema-14-50r',
    Nema1460r = 'nema-14-60r',
    Nema1515r = 'nema-15-15r',
    Nema1520r = 'nema-15-20r',
    Nema1530r = 'nema-15-30r',
    Nema1550r = 'nema-15-50r',
    Nema1560r = 'nema-15-60r',
    NemaL115r = 'nema-l1-15r',
    NemaL515r = 'nema-l5-15r',
    NemaL520r = 'nema-l5-20r',
    NemaL530r = 'nema-l5-30r',
    NemaL550r = 'nema-l5-50r',
    NemaL615r = 'nema-l6-15r',
    NemaL620r = 'nema-l6-20r',
    NemaL630r = 'nema-l6-30r',
    NemaL650r = 'nema-l6-50r',
    NemaL1030r = 'nema-l10-30r',
    NemaL1420r = 'nema-l14-20r',
    NemaL1430r = 'nema-l14-30r',
    NemaL1450r = 'nema-l14-50r',
    NemaL1460r = 'nema-l14-60r',
    NemaL1520r = 'nema-l15-20r',
    NemaL1530r = 'nema-l15-30r',
    NemaL1550r = 'nema-l15-50r',
    NemaL1560r = 'nema-l15-60r',
    NemaL2120r = 'nema-l21-20r',
    NemaL2130r = 'nema-l21-30r',
    Cs6360C = 'CS6360C',
    Cs6364C = 'CS6364C',
    Cs8164C = 'CS8164C',
    Cs8264C = 'CS8264C',
    Cs8364C = 'CS8364C',
    Cs8464C = 'CS8464C',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbMicroB = 'usb-micro-b',
    UsbC = 'usb-c',
    HdotCx = 'hdot-cx'
}

/**
 * 
 * @export
 * @interface Type6
 */
export interface Type6 {
    /**
     * 
     * @type {string}
     * @memberof Type6
     */
    label: Type6LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type6
     */
    value: Type6ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type6LabelEnum {
    _2PostFrame = '2-post frame',
    _4PostFrame = '4-post frame',
    _4PostCabinet = '4-post cabinet',
    WallMountedFrame = 'Wall-mounted frame',
    WallMountedCabinet = 'Wall-mounted cabinet'
}
/**
    * @export
    * @enum {string}
    */
export enum Type6ValueEnum {
    _2PostFrame = '2-post-frame',
    _4PostFrame = '4-post-frame',
    _4PostCabinet = '4-post-cabinet',
    WallFrame = 'wall-frame',
    WallCabinet = 'wall-cabinet'
}

/**
 * 
 * @export
 * @interface Type7
 */
export interface Type7 {
    /**
     * 
     * @type {string}
     * @memberof Type7
     */
    label: Type7LabelEnum;
    /**
     * 
     * @type {string}
     * @memberof Type7
     */
    value: Type7ValueEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum Type7LabelEnum {
    Text = 'Text',
    Integer = 'Integer',
    BooleanTrueFalse = 'Boolean (true/false)',
    Date = 'Date',
    Url = 'URL',
    Selection = 'Selection'
}
/**
    * @export
    * @enum {string}
    */
export enum Type7ValueEnum {
    Text = 'text',
    Integer = 'integer',
    Boolean = 'boolean',
    Date = 'date',
    Url = 'url',
    Select = 'select'
}

/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    url?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof User
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof User
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof User
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    date_joined?: string;
    /**
     * 
     * @type {Set<NestedGroup>}
     * @memberof User
     */
    groups?: Set<NestedGroup>;
}
/**
 * 
 * @export
 * @interface VLAN
 */
export interface VLAN {
    /**
     * 
     * @type {number}
     * @memberof VLAN
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    url?: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof VLAN
     */
    site?: NestedSite;
    /**
     * 
     * @type {NestedVLANGroup}
     * @memberof VLAN
     */
    group?: NestedVLANGroup | null;
    /**
     * 
     * @type {number}
     * @memberof VLAN
     */
    vid: number;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    name: string;
    /**
     * 
     * @type {NestedTenant}
     * @memberof VLAN
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {Status9}
     * @memberof VLAN
     */
    status?: Status9;
    /**
     * 
     * @type {NestedRole}
     * @memberof VLAN
     */
    role?: NestedRole | null;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof VLAN
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    display_name?: string;
    /**
     * 
     * @type {object}
     * @memberof VLAN
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VLAN
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof VLAN
     */
    prefix_count?: number;
}
/**
 * 
 * @export
 * @interface VLANGroup
 */
export interface VLANGroup {
    /**
     * 
     * @type {number}
     * @memberof VLANGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VLANGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VLANGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VLANGroup
     */
    slug: string;
    /**
     * 
     * @type {NestedSite}
     * @memberof VLANGroup
     */
    site?: NestedSite;
    /**
     * 
     * @type {string}
     * @memberof VLANGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof VLANGroup
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface VMInterface
 */
export interface VMInterface {
    /**
     * 
     * @type {number}
     * @memberof VMInterface
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VMInterface
     */
    url?: string;
    /**
     * 
     * @type {NestedVirtualMachine}
     * @memberof VMInterface
     */
    virtual_machine: NestedVirtualMachine | null;
    /**
     * 
     * @type {string}
     * @memberof VMInterface
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof VMInterface
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof VMInterface
     */
    mtu?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VMInterface
     */
    mac_address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof VMInterface
     */
    description?: string;
    /**
     * 
     * @type {Mode}
     * @memberof VMInterface
     */
    mode?: Mode;
    /**
     * 
     * @type {NestedVLAN}
     * @memberof VMInterface
     */
    untagged_vlan?: NestedVLAN | null;
    /**
     * 
     * @type {Set<NestedVLAN>}
     * @memberof VMInterface
     */
    tagged_vlans?: Set<NestedVLAN>;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof VMInterface
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface VRF
 */
export interface VRF {
    /**
     * 
     * @type {number}
     * @memberof VRF
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    name: string;
    /**
     * Unique route distinguisher (as defined in RFC 4364)
     * @type {string}
     * @memberof VRF
     */
    rd?: string | null;
    /**
     * 
     * @type {NestedTenant}
     * @memberof VRF
     */
    tenant?: NestedTenant | null;
    /**
     * Prevent duplicate prefixes/IP addresses within this VRF
     * @type {boolean}
     * @memberof VRF
     */
    enforce_unique?: boolean;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedRouteTarget>}
     * @memberof VRF
     */
    import_targets?: Array<NestedRouteTarget> | null;
    /**
     * 
     * @type {Array<NestedRouteTarget>}
     * @memberof VRF
     */
    export_targets?: Array<NestedRouteTarget> | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof VRF
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    display_name?: string;
    /**
     * 
     * @type {object}
     * @memberof VRF
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VRF
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof VRF
     */
    ipaddress_count?: number;
    /**
     * 
     * @type {number}
     * @memberof VRF
     */
    prefix_count?: number;
}
/**
 * 
 * @export
 * @interface VirtualChassis
 */
export interface VirtualChassis {
    /**
     * 
     * @type {number}
     * @memberof VirtualChassis
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VirtualChassis
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualChassis
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualChassis
     */
    domain?: string;
    /**
     * 
     * @type {NestedDevice}
     * @memberof VirtualChassis
     */
    master?: NestedDevice;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof VirtualChassis
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof VirtualChassis
     */
    custom_fields?: object;
    /**
     * 
     * @type {number}
     * @memberof VirtualChassis
     */
    member_count?: number;
}
/**
 * 
 * @export
 * @interface VirtualMachineWithConfigContext
 */
export interface VirtualMachineWithConfigContext {
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineWithConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    name: string;
    /**
     * 
     * @type {Status10}
     * @memberof VirtualMachineWithConfigContext
     */
    status?: Status10;
    /**
     * 
     * @type {NestedSite}
     * @memberof VirtualMachineWithConfigContext
     */
    site?: NestedSite;
    /**
     * 
     * @type {NestedCluster}
     * @memberof VirtualMachineWithConfigContext
     */
    cluster: NestedCluster | null;
    /**
     * 
     * @type {NestedDeviceRole}
     * @memberof VirtualMachineWithConfigContext
     */
    role?: NestedDeviceRole;
    /**
     * 
     * @type {NestedTenant}
     * @memberof VirtualMachineWithConfigContext
     */
    tenant?: NestedTenant | null;
    /**
     * 
     * @type {NestedPlatform}
     * @memberof VirtualMachineWithConfigContext
     */
    platform?: NestedPlatform | null;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof VirtualMachineWithConfigContext
     */
    primary_ip?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof VirtualMachineWithConfigContext
     */
    primary_ip4?: NestedIPAddress;
    /**
     * 
     * @type {NestedIPAddress}
     * @memberof VirtualMachineWithConfigContext
     */
    primary_ip6?: NestedIPAddress;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineWithConfigContext
     */
    vcpus?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineWithConfigContext
     */
    memory?: number | null;
    /**
     * 
     * @type {number}
     * @memberof VirtualMachineWithConfigContext
     */
    disk?: number | null;
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    local_context_data?: string | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof VirtualMachineWithConfigContext
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof VirtualMachineWithConfigContext
     */
    custom_fields?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof VirtualMachineWithConfigContext
     */
    config_context?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof VirtualMachineWithConfigContext
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface Width
 */
export interface Width {
    /**
     * 
     * @type {string}
     * @memberof Width
     */
    label: WidthLabelEnum;
    /**
     * 
     * @type {number}
     * @memberof Width
     */
    value: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WidthLabelEnum {
    _10Inches = '10 inches',
    _19Inches = '19 inches',
    _21Inches = '21 inches',
    _23Inches = '23 inches'
}

/**
 * 
 * @export
 * @interface WritableAggregate
 */
export interface WritableAggregate {
    /**
     * 
     * @type {number}
     * @memberof WritableAggregate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    family?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    prefix: string;
    /**
     * 
     * @type {number}
     * @memberof WritableAggregate
     */
    rir: number;
    /**
     * 
     * @type {number}
     * @memberof WritableAggregate
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    date_added?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableAggregate
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableAggregate
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableAggregate
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface WritableAvailableIP
 */
export interface WritableAvailableIP {
    /**
     * 
     * @type {number}
     * @memberof WritableAvailableIP
     */
    family?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableAvailableIP
     */
    address?: string;
}
/**
 * 
 * @export
 * @interface WritableCable
 */
export interface WritableCable {
    /**
     * 
     * @type {number}
     * @memberof WritableCable
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    termination_a_type: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCable
     */
    termination_a_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableCable
     */
    termination_a?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    termination_b_type: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCable
     */
    termination_b_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableCable
     */
    termination_b?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    type?: WritableCableTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    status?: WritableCableStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    color?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCable
     */
    length?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableCable
     */
    length_unit?: WritableCableLengthUnitEnum;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableCable
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableCable
     */
    custom_fields?: object;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableCableTypeEnum {
    Cat3 = 'cat3',
    Cat5 = 'cat5',
    Cat5e = 'cat5e',
    Cat6 = 'cat6',
    Cat6a = 'cat6a',
    Cat7 = 'cat7',
    DacActive = 'dac-active',
    DacPassive = 'dac-passive',
    Mrj21Trunk = 'mrj21-trunk',
    Coaxial = 'coaxial',
    Mmf = 'mmf',
    MmfOm1 = 'mmf-om1',
    MmfOm2 = 'mmf-om2',
    MmfOm3 = 'mmf-om3',
    MmfOm4 = 'mmf-om4',
    Smf = 'smf',
    SmfOs1 = 'smf-os1',
    SmfOs2 = 'smf-os2',
    Aoc = 'aoc',
    Power = 'power'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableCableStatusEnum {
    Connected = 'connected',
    Planned = 'planned',
    Decommissioning = 'decommissioning'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableCableLengthUnitEnum {
    M = 'm',
    Cm = 'cm',
    Ft = 'ft',
    In = 'in'
}

/**
 * 
 * @export
 * @interface WritableCircuit
 */
export interface WritableCircuit {
    /**
     * 
     * @type {number}
     * @memberof WritableCircuit
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    cid: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuit
     */
    provider: number;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuit
     */
    type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    status?: WritableCircuitStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuit
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    install_date?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuit
     */
    commit_rate?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    termination_a?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    termination_z?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableCircuit
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableCircuit
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuit
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableCircuitStatusEnum {
    Planned = 'planned',
    Provisioning = 'provisioning',
    Active = 'active',
    Offline = 'offline',
    Deprovisioning = 'deprovisioning',
    Decommissioned = 'decommissioned'
}

/**
 * 
 * @export
 * @interface WritableCircuitTermination
 */
export interface WritableCircuitTermination {
    /**
     * 
     * @type {number}
     * @memberof WritableCircuitTermination
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuitTermination
     */
    circuit: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    term_side: WritableCircuitTerminationTermSideEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuitTermination
     */
    site: number;
    /**
     * 
     * @type {number}
     * @memberof WritableCircuitTermination
     */
    port_speed?: number | null;
    /**
     * Upstream speed, if different from port speed
     * @type {number}
     * @memberof WritableCircuitTermination
     */
    upstream_speed?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    xconnect_id?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    pp_info?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableCircuitTermination
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableCircuitTermination
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableCircuitTermination
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableCircuitTermination
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableCircuitTermination
     */
    connected_endpoint_reachable?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableCircuitTerminationTermSideEnum {
    A = 'A',
    Z = 'Z'
}

/**
 * 
 * @export
 * @interface WritableCluster
 */
export interface WritableCluster {
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCluster
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCluster
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    type: number;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    group?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    tenant?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    site?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableCluster
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableCluster
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableCluster
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableCluster
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCluster
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableCluster
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface WritableConfigContext
 */
export interface WritableConfigContext {
    /**
     * 
     * @type {number}
     * @memberof WritableConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof WritableConfigContext
     */
    weight?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableConfigContext
     */
    is_active?: boolean;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    regions?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    sites?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    roles?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    platforms?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    cluster_groups?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    clusters?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    tenant_groups?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableConfigContext
     */
    tenants?: Set<number>;
    /**
     * 
     * @type {Set<string>}
     * @memberof WritableConfigContext
     */
    tags?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    data: string;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableConfigContext
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface WritableConsolePort
 */
export interface WritableConsolePort {
    /**
     * 
     * @type {number}
     * @memberof WritableConsolePort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePort
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableConsolePort
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableConsolePort
     */
    label?: string;
    /**
     * Physical port type
     * @type {string}
     * @memberof WritableConsolePort
     */
    type?: WritableConsolePortTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableConsolePort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableConsolePort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableConsolePort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableConsolePort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableConsolePort
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableConsolePortTypeEnum {
    De9 = 'de-9',
    Db25 = 'db-25',
    Rj11 = 'rj-11',
    Rj12 = 'rj-12',
    Rj45 = 'rj-45',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface WritableConsolePortTemplate
 */
export interface WritableConsolePortTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableConsolePortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePortTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableConsolePortTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableConsolePortTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePortTemplate
     */
    type?: WritableConsolePortTemplateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableConsolePortTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableConsolePortTemplateTypeEnum {
    De9 = 'de-9',
    Db25 = 'db-25',
    Rj11 = 'rj-11',
    Rj12 = 'rj-12',
    Rj45 = 'rj-45',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface WritableConsoleServerPort
 */
export interface WritableConsoleServerPort {
    /**
     * 
     * @type {number}
     * @memberof WritableConsoleServerPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableConsoleServerPort
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    label?: string;
    /**
     * Physical port type
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    type?: WritableConsoleServerPortTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableConsoleServerPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableConsoleServerPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableConsoleServerPort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableConsoleServerPort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableConsoleServerPort
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableConsoleServerPortTypeEnum {
    De9 = 'de-9',
    Db25 = 'db-25',
    Rj11 = 'rj-11',
    Rj12 = 'rj-12',
    Rj45 = 'rj-45',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface WritableConsoleServerPortTemplate
 */
export interface WritableConsoleServerPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableConsoleServerPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableConsoleServerPortTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableConsoleServerPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPortTemplate
     */
    type?: WritableConsoleServerPortTemplateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableConsoleServerPortTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableConsoleServerPortTemplateTypeEnum {
    De9 = 'de-9',
    Db25 = 'db-25',
    Rj11 = 'rj-11',
    Rj12 = 'rj-12',
    Rj45 = 'rj-45',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface WritableCustomField
 */
export interface WritableCustomField {
    /**
     * 
     * @type {number}
     * @memberof WritableCustomField
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableCustomField
     */
    url?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof WritableCustomField
     */
    content_types: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof WritableCustomField
     */
    type?: WritableCustomFieldTypeEnum;
    /**
     * Internal field name
     * @type {string}
     * @memberof WritableCustomField
     */
    name: string;
    /**
     * Name of the field as displayed to users (if not provided, the field\'s name will be used)
     * @type {string}
     * @memberof WritableCustomField
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableCustomField
     */
    description?: string;
    /**
     * If true, this field is required when creating new objects or editing an existing object.
     * @type {boolean}
     * @memberof WritableCustomField
     */
    required?: boolean;
    /**
     * Loose matches any instance of a given string; exact matches the entire field.
     * @type {string}
     * @memberof WritableCustomField
     */
    filter_logic?: WritableCustomFieldFilterLogicEnum;
    /**
     * Default value for the field (must be a JSON value). Encapsulate strings with double quotes (e.g. \"Foo\").
     * @type {string}
     * @memberof WritableCustomField
     */
    _default?: string | null;
    /**
     * Fields with higher weights appear lower in a form.
     * @type {number}
     * @memberof WritableCustomField
     */
    weight?: number;
    /**
     * Minimum allowed value (for numeric fields)
     * @type {number}
     * @memberof WritableCustomField
     */
    validation_minimum?: number | null;
    /**
     * Maximum allowed value (for numeric fields)
     * @type {number}
     * @memberof WritableCustomField
     */
    validation_maximum?: number | null;
    /**
     * Regular expression to enforce on text field values. Use ^ and $ to force matching of entire string. For example, <code>^[A-Z]{3}$</code> will limit values to exactly three uppercase letters.
     * @type {string}
     * @memberof WritableCustomField
     */
    validation_regex?: string;
    /**
     * Comma-separated list of available choices (for selection fields)
     * @type {Array<string>}
     * @memberof WritableCustomField
     */
    choices?: Array<string> | null;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableCustomFieldTypeEnum {
    Text = 'text',
    Integer = 'integer',
    Boolean = 'boolean',
    Date = 'date',
    Url = 'url',
    Select = 'select'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableCustomFieldFilterLogicEnum {
    Disabled = 'disabled',
    Loose = 'loose',
    Exact = 'exact'
}

/**
 * 
 * @export
 * @interface WritableDeviceBay
 */
export interface WritableDeviceBay {
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceBay
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBay
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceBay
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBay
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableDeviceBay
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBay
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceBay
     */
    installed_device?: number | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableDeviceBay
     */
    tags?: Array<NestedTag>;
}
/**
 * 
 * @export
 * @interface WritableDeviceBayTemplate
 */
export interface WritableDeviceBayTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceBayTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBayTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceBayTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBayTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableDeviceBayTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceBayTemplate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface WritableDeviceType
 */
export interface WritableDeviceType {
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceType
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceType
     */
    manufacturer: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    model: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    display_name?: string;
    /**
     * Discrete part number (optional)
     * @type {string}
     * @memberof WritableDeviceType
     */
    part_number?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceType
     */
    u_height?: number;
    /**
     * Device consumes both front and rear rack faces
     * @type {boolean}
     * @memberof WritableDeviceType
     */
    is_full_depth?: boolean;
    /**
     * Parent devices house child devices in device bays. Leave blank if this device type is neither a parent nor a child.
     * @type {string}
     * @memberof WritableDeviceType
     */
    subdevice_role?: WritableDeviceTypeSubdeviceRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    front_image?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    rear_image?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableDeviceType
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableDeviceType
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceType
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceType
     */
    device_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableDeviceTypeSubdeviceRoleEnum {
    Parent = 'parent',
    Child = 'child'
}

/**
 * 
 * @export
 * @interface WritableDeviceWithConfigContext
 */
export interface WritableDeviceWithConfigContext {
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    name?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    device_type: number;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    device_role: number;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    tenant?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    platform?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    serial?: string;
    /**
     * A unique tag used to identify this device
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    asset_tag?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    site: number;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    rack?: number | null;
    /**
     * The lowest-numbered unit occupied by the device
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    position?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    face?: WritableDeviceWithConfigContextFaceEnum;
    /**
     * 
     * @type {NestedDevice}
     * @memberof WritableDeviceWithConfigContext
     */
    parent_device?: NestedDevice;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    status?: WritableDeviceWithConfigContextStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    primary_ip?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    primary_ip4?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    primary_ip6?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    cluster?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    virtual_chassis?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    vc_position?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableDeviceWithConfigContext
     */
    vc_priority?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    local_context_data?: string | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableDeviceWithConfigContext
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableDeviceWithConfigContext
     */
    custom_fields?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableDeviceWithConfigContext
     */
    config_context?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableDeviceWithConfigContext
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableDeviceWithConfigContextFaceEnum {
    Front = 'front',
    Rear = 'rear'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableDeviceWithConfigContextStatusEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Staged = 'staged',
    Failed = 'failed',
    Inventory = 'inventory',
    Decommissioning = 'decommissioning'
}

/**
 * 
 * @export
 * @interface WritableFrontPort
 */
export interface WritableFrontPort {
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPort
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPort
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableFrontPort
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPort
     */
    type: WritableFrontPortTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPort
     */
    rear_port: number;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPort
     */
    rear_port_position?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableFrontPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableFrontPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPort
     */
    cable_peer_type?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableFrontPort
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableFrontPortTypeEnum {
    _8p8c = '8p8c',
    _8p6c = '8p6c',
    _8p4c = '8p4c',
    _8p2c = '8p2c',
    _110Punch = '110-punch',
    Bnc = 'bnc',
    Mrj21 = 'mrj21',
    Fc = 'fc',
    Lc = 'lc',
    LcApc = 'lc-apc',
    Lsh = 'lsh',
    LshApc = 'lsh-apc',
    Mpo = 'mpo',
    Mtrj = 'mtrj',
    Sc = 'sc',
    ScApc = 'sc-apc',
    St = 'st',
    Cs = 'cs',
    Sn = 'sn',
    Splice = 'splice'
}

/**
 * 
 * @export
 * @interface WritableFrontPortTemplate
 */
export interface WritableFrontPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPortTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableFrontPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPortTemplate
     */
    type: WritableFrontPortTemplateTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPortTemplate
     */
    rear_port: number;
    /**
     * 
     * @type {number}
     * @memberof WritableFrontPortTemplate
     */
    rear_port_position?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableFrontPortTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableFrontPortTemplateTypeEnum {
    _8p8c = '8p8c',
    _8p6c = '8p6c',
    _8p4c = '8p4c',
    _8p2c = '8p2c',
    _110Punch = '110-punch',
    Bnc = 'bnc',
    Mrj21 = 'mrj21',
    Fc = 'fc',
    Lc = 'lc',
    LcApc = 'lc-apc',
    Lsh = 'lsh',
    LshApc = 'lsh-apc',
    Mpo = 'mpo',
    Mtrj = 'mtrj',
    Sc = 'sc',
    ScApc = 'sc-apc',
    St = 'st',
    Cs = 'cs',
    Sn = 'sn',
    Splice = 'splice'
}

/**
 * 
 * @export
 * @interface WritableIPAddress
 */
export interface WritableIPAddress {
    /**
     * 
     * @type {number}
     * @memberof WritableIPAddress
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    family?: string;
    /**
     * IPv4 or IPv6 address (with mask)
     * @type {string}
     * @memberof WritableIPAddress
     */
    address: string;
    /**
     * 
     * @type {number}
     * @memberof WritableIPAddress
     */
    vrf?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableIPAddress
     */
    tenant?: number | null;
    /**
     * The operational status of this IP
     * @type {string}
     * @memberof WritableIPAddress
     */
    status?: WritableIPAddressStatusEnum;
    /**
     * The functional role of this IP
     * @type {string}
     * @memberof WritableIPAddress
     */
    role?: WritableIPAddressRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    assigned_object_type?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WritableIPAddress
     */
    assigned_object_id?: number | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableIPAddress
     */
    assigned_object?: { [key: string]: string; };
    /**
     * The IP for which this address is the \"outside\" IP
     * @type {number}
     * @memberof WritableIPAddress
     */
    nat_inside?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableIPAddress
     */
    nat_outside: number;
    /**
     * Hostname or FQDN (not case-sensitive)
     * @type {string}
     * @memberof WritableIPAddress
     */
    dns_name?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableIPAddress
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableIPAddress
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableIPAddress
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableIPAddressStatusEnum {
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated',
    Dhcp = 'dhcp',
    Slaac = 'slaac'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableIPAddressRoleEnum {
    Loopback = 'loopback',
    Secondary = 'secondary',
    Anycast = 'anycast',
    Vip = 'vip',
    Vrrp = 'vrrp',
    Hsrp = 'hsrp',
    Glbp = 'glbp',
    Carp = 'carp'
}

/**
 * 
 * @export
 * @interface WritableInterface
 */
export interface WritableInterface {
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableInterface
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    type: WritableInterfaceTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof WritableInterface
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    lag?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    mtu?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    mac_address?: string | null;
    /**
     * This interface is used only for out-of-band management
     * @type {boolean}
     * @memberof WritableInterface
     */
    mgmt_only?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    mode?: WritableInterfaceModeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    untagged_vlan?: number | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableInterface
     */
    tagged_vlans?: Set<number>;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableInterface
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableInterface
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableInterface
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableInterface
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableInterface
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableInterface
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {number}
     * @memberof WritableInterface
     */
    count_ipaddresses?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableInterfaceTypeEnum {
    Virtual = 'virtual',
    Lag = 'lag',
    _100baseTx = '100base-tx',
    _1000baseT = '1000base-t',
    _25gbaseT = '2.5gbase-t',
    _5gbaseT = '5gbase-t',
    _10gbaseT = '10gbase-t',
    _10gbaseCx4 = '10gbase-cx4',
    _1000baseXGbic = '1000base-x-gbic',
    _1000baseXSfp = '1000base-x-sfp',
    _10gbaseXSfpp = '10gbase-x-sfpp',
    _10gbaseXXfp = '10gbase-x-xfp',
    _10gbaseXXenpak = '10gbase-x-xenpak',
    _10gbaseXX2 = '10gbase-x-x2',
    _25gbaseXSfp28 = '25gbase-x-sfp28',
    _40gbaseXQsfpp = '40gbase-x-qsfpp',
    _50gbaseXSfp28 = '50gbase-x-sfp28',
    _100gbaseXCfp = '100gbase-x-cfp',
    _100gbaseXCfp2 = '100gbase-x-cfp2',
    _200gbaseXCfp2 = '200gbase-x-cfp2',
    _100gbaseXCfp4 = '100gbase-x-cfp4',
    _100gbaseXCpak = '100gbase-x-cpak',
    _100gbaseXQsfp28 = '100gbase-x-qsfp28',
    _200gbaseXQsfp56 = '200gbase-x-qsfp56',
    _400gbaseXQsfpdd = '400gbase-x-qsfpdd',
    _400gbaseXOsfp = '400gbase-x-osfp',
    Ieee80211a = 'ieee802.11a',
    Ieee80211g = 'ieee802.11g',
    Ieee80211n = 'ieee802.11n',
    Ieee80211ac = 'ieee802.11ac',
    Ieee80211ad = 'ieee802.11ad',
    Ieee80211ax = 'ieee802.11ax',
    Gsm = 'gsm',
    Cdma = 'cdma',
    Lte = 'lte',
    SonetOc3 = 'sonet-oc3',
    SonetOc12 = 'sonet-oc12',
    SonetOc48 = 'sonet-oc48',
    SonetOc192 = 'sonet-oc192',
    SonetOc768 = 'sonet-oc768',
    SonetOc1920 = 'sonet-oc1920',
    SonetOc3840 = 'sonet-oc3840',
    _1gfcSfp = '1gfc-sfp',
    _2gfcSfp = '2gfc-sfp',
    _4gfcSfp = '4gfc-sfp',
    _8gfcSfpp = '8gfc-sfpp',
    _16gfcSfpp = '16gfc-sfpp',
    _32gfcSfp28 = '32gfc-sfp28',
    _128gfcSfp28 = '128gfc-sfp28',
    InfinibandSdr = 'infiniband-sdr',
    InfinibandDdr = 'infiniband-ddr',
    InfinibandQdr = 'infiniband-qdr',
    InfinibandFdr10 = 'infiniband-fdr10',
    InfinibandFdr = 'infiniband-fdr',
    InfinibandEdr = 'infiniband-edr',
    InfinibandHdr = 'infiniband-hdr',
    InfinibandNdr = 'infiniband-ndr',
    InfinibandXdr = 'infiniband-xdr',
    T1 = 't1',
    E1 = 'e1',
    T3 = 't3',
    E3 = 'e3',
    CiscoStackwise = 'cisco-stackwise',
    CiscoStackwisePlus = 'cisco-stackwise-plus',
    CiscoFlexstack = 'cisco-flexstack',
    CiscoFlexstackPlus = 'cisco-flexstack-plus',
    JuniperVcp = 'juniper-vcp',
    ExtremeSummitstack = 'extreme-summitstack',
    ExtremeSummitstack128 = 'extreme-summitstack-128',
    ExtremeSummitstack256 = 'extreme-summitstack-256',
    ExtremeSummitstack512 = 'extreme-summitstack-512',
    Other = 'other'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableInterfaceModeEnum {
    Access = 'access',
    Tagged = 'tagged',
    TaggedAll = 'tagged-all'
}

/**
 * 
 * @export
 * @interface WritableInterfaceTemplate
 */
export interface WritableInterfaceTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableInterfaceTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableInterfaceTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableInterfaceTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableInterfaceTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableInterfaceTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableInterfaceTemplate
     */
    type: WritableInterfaceTemplateTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof WritableInterfaceTemplate
     */
    mgmt_only?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritableInterfaceTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableInterfaceTemplateTypeEnum {
    Virtual = 'virtual',
    Lag = 'lag',
    _100baseTx = '100base-tx',
    _1000baseT = '1000base-t',
    _25gbaseT = '2.5gbase-t',
    _5gbaseT = '5gbase-t',
    _10gbaseT = '10gbase-t',
    _10gbaseCx4 = '10gbase-cx4',
    _1000baseXGbic = '1000base-x-gbic',
    _1000baseXSfp = '1000base-x-sfp',
    _10gbaseXSfpp = '10gbase-x-sfpp',
    _10gbaseXXfp = '10gbase-x-xfp',
    _10gbaseXXenpak = '10gbase-x-xenpak',
    _10gbaseXX2 = '10gbase-x-x2',
    _25gbaseXSfp28 = '25gbase-x-sfp28',
    _40gbaseXQsfpp = '40gbase-x-qsfpp',
    _50gbaseXSfp28 = '50gbase-x-sfp28',
    _100gbaseXCfp = '100gbase-x-cfp',
    _100gbaseXCfp2 = '100gbase-x-cfp2',
    _200gbaseXCfp2 = '200gbase-x-cfp2',
    _100gbaseXCfp4 = '100gbase-x-cfp4',
    _100gbaseXCpak = '100gbase-x-cpak',
    _100gbaseXQsfp28 = '100gbase-x-qsfp28',
    _200gbaseXQsfp56 = '200gbase-x-qsfp56',
    _400gbaseXQsfpdd = '400gbase-x-qsfpdd',
    _400gbaseXOsfp = '400gbase-x-osfp',
    Ieee80211a = 'ieee802.11a',
    Ieee80211g = 'ieee802.11g',
    Ieee80211n = 'ieee802.11n',
    Ieee80211ac = 'ieee802.11ac',
    Ieee80211ad = 'ieee802.11ad',
    Ieee80211ax = 'ieee802.11ax',
    Gsm = 'gsm',
    Cdma = 'cdma',
    Lte = 'lte',
    SonetOc3 = 'sonet-oc3',
    SonetOc12 = 'sonet-oc12',
    SonetOc48 = 'sonet-oc48',
    SonetOc192 = 'sonet-oc192',
    SonetOc768 = 'sonet-oc768',
    SonetOc1920 = 'sonet-oc1920',
    SonetOc3840 = 'sonet-oc3840',
    _1gfcSfp = '1gfc-sfp',
    _2gfcSfp = '2gfc-sfp',
    _4gfcSfp = '4gfc-sfp',
    _8gfcSfpp = '8gfc-sfpp',
    _16gfcSfpp = '16gfc-sfpp',
    _32gfcSfp28 = '32gfc-sfp28',
    _128gfcSfp28 = '128gfc-sfp28',
    InfinibandSdr = 'infiniband-sdr',
    InfinibandDdr = 'infiniband-ddr',
    InfinibandQdr = 'infiniband-qdr',
    InfinibandFdr10 = 'infiniband-fdr10',
    InfinibandFdr = 'infiniband-fdr',
    InfinibandEdr = 'infiniband-edr',
    InfinibandHdr = 'infiniband-hdr',
    InfinibandNdr = 'infiniband-ndr',
    InfinibandXdr = 'infiniband-xdr',
    T1 = 't1',
    E1 = 'e1',
    T3 = 't3',
    E3 = 'e3',
    CiscoStackwise = 'cisco-stackwise',
    CiscoStackwisePlus = 'cisco-stackwise-plus',
    CiscoFlexstack = 'cisco-flexstack',
    CiscoFlexstackPlus = 'cisco-flexstack-plus',
    JuniperVcp = 'juniper-vcp',
    ExtremeSummitstack = 'extreme-summitstack',
    ExtremeSummitstack128 = 'extreme-summitstack-128',
    ExtremeSummitstack256 = 'extreme-summitstack-256',
    ExtremeSummitstack512 = 'extreme-summitstack-512',
    Other = 'other'
}

/**
 * 
 * @export
 * @interface WritableInventoryItem
 */
export interface WritableInventoryItem {
    /**
     * 
     * @type {number}
     * @memberof WritableInventoryItem
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableInventoryItem
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableInventoryItem
     */
    device: number;
    /**
     * 
     * @type {number}
     * @memberof WritableInventoryItem
     */
    parent?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableInventoryItem
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableInventoryItem
     */
    label?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableInventoryItem
     */
    manufacturer?: number | null;
    /**
     * Manufacturer-assigned part identifier
     * @type {string}
     * @memberof WritableInventoryItem
     */
    part_id?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableInventoryItem
     */
    serial?: string;
    /**
     * A unique tag used to identify this item
     * @type {string}
     * @memberof WritableInventoryItem
     */
    asset_tag?: string | null;
    /**
     * This item was automatically discovered
     * @type {boolean}
     * @memberof WritableInventoryItem
     */
    discovered?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritableInventoryItem
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableInventoryItem
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {number}
     * @memberof WritableInventoryItem
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface WritableObjectPermission
 */
export interface WritableObjectPermission {
    /**
     * 
     * @type {number}
     * @memberof WritableObjectPermission
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableObjectPermission
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableObjectPermission
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableObjectPermission
     */
    description?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableObjectPermission
     */
    enabled?: boolean;
    /**
     * 
     * @type {Set<string>}
     * @memberof WritableObjectPermission
     */
    object_types: Set<string>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableObjectPermission
     */
    groups?: Set<number>;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableObjectPermission
     */
    users?: Set<number>;
    /**
     * The list of actions granted by this permission
     * @type {Array<string>}
     * @memberof WritableObjectPermission
     */
    actions: Array<string>;
    /**
     * Queryset filter matching the applicable objects of the selected type(s)
     * @type {string}
     * @memberof WritableObjectPermission
     */
    constraints?: string | null;
}
/**
 * 
 * @export
 * @interface WritablePlatform
 */
export interface WritablePlatform {
    /**
     * 
     * @type {number}
     * @memberof WritablePlatform
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePlatform
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePlatform
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePlatform
     */
    slug: string;
    /**
     * Optionally limit this platform to devices of a certain manufacturer
     * @type {number}
     * @memberof WritablePlatform
     */
    manufacturer?: number | null;
    /**
     * The name of the NAPALM driver to use when interacting with devices
     * @type {string}
     * @memberof WritablePlatform
     */
    napalm_driver?: string;
    /**
     * Additional arguments to pass when initiating the NAPALM driver (JSON format)
     * @type {string}
     * @memberof WritablePlatform
     */
    napalm_args?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritablePlatform
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePlatform
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritablePlatform
     */
    virtualmachine_count?: number;
}
/**
 * 
 * @export
 * @interface WritablePowerFeed
 */
export interface WritablePowerFeed {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerFeed
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerFeed
     */
    power_panel: number;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerFeed
     */
    rack?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    status?: WritablePowerFeedStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    type?: WritablePowerFeedTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    supply?: WritablePowerFeedSupplyEnum;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    phase?: WritablePowerFeedPhaseEnum;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerFeed
     */
    voltage?: number;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerFeed
     */
    amperage?: number;
    /**
     * Maximum permissible draw (percentage)
     * @type {number}
     * @memberof WritablePowerFeed
     */
    max_utilization?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    comments?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritablePowerFeed
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerFeed
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerFeed
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritablePowerFeed
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritablePowerFeed
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritablePowerFeed
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerFeed
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePowerFeedStatusEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Failed = 'failed'
}
/**
    * @export
    * @enum {string}
    */
export enum WritablePowerFeedTypeEnum {
    Primary = 'primary',
    Redundant = 'redundant'
}
/**
    * @export
    * @enum {string}
    */
export enum WritablePowerFeedSupplyEnum {
    Ac = 'ac',
    Dc = 'dc'
}
/**
    * @export
    * @enum {string}
    */
export enum WritablePowerFeedPhaseEnum {
    SinglePhase = 'single-phase',
    ThreePhase = 'three-phase'
}

/**
 * 
 * @export
 * @interface WritablePowerOutlet
 */
export interface WritablePowerOutlet {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutlet
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutlet
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    label?: string;
    /**
     * Physical port type
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    type?: WritablePowerOutletTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutlet
     */
    power_port?: number | null;
    /**
     * Phase (for three-phase feeds)
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    feed_leg?: WritablePowerOutletFeedLegEnum;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritablePowerOutlet
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerOutlet
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerOutlet
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutlet
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritablePowerOutlet
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritablePowerOutlet
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePowerOutletTypeEnum {
    Iec60320C5 = 'iec-60320-c5',
    Iec60320C7 = 'iec-60320-c7',
    Iec60320C13 = 'iec-60320-c13',
    Iec60320C15 = 'iec-60320-c15',
    Iec60320C19 = 'iec-60320-c19',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115r = 'nema-1-15r',
    Nema515r = 'nema-5-15r',
    Nema520r = 'nema-5-20r',
    Nema530r = 'nema-5-30r',
    Nema550r = 'nema-5-50r',
    Nema615r = 'nema-6-15r',
    Nema620r = 'nema-6-20r',
    Nema630r = 'nema-6-30r',
    Nema650r = 'nema-6-50r',
    Nema1030r = 'nema-10-30r',
    Nema1050r = 'nema-10-50r',
    Nema1420r = 'nema-14-20r',
    Nema1430r = 'nema-14-30r',
    Nema1450r = 'nema-14-50r',
    Nema1460r = 'nema-14-60r',
    Nema1515r = 'nema-15-15r',
    Nema1520r = 'nema-15-20r',
    Nema1530r = 'nema-15-30r',
    Nema1550r = 'nema-15-50r',
    Nema1560r = 'nema-15-60r',
    NemaL115r = 'nema-l1-15r',
    NemaL515r = 'nema-l5-15r',
    NemaL520r = 'nema-l5-20r',
    NemaL530r = 'nema-l5-30r',
    NemaL550r = 'nema-l5-50r',
    NemaL615r = 'nema-l6-15r',
    NemaL620r = 'nema-l6-20r',
    NemaL630r = 'nema-l6-30r',
    NemaL650r = 'nema-l6-50r',
    NemaL1030r = 'nema-l10-30r',
    NemaL1420r = 'nema-l14-20r',
    NemaL1430r = 'nema-l14-30r',
    NemaL1450r = 'nema-l14-50r',
    NemaL1460r = 'nema-l14-60r',
    NemaL1520r = 'nema-l15-20r',
    NemaL1530r = 'nema-l15-30r',
    NemaL1550r = 'nema-l15-50r',
    NemaL1560r = 'nema-l15-60r',
    NemaL2120r = 'nema-l21-20r',
    NemaL2130r = 'nema-l21-30r',
    Cs6360C = 'CS6360C',
    Cs6364C = 'CS6364C',
    Cs8164C = 'CS8164C',
    Cs8264C = 'CS8264C',
    Cs8364C = 'CS8364C',
    Cs8464C = 'CS8464C',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbMicroB = 'usb-micro-b',
    UsbC = 'usb-c',
    HdotCx = 'hdot-cx'
}
/**
    * @export
    * @enum {string}
    */
export enum WritablePowerOutletFeedLegEnum {
    A = 'A',
    B = 'B',
    C = 'C'
}

/**
 * 
 * @export
 * @interface WritablePowerOutletTemplate
 */
export interface WritablePowerOutletTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutletTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutletTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    type?: WritablePowerOutletTemplateTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerOutletTemplate
     */
    power_port?: number | null;
    /**
     * Phase (for three-phase feeds)
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    feed_leg?: WritablePowerOutletTemplateFeedLegEnum;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerOutletTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePowerOutletTemplateTypeEnum {
    Iec60320C5 = 'iec-60320-c5',
    Iec60320C7 = 'iec-60320-c7',
    Iec60320C13 = 'iec-60320-c13',
    Iec60320C15 = 'iec-60320-c15',
    Iec60320C19 = 'iec-60320-c19',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115r = 'nema-1-15r',
    Nema515r = 'nema-5-15r',
    Nema520r = 'nema-5-20r',
    Nema530r = 'nema-5-30r',
    Nema550r = 'nema-5-50r',
    Nema615r = 'nema-6-15r',
    Nema620r = 'nema-6-20r',
    Nema630r = 'nema-6-30r',
    Nema650r = 'nema-6-50r',
    Nema1030r = 'nema-10-30r',
    Nema1050r = 'nema-10-50r',
    Nema1420r = 'nema-14-20r',
    Nema1430r = 'nema-14-30r',
    Nema1450r = 'nema-14-50r',
    Nema1460r = 'nema-14-60r',
    Nema1515r = 'nema-15-15r',
    Nema1520r = 'nema-15-20r',
    Nema1530r = 'nema-15-30r',
    Nema1550r = 'nema-15-50r',
    Nema1560r = 'nema-15-60r',
    NemaL115r = 'nema-l1-15r',
    NemaL515r = 'nema-l5-15r',
    NemaL520r = 'nema-l5-20r',
    NemaL530r = 'nema-l5-30r',
    NemaL550r = 'nema-l5-50r',
    NemaL615r = 'nema-l6-15r',
    NemaL620r = 'nema-l6-20r',
    NemaL630r = 'nema-l6-30r',
    NemaL650r = 'nema-l6-50r',
    NemaL1030r = 'nema-l10-30r',
    NemaL1420r = 'nema-l14-20r',
    NemaL1430r = 'nema-l14-30r',
    NemaL1450r = 'nema-l14-50r',
    NemaL1460r = 'nema-l14-60r',
    NemaL1520r = 'nema-l15-20r',
    NemaL1530r = 'nema-l15-30r',
    NemaL1550r = 'nema-l15-50r',
    NemaL1560r = 'nema-l15-60r',
    NemaL2120r = 'nema-l21-20r',
    NemaL2130r = 'nema-l21-30r',
    Cs6360C = 'CS6360C',
    Cs6364C = 'CS6364C',
    Cs8164C = 'CS8164C',
    Cs8264C = 'CS8264C',
    Cs8364C = 'CS8364C',
    Cs8464C = 'CS8464C',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbMicroB = 'usb-micro-b',
    UsbC = 'usb-c',
    HdotCx = 'hdot-cx'
}
/**
    * @export
    * @enum {string}
    */
export enum WritablePowerOutletTemplateFeedLegEnum {
    A = 'A',
    B = 'B',
    C = 'C'
}

/**
 * 
 * @export
 * @interface WritablePowerPanel
 */
export interface WritablePowerPanel {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPanel
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPanel
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPanel
     */
    site: number;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPanel
     */
    rack_group?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPanel
     */
    name: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritablePowerPanel
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritablePowerPanel
     */
    custom_fields?: object;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPanel
     */
    powerfeed_count?: number;
}
/**
 * 
 * @export
 * @interface WritablePowerPort
 */
export interface WritablePowerPort {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPort
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPort
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritablePowerPort
     */
    label?: string;
    /**
     * Physical port type
     * @type {string}
     * @memberof WritablePowerPort
     */
    type?: WritablePowerPortTypeEnum;
    /**
     * Maximum power draw (watts)
     * @type {number}
     * @memberof WritablePowerPort
     */
    maximum_draw?: number | null;
    /**
     * Allocated power draw (watts)
     * @type {number}
     * @memberof WritablePowerPort
     */
    allocated_draw?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritablePowerPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPort
     */
    cable_peer_type?: string;
    /**
     *  Return the appropriate serializer for the type of connected object. 
     * @type {{ [key: string]: string; }}
     * @memberof WritablePowerPort
     */
    connected_endpoint?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPort
     */
    connected_endpoint_type?: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritablePowerPort
     */
    connected_endpoint_reachable?: boolean;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritablePowerPort
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePowerPortTypeEnum {
    Iec60320C6 = 'iec-60320-c6',
    Iec60320C8 = 'iec-60320-c8',
    Iec60320C14 = 'iec-60320-c14',
    Iec60320C16 = 'iec-60320-c16',
    Iec60320C20 = 'iec-60320-c20',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115p = 'nema-1-15p',
    Nema515p = 'nema-5-15p',
    Nema520p = 'nema-5-20p',
    Nema530p = 'nema-5-30p',
    Nema550p = 'nema-5-50p',
    Nema615p = 'nema-6-15p',
    Nema620p = 'nema-6-20p',
    Nema630p = 'nema-6-30p',
    Nema650p = 'nema-6-50p',
    Nema1030p = 'nema-10-30p',
    Nema1050p = 'nema-10-50p',
    Nema1420p = 'nema-14-20p',
    Nema1430p = 'nema-14-30p',
    Nema1450p = 'nema-14-50p',
    Nema1460p = 'nema-14-60p',
    Nema1515p = 'nema-15-15p',
    Nema1520p = 'nema-15-20p',
    Nema1530p = 'nema-15-30p',
    Nema1550p = 'nema-15-50p',
    Nema1560p = 'nema-15-60p',
    NemaL115p = 'nema-l1-15p',
    NemaL515p = 'nema-l5-15p',
    NemaL520p = 'nema-l5-20p',
    NemaL530p = 'nema-l5-30p',
    NemaL550p = 'nema-l5-50p',
    NemaL615p = 'nema-l6-15p',
    NemaL620p = 'nema-l6-20p',
    NemaL630p = 'nema-l6-30p',
    NemaL650p = 'nema-l6-50p',
    NemaL1030p = 'nema-l10-30p',
    NemaL1420p = 'nema-l14-20p',
    NemaL1430p = 'nema-l14-30p',
    NemaL1450p = 'nema-l14-50p',
    NemaL1460p = 'nema-l14-60p',
    NemaL1520p = 'nema-l15-20p',
    NemaL1530p = 'nema-l15-30p',
    NemaL1550p = 'nema-l15-50p',
    NemaL1560p = 'nema-l15-60p',
    NemaL2120p = 'nema-l21-20p',
    NemaL2130p = 'nema-l21-30p',
    Cs6361c = 'cs6361c',
    Cs6365c = 'cs6365c',
    Cs8165c = 'cs8165c',
    Cs8265c = 'cs8265c',
    Cs8365c = 'cs8365c',
    Cs8465c = 'cs8465c',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaEf = 'ita-ef',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Usb3B = 'usb-3-b',
    Usb3MicroB = 'usb-3-micro-b'
}

/**
 * 
 * @export
 * @interface WritablePowerPortTemplate
 */
export interface WritablePowerPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePowerPortTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritablePowerPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPortTemplate
     */
    type?: WritablePowerPortTemplateTypeEnum;
    /**
     * Maximum power draw (watts)
     * @type {number}
     * @memberof WritablePowerPortTemplate
     */
    maximum_draw?: number | null;
    /**
     * Allocated power draw (watts)
     * @type {number}
     * @memberof WritablePowerPortTemplate
     */
    allocated_draw?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritablePowerPortTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePowerPortTemplateTypeEnum {
    Iec60320C6 = 'iec-60320-c6',
    Iec60320C8 = 'iec-60320-c8',
    Iec60320C14 = 'iec-60320-c14',
    Iec60320C16 = 'iec-60320-c16',
    Iec60320C20 = 'iec-60320-c20',
    Iec60309PNE4h = 'iec-60309-p-n-e-4h',
    Iec60309PNE6h = 'iec-60309-p-n-e-6h',
    Iec60309PNE9h = 'iec-60309-p-n-e-9h',
    Iec603092pE4h = 'iec-60309-2p-e-4h',
    Iec603092pE6h = 'iec-60309-2p-e-6h',
    Iec603092pE9h = 'iec-60309-2p-e-9h',
    Iec603093pE4h = 'iec-60309-3p-e-4h',
    Iec603093pE6h = 'iec-60309-3p-e-6h',
    Iec603093pE9h = 'iec-60309-3p-e-9h',
    Iec603093pNE4h = 'iec-60309-3p-n-e-4h',
    Iec603093pNE6h = 'iec-60309-3p-n-e-6h',
    Iec603093pNE9h = 'iec-60309-3p-n-e-9h',
    Nema115p = 'nema-1-15p',
    Nema515p = 'nema-5-15p',
    Nema520p = 'nema-5-20p',
    Nema530p = 'nema-5-30p',
    Nema550p = 'nema-5-50p',
    Nema615p = 'nema-6-15p',
    Nema620p = 'nema-6-20p',
    Nema630p = 'nema-6-30p',
    Nema650p = 'nema-6-50p',
    Nema1030p = 'nema-10-30p',
    Nema1050p = 'nema-10-50p',
    Nema1420p = 'nema-14-20p',
    Nema1430p = 'nema-14-30p',
    Nema1450p = 'nema-14-50p',
    Nema1460p = 'nema-14-60p',
    Nema1515p = 'nema-15-15p',
    Nema1520p = 'nema-15-20p',
    Nema1530p = 'nema-15-30p',
    Nema1550p = 'nema-15-50p',
    Nema1560p = 'nema-15-60p',
    NemaL115p = 'nema-l1-15p',
    NemaL515p = 'nema-l5-15p',
    NemaL520p = 'nema-l5-20p',
    NemaL530p = 'nema-l5-30p',
    NemaL550p = 'nema-l5-50p',
    NemaL615p = 'nema-l6-15p',
    NemaL620p = 'nema-l6-20p',
    NemaL630p = 'nema-l6-30p',
    NemaL650p = 'nema-l6-50p',
    NemaL1030p = 'nema-l10-30p',
    NemaL1420p = 'nema-l14-20p',
    NemaL1430p = 'nema-l14-30p',
    NemaL1450p = 'nema-l14-50p',
    NemaL1460p = 'nema-l14-60p',
    NemaL1520p = 'nema-l15-20p',
    NemaL1530p = 'nema-l15-30p',
    NemaL1550p = 'nema-l15-50p',
    NemaL1560p = 'nema-l15-60p',
    NemaL2120p = 'nema-l21-20p',
    NemaL2130p = 'nema-l21-30p',
    Cs6361c = 'cs6361c',
    Cs6365c = 'cs6365c',
    Cs8165c = 'cs8165c',
    Cs8265c = 'cs8265c',
    Cs8365c = 'cs8365c',
    Cs8465c = 'cs8465c',
    ItaE = 'ita-e',
    ItaF = 'ita-f',
    ItaEf = 'ita-ef',
    ItaG = 'ita-g',
    ItaH = 'ita-h',
    ItaI = 'ita-i',
    ItaJ = 'ita-j',
    ItaK = 'ita-k',
    ItaL = 'ita-l',
    ItaM = 'ita-m',
    ItaN = 'ita-n',
    ItaO = 'ita-o',
    UsbA = 'usb-a',
    UsbB = 'usb-b',
    UsbC = 'usb-c',
    UsbMiniA = 'usb-mini-a',
    UsbMiniB = 'usb-mini-b',
    UsbMicroA = 'usb-micro-a',
    UsbMicroB = 'usb-micro-b',
    Usb3B = 'usb-3-b',
    Usb3MicroB = 'usb-3-micro-b'
}

/**
 * 
 * @export
 * @interface WritablePrefix
 */
export interface WritablePrefix {
    /**
     * 
     * @type {number}
     * @memberof WritablePrefix
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritablePrefix
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePrefix
     */
    family?: string;
    /**
     * IPv4 or IPv6 network with mask
     * @type {string}
     * @memberof WritablePrefix
     */
    prefix: string;
    /**
     * 
     * @type {number}
     * @memberof WritablePrefix
     */
    site?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritablePrefix
     */
    vrf?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritablePrefix
     */
    tenant?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritablePrefix
     */
    vlan?: number | null;
    /**
     * Operational status of this prefix
     * @type {string}
     * @memberof WritablePrefix
     */
    status?: WritablePrefixStatusEnum;
    /**
     * The primary function of this prefix
     * @type {number}
     * @memberof WritablePrefix
     */
    role?: number | null;
    /**
     * All IP addresses within this prefix are considered usable
     * @type {boolean}
     * @memberof WritablePrefix
     */
    is_pool?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritablePrefix
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritablePrefix
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritablePrefix
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritablePrefix
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritablePrefix
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritablePrefixStatusEnum {
    Container = 'container',
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated'
}

/**
 * 
 * @export
 * @interface WritableRack
 */
export interface WritableRack {
    /**
     * 
     * @type {number}
     * @memberof WritableRack
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    name: string;
    /**
     * Locally-assigned identifier
     * @type {string}
     * @memberof WritableRack
     */
    facility_id?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    display_name?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRack
     */
    site: number;
    /**
     * Assigned group
     * @type {number}
     * @memberof WritableRack
     */
    group?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableRack
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    status?: WritableRackStatusEnum;
    /**
     * Functional role
     * @type {number}
     * @memberof WritableRack
     */
    role?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    serial?: string;
    /**
     * A unique tag used to identify this rack
     * @type {string}
     * @memberof WritableRack
     */
    asset_tag?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    type?: WritableRackTypeEnum;
    /**
     * Rail-to-rail width
     * @type {number}
     * @memberof WritableRack
     */
    width?: number;
    /**
     * Height in rack units
     * @type {number}
     * @memberof WritableRack
     */
    u_height?: number;
    /**
     * Units are numbered top-to-bottom
     * @type {boolean}
     * @memberof WritableRack
     */
    desc_units?: boolean;
    /**
     * Outer dimension of rack (width)
     * @type {number}
     * @memberof WritableRack
     */
    outer_width?: number | null;
    /**
     * Outer dimension of rack (depth)
     * @type {number}
     * @memberof WritableRack
     */
    outer_depth?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    outer_unit?: WritableRackOuterUnitEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableRack
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableRack
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRack
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRack
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableRack
     */
    powerfeed_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableRackStatusEnum {
    Reserved = 'reserved',
    Available = 'available',
    Planned = 'planned',
    Active = 'active',
    Deprecated = 'deprecated'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableRackTypeEnum {
    _2PostFrame = '2-post-frame',
    _4PostFrame = '4-post-frame',
    _4PostCabinet = '4-post-cabinet',
    WallFrame = 'wall-frame',
    WallCabinet = 'wall-cabinet'
}
/**
    * @export
    * @enum {string}
    */
export enum WritableRackOuterUnitEnum {
    Mm = 'mm',
    In = 'in'
}

/**
 * 
 * @export
 * @interface WritableRackGroup
 */
export interface WritableRackGroup {
    /**
     * 
     * @type {number}
     * @memberof WritableRackGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRackGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRackGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRackGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRackGroup
     */
    site: number;
    /**
     * 
     * @type {number}
     * @memberof WritableRackGroup
     */
    parent?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRackGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRackGroup
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableRackGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface WritableRackReservation
 */
export interface WritableRackReservation {
    /**
     * 
     * @type {number}
     * @memberof WritableRackReservation
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRackReservation
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRackReservation
     */
    rack: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof WritableRackReservation
     */
    units: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof WritableRackReservation
     */
    created?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRackReservation
     */
    user: number;
    /**
     * 
     * @type {number}
     * @memberof WritableRackReservation
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRackReservation
     */
    description: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableRackReservation
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableRackReservation
     */
    custom_fields?: object;
}
/**
 * 
 * @export
 * @interface WritableRearPort
 */
export interface WritableRearPort {
    /**
     * 
     * @type {number}
     * @memberof WritableRearPort
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPort
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRearPort
     */
    device: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPort
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableRearPort
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPort
     */
    type: WritableRearPortTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableRearPort
     */
    positions?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPort
     */
    description?: string;
    /**
     * 
     * @type {NestedCable}
     * @memberof WritableRearPort
     */
    cable?: NestedCable;
    /**
     *  Return the appropriate serializer for the cable termination model. 
     * @type {{ [key: string]: string; }}
     * @memberof WritableRearPort
     */
    cable_peer?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableRearPort
     */
    cable_peer_type?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableRearPort
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableRearPortTypeEnum {
    _8p8c = '8p8c',
    _8p6c = '8p6c',
    _8p4c = '8p4c',
    _8p2c = '8p2c',
    _110Punch = '110-punch',
    Bnc = 'bnc',
    Mrj21 = 'mrj21',
    Fc = 'fc',
    Lc = 'lc',
    LcApc = 'lc-apc',
    Lsh = 'lsh',
    LshApc = 'lsh-apc',
    Mpo = 'mpo',
    Mtrj = 'mtrj',
    Sc = 'sc',
    ScApc = 'sc-apc',
    St = 'st',
    Cs = 'cs',
    Sn = 'sn',
    Splice = 'splice'
}

/**
 * 
 * @export
 * @interface WritableRearPortTemplate
 */
export interface WritableRearPortTemplate {
    /**
     * 
     * @type {number}
     * @memberof WritableRearPortTemplate
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPortTemplate
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRearPortTemplate
     */
    device_type: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPortTemplate
     */
    name: string;
    /**
     * Physical label
     * @type {string}
     * @memberof WritableRearPortTemplate
     */
    label?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPortTemplate
     */
    type: WritableRearPortTemplateTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableRearPortTemplate
     */
    positions?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRearPortTemplate
     */
    description?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableRearPortTemplateTypeEnum {
    _8p8c = '8p8c',
    _8p6c = '8p6c',
    _8p4c = '8p4c',
    _8p2c = '8p2c',
    _110Punch = '110-punch',
    Bnc = 'bnc',
    Mrj21 = 'mrj21',
    Fc = 'fc',
    Lc = 'lc',
    LcApc = 'lc-apc',
    Lsh = 'lsh',
    LshApc = 'lsh-apc',
    Mpo = 'mpo',
    Mtrj = 'mtrj',
    Sc = 'sc',
    ScApc = 'sc-apc',
    St = 'st',
    Cs = 'cs',
    Sn = 'sn',
    Splice = 'splice'
}

/**
 * 
 * @export
 * @interface WritableRegion
 */
export interface WritableRegion {
    /**
     * 
     * @type {number}
     * @memberof WritableRegion
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRegion
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRegion
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRegion
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRegion
     */
    parent?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRegion
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRegion
     */
    site_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableRegion
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface WritableRouteTarget
 */
export interface WritableRouteTarget {
    /**
     * 
     * @type {number}
     * @memberof WritableRouteTarget
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableRouteTarget
     */
    url?: string;
    /**
     * Route target value (formatted in accordance with RFC 4360)
     * @type {string}
     * @memberof WritableRouteTarget
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof WritableRouteTarget
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableRouteTarget
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableRouteTarget
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableRouteTarget
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableRouteTarget
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableRouteTarget
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface WritableSecret
 */
export interface WritableSecret {
    /**
     * 
     * @type {number}
     * @memberof WritableSecret
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    assigned_object_type: string;
    /**
     * 
     * @type {number}
     * @memberof WritableSecret
     */
    assigned_object_id: number;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableSecret
     */
    assigned_object?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof WritableSecret
     */
    role: number;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    plaintext: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    hash?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableSecret
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableSecret
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSecret
     */
    last_updated?: string;
}
/**
 * 
 * @export
 * @interface WritableService
 */
export interface WritableService {
    /**
     * 
     * @type {number}
     * @memberof WritableService
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableService
     */
    device?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableService
     */
    virtual_machine?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    name: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof WritableService
     */
    ports: Array<number>;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    protocol: WritableServiceProtocolEnum;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableService
     */
    ipaddresses?: Set<number>;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableService
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableService
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableService
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableServiceProtocolEnum {
    Tcp = 'tcp',
    Udp = 'udp'
}

/**
 * 
 * @export
 * @interface WritableSite
 */
export interface WritableSite {
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    slug: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    status?: WritableSiteStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    region?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    tenant?: number | null;
    /**
     * Local facility ID or description
     * @type {string}
     * @memberof WritableSite
     */
    facility?: string;
    /**
     * 32-bit autonomous system number
     * @type {number}
     * @memberof WritableSite
     */
    asn?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    time_zone?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    physical_address?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    shipping_address?: string;
    /**
     * GPS coordinate (latitude)
     * @type {string}
     * @memberof WritableSite
     */
    latitude?: string | null;
    /**
     * GPS coordinate (longitude)
     * @type {string}
     * @memberof WritableSite
     */
    longitude?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    contact_name?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    contact_phone?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    contact_email?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableSite
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableSite
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableSite
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    circuit_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    virtualmachine_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableSite
     */
    vlan_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableSiteStatusEnum {
    Planned = 'planned',
    Staging = 'staging',
    Active = 'active',
    Decommissioning = 'decommissioning',
    Retired = 'retired'
}

/**
 * 
 * @export
 * @interface WritableTenant
 */
export interface WritableTenant {
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    group?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    comments?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableTenant
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableTenant
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenant
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    circuit_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    device_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    ipaddress_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    prefix_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    rack_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    site_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    virtualmachine_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    vlan_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    vrf_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenant
     */
    cluster_count?: number;
}
/**
 * 
 * @export
 * @interface WritableTenantGroup
 */
export interface WritableTenantGroup {
    /**
     * 
     * @type {number}
     * @memberof WritableTenantGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableTenantGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenantGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableTenantGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof WritableTenantGroup
     */
    parent?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableTenantGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableTenantGroup
     */
    tenant_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableTenantGroup
     */
    _depth?: number;
}
/**
 * 
 * @export
 * @interface WritableUser
 */
export interface WritableUser {
    /**
     * 
     * @type {number}
     * @memberof WritableUser
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    url?: string;
    /**
     * Required. 150 characters or fewer. Letters, digits and @/./+/-/_ only.
     * @type {string}
     * @memberof WritableUser
     */
    username: string;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    password: string;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    first_name?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    last_name?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    email?: string;
    /**
     * Designates whether the user can log into this admin site.
     * @type {boolean}
     * @memberof WritableUser
     */
    is_staff?: boolean;
    /**
     * Designates whether this user should be treated as active. Unselect this instead of deleting accounts.
     * @type {boolean}
     * @memberof WritableUser
     */
    is_active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritableUser
     */
    date_joined?: string;
    /**
     * The groups this user belongs to. A user will get all permissions granted to each of their groups.
     * @type {Set<number>}
     * @memberof WritableUser
     */
    groups?: Set<number>;
}
/**
 * 
 * @export
 * @interface WritableVLAN
 */
export interface WritableVLAN {
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    site?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    group?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    vid: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    tenant?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    status?: WritableVLANStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    role?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableVLAN
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    display_name?: string;
    /**
     * 
     * @type {object}
     * @memberof WritableVLAN
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVLAN
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVLAN
     */
    prefix_count?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableVLANStatusEnum {
    Active = 'active',
    Reserved = 'reserved',
    Deprecated = 'deprecated'
}

/**
 * 
 * @export
 * @interface WritableVLANGroup
 */
export interface WritableVLANGroup {
    /**
     * 
     * @type {number}
     * @memberof WritableVLANGroup
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVLANGroup
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVLANGroup
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVLANGroup
     */
    slug: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVLANGroup
     */
    site?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVLANGroup
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVLANGroup
     */
    vlan_count?: number;
}
/**
 * 
 * @export
 * @interface WritableVMInterface
 */
export interface WritableVMInterface {
    /**
     * 
     * @type {number}
     * @memberof WritableVMInterface
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVMInterface
     */
    url?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVMInterface
     */
    virtual_machine: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVMInterface
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof WritableVMInterface
     */
    enabled?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WritableVMInterface
     */
    mtu?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVMInterface
     */
    mac_address?: string | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVMInterface
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVMInterface
     */
    mode?: WritableVMInterfaceModeEnum;
    /**
     * 
     * @type {number}
     * @memberof WritableVMInterface
     */
    untagged_vlan?: number | null;
    /**
     * 
     * @type {Set<number>}
     * @memberof WritableVMInterface
     */
    tagged_vlans?: Set<number>;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableVMInterface
     */
    tags?: Array<NestedTag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableVMInterfaceModeEnum {
    Access = 'access',
    Tagged = 'tagged',
    TaggedAll = 'tagged-all'
}

/**
 * 
 * @export
 * @interface WritableVRF
 */
export interface WritableVRF {
    /**
     * 
     * @type {number}
     * @memberof WritableVRF
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    name: string;
    /**
     * Unique route distinguisher (as defined in RFC 4364)
     * @type {string}
     * @memberof WritableVRF
     */
    rd?: string | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVRF
     */
    tenant?: number | null;
    /**
     * Prevent duplicate prefixes/IP addresses within this VRF
     * @type {boolean}
     * @memberof WritableVRF
     */
    enforce_unique?: boolean;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    description?: string;
    /**
     * 
     * @type {Array<NestedRouteTarget>}
     * @memberof WritableVRF
     */
    import_targets?: Array<NestedRouteTarget> | null;
    /**
     * 
     * @type {Array<NestedRouteTarget>}
     * @memberof WritableVRF
     */
    export_targets?: Array<NestedRouteTarget> | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableVRF
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    display_name?: string;
    /**
     * 
     * @type {object}
     * @memberof WritableVRF
     */
    custom_fields?: object;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVRF
     */
    last_updated?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVRF
     */
    ipaddress_count?: number;
    /**
     * 
     * @type {number}
     * @memberof WritableVRF
     */
    prefix_count?: number;
}
/**
 * 
 * @export
 * @interface WritableVirtualChassis
 */
export interface WritableVirtualChassis {
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualChassis
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualChassis
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualChassis
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualChassis
     */
    domain?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualChassis
     */
    master?: number | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableVirtualChassis
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableVirtualChassis
     */
    custom_fields?: object;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualChassis
     */
    member_count?: number;
}
/**
 * 
 * @export
 * @interface WritableVirtualMachineWithConfigContext
 */
export interface WritableVirtualMachineWithConfigContext {
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    status?: WritableVirtualMachineWithConfigContextStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    site?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    cluster: number;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    role?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    tenant?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    platform?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    primary_ip?: string;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    primary_ip4?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    primary_ip6?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    vcpus?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    memory?: number | null;
    /**
     * 
     * @type {number}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    disk?: number | null;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    comments?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    local_context_data?: string | null;
    /**
     * 
     * @type {Array<NestedTag>}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    tags?: Array<NestedTag>;
    /**
     * 
     * @type {object}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    custom_fields?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    config_context?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    created?: string;
    /**
     * 
     * @type {string}
     * @memberof WritableVirtualMachineWithConfigContext
     */
    last_updated?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WritableVirtualMachineWithConfigContextStatusEnum {
    Offline = 'offline',
    Active = 'active',
    Planned = 'planned',
    Staged = 'staged',
    Failed = 'failed',
    Decommissioning = 'decommissioning'
}


/**
 * CircuitsApi - axios parameter creator
 * @export
 */
export const CircuitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkPartialUpdate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkUpdate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsCreate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsCreate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsDelete', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsList: async (termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (termSide !== undefined) {
                localVarQueryParameter['term_side'] = termSide;
            }

            if (portSpeed !== undefined) {
                localVarQueryParameter['port_speed'] = portSpeed;
            }

            if (upstreamSpeed !== undefined) {
                localVarQueryParameter['upstream_speed'] = upstreamSpeed;
            }

            if (xconnectId !== undefined) {
                localVarQueryParameter['xconnect_id'] = xconnectId;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (circuitId !== undefined) {
                localVarQueryParameter['circuit_id'] = circuitId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (termSideN !== undefined) {
                localVarQueryParameter['term_side__n'] = termSideN;
            }

            if (portSpeedN !== undefined) {
                localVarQueryParameter['port_speed__n'] = portSpeedN;
            }

            if (portSpeedLte !== undefined) {
                localVarQueryParameter['port_speed__lte'] = portSpeedLte;
            }

            if (portSpeedLt !== undefined) {
                localVarQueryParameter['port_speed__lt'] = portSpeedLt;
            }

            if (portSpeedGte !== undefined) {
                localVarQueryParameter['port_speed__gte'] = portSpeedGte;
            }

            if (portSpeedGt !== undefined) {
                localVarQueryParameter['port_speed__gt'] = portSpeedGt;
            }

            if (upstreamSpeedN !== undefined) {
                localVarQueryParameter['upstream_speed__n'] = upstreamSpeedN;
            }

            if (upstreamSpeedLte !== undefined) {
                localVarQueryParameter['upstream_speed__lte'] = upstreamSpeedLte;
            }

            if (upstreamSpeedLt !== undefined) {
                localVarQueryParameter['upstream_speed__lt'] = upstreamSpeedLt;
            }

            if (upstreamSpeedGte !== undefined) {
                localVarQueryParameter['upstream_speed__gte'] = upstreamSpeedGte;
            }

            if (upstreamSpeedGt !== undefined) {
                localVarQueryParameter['upstream_speed__gt'] = upstreamSpeedGt;
            }

            if (xconnectIdN !== undefined) {
                localVarQueryParameter['xconnect_id__n'] = xconnectIdN;
            }

            if (xconnectIdIc !== undefined) {
                localVarQueryParameter['xconnect_id__ic'] = xconnectIdIc;
            }

            if (xconnectIdNic !== undefined) {
                localVarQueryParameter['xconnect_id__nic'] = xconnectIdNic;
            }

            if (xconnectIdIew !== undefined) {
                localVarQueryParameter['xconnect_id__iew'] = xconnectIdIew;
            }

            if (xconnectIdNiew !== undefined) {
                localVarQueryParameter['xconnect_id__niew'] = xconnectIdNiew;
            }

            if (xconnectIdIsw !== undefined) {
                localVarQueryParameter['xconnect_id__isw'] = xconnectIdIsw;
            }

            if (xconnectIdNisw !== undefined) {
                localVarQueryParameter['xconnect_id__nisw'] = xconnectIdNisw;
            }

            if (xconnectIdIe !== undefined) {
                localVarQueryParameter['xconnect_id__ie'] = xconnectIdIe;
            }

            if (xconnectIdNie !== undefined) {
                localVarQueryParameter['xconnect_id__nie'] = xconnectIdNie;
            }

            if (circuitIdN !== undefined) {
                localVarQueryParameter['circuit_id__n'] = circuitIdN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsPartialUpdate: async (id: number, data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsRead', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsTrace', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsUpdate: async (id: number, data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkPartialUpdate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkUpdate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesCreate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesCreate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesDelete', 'id', id)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesList: async (id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesPartialUpdate: async (id: number, data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesRead', 'id', id)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesUpdate: async (id: number, data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkPartialUpdate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkUpdate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsCreate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsCreate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsDelete', 'id', id)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsList: async (id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }

            if (installDate !== undefined) {
                localVarQueryParameter['install_date'] = installDate;
            }

            if (commitRate !== undefined) {
                localVarQueryParameter['commit_rate'] = commitRate;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (cidN !== undefined) {
                localVarQueryParameter['cid__n'] = cidN;
            }

            if (cidIc !== undefined) {
                localVarQueryParameter['cid__ic'] = cidIc;
            }

            if (cidNic !== undefined) {
                localVarQueryParameter['cid__nic'] = cidNic;
            }

            if (cidIew !== undefined) {
                localVarQueryParameter['cid__iew'] = cidIew;
            }

            if (cidNiew !== undefined) {
                localVarQueryParameter['cid__niew'] = cidNiew;
            }

            if (cidIsw !== undefined) {
                localVarQueryParameter['cid__isw'] = cidIsw;
            }

            if (cidNisw !== undefined) {
                localVarQueryParameter['cid__nisw'] = cidNisw;
            }

            if (cidIe !== undefined) {
                localVarQueryParameter['cid__ie'] = cidIe;
            }

            if (cidNie !== undefined) {
                localVarQueryParameter['cid__nie'] = cidNie;
            }

            if (installDateN !== undefined) {
                localVarQueryParameter['install_date__n'] = installDateN;
            }

            if (installDateLte !== undefined) {
                localVarQueryParameter['install_date__lte'] = installDateLte;
            }

            if (installDateLt !== undefined) {
                localVarQueryParameter['install_date__lt'] = installDateLt;
            }

            if (installDateGte !== undefined) {
                localVarQueryParameter['install_date__gte'] = installDateGte;
            }

            if (installDateGt !== undefined) {
                localVarQueryParameter['install_date__gt'] = installDateGt;
            }

            if (commitRateN !== undefined) {
                localVarQueryParameter['commit_rate__n'] = commitRateN;
            }

            if (commitRateLte !== undefined) {
                localVarQueryParameter['commit_rate__lte'] = commitRateLte;
            }

            if (commitRateLt !== undefined) {
                localVarQueryParameter['commit_rate__lt'] = commitRateLt;
            }

            if (commitRateGte !== undefined) {
                localVarQueryParameter['commit_rate__gte'] = commitRateGte;
            }

            if (commitRateGt !== undefined) {
                localVarQueryParameter['commit_rate__gt'] = commitRateGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (providerIdN !== undefined) {
                localVarQueryParameter['provider_id__n'] = providerIdN;
            }

            if (providerN !== undefined) {
                localVarQueryParameter['provider__n'] = providerN;
            }

            if (typeIdN !== undefined) {
                localVarQueryParameter['type_id__n'] = typeIdN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsPartialUpdate: async (id: number, data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsRead', 'id', id)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsUpdate: async (id: number, data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkPartialUpdate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkUpdate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersBulkUpdate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersCreate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersCreate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersDelete', 'id', id)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersList: async (id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (asnN !== undefined) {
                localVarQueryParameter['asn__n'] = asnN;
            }

            if (asnLte !== undefined) {
                localVarQueryParameter['asn__lte'] = asnLte;
            }

            if (asnLt !== undefined) {
                localVarQueryParameter['asn__lt'] = asnLt;
            }

            if (asnGte !== undefined) {
                localVarQueryParameter['asn__gte'] = asnGte;
            }

            if (asnGt !== undefined) {
                localVarQueryParameter['asn__gt'] = asnGt;
            }

            if (accountN !== undefined) {
                localVarQueryParameter['account__n'] = accountN;
            }

            if (accountIc !== undefined) {
                localVarQueryParameter['account__ic'] = accountIc;
            }

            if (accountNic !== undefined) {
                localVarQueryParameter['account__nic'] = accountNic;
            }

            if (accountIew !== undefined) {
                localVarQueryParameter['account__iew'] = accountIew;
            }

            if (accountNiew !== undefined) {
                localVarQueryParameter['account__niew'] = accountNiew;
            }

            if (accountIsw !== undefined) {
                localVarQueryParameter['account__isw'] = accountIsw;
            }

            if (accountNisw !== undefined) {
                localVarQueryParameter['account__nisw'] = accountNisw;
            }

            if (accountIe !== undefined) {
                localVarQueryParameter['account__ie'] = accountIe;
            }

            if (accountNie !== undefined) {
                localVarQueryParameter['account__nie'] = accountNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersPartialUpdate: async (id: number, data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersPartialUpdate', 'data', data)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersRead', 'id', id)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersUpdate: async (id: number, data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersUpdate', 'data', data)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CircuitsApi - functional programming interface
 * @export
 */
export const CircuitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CircuitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkPartialUpdate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkUpdate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsCreate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsList(termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsList(termSide, portSpeed, upstreamSpeed, xconnectId, cabled, connected, q, circuitId, siteId, site, termSideN, portSpeedN, portSpeedLte, portSpeedLt, portSpeedGte, portSpeedGt, upstreamSpeedN, upstreamSpeedLte, upstreamSpeedLt, upstreamSpeedGte, upstreamSpeedGt, xconnectIdN, xconnectIdIc, xconnectIdNic, xconnectIdIew, xconnectIdNiew, xconnectIdIsw, xconnectIdNisw, xconnectIdIe, xconnectIdNie, circuitIdN, siteIdN, siteN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsPartialUpdate(id: number, data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsUpdate(id: number, data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkPartialUpdate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkUpdate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesCreate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesPartialUpdate(id: number, data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesUpdate(id: number, data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkPartialUpdate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkUpdate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsCreate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsList(id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsList(id, cid, installDate, commitRate, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, providerId, provider, typeId, type, status, siteId, site, regionId, region, tag, idN, idLte, idLt, idGte, idGt, cidN, cidIc, cidNic, cidIew, cidNiew, cidIsw, cidNisw, cidIe, cidNie, installDateN, installDateLte, installDateLt, installDateGte, installDateGt, commitRateN, commitRateLte, commitRateLt, commitRateGte, commitRateGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, providerIdN, providerN, typeIdN, typeN, statusN, siteIdN, siteN, regionIdN, regionN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsPartialUpdate(id: number, data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsUpdate(id: number, data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkPartialUpdate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkUpdate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersCreate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersList(id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersList(id, name, slug, asn, account, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, asnN, asnLte, asnLt, asnGte, asnGt, accountN, accountIc, accountNic, accountIew, accountNiew, accountIsw, accountNisw, accountIe, accountNie, regionIdN, regionN, siteIdN, siteN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersPartialUpdate(id: number, data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersUpdate(id: number, data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CircuitsApi - factory interface
 * @export
 */
export const CircuitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CircuitsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTerminationsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkPartialUpdate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkUpdate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsCreate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTerminationsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsList(termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.circuitsCircuitTerminationsList(termSide, portSpeed, upstreamSpeed, xconnectId, cabled, connected, q, circuitId, siteId, site, termSideN, portSpeedN, portSpeedLte, portSpeedLt, portSpeedGte, portSpeedGt, upstreamSpeedN, upstreamSpeedLte, upstreamSpeedLt, upstreamSpeedGte, upstreamSpeedGt, xconnectIdN, xconnectIdIc, xconnectIdNic, xconnectIdIew, xconnectIdNiew, xconnectIdIsw, xconnectIdNisw, xconnectIdIe, xconnectIdNie, circuitIdN, siteIdN, siteN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsPartialUpdate(id: number, data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsRead(id: number, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsTrace(id: number, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsUpdate(id: number, data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkPartialUpdate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkUpdate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesCreate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.circuitsCircuitTypesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesPartialUpdate(id: number, data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesRead(id: number, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesUpdate(id: number, data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkPartialUpdate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkUpdate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsCreate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsList(id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.circuitsCircuitsList(id, cid, installDate, commitRate, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, providerId, provider, typeId, type, status, siteId, site, regionId, region, tag, idN, idLte, idLt, idGte, idGt, cidN, cidIc, cidNic, cidIew, cidNiew, cidIsw, cidNisw, cidIe, cidNie, installDateN, installDateLte, installDateLt, installDateGte, installDateGt, commitRateN, commitRateLte, commitRateLt, commitRateGte, commitRateGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, providerIdN, providerN, typeIdN, typeN, statusN, siteIdN, siteN, regionIdN, regionN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsPartialUpdate(id: number, data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsRead(id: number, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsUpdate(id: number, data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsProvidersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkPartialUpdate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkUpdate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersCreate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsProvidersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersList(id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.circuitsProvidersList(id, name, slug, asn, account, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, asnN, asnLte, asnLt, asnGte, asnGt, accountN, accountIc, accountNic, accountIew, accountNiew, accountIsw, accountNisw, accountIe, accountNie, regionIdN, regionN, siteIdN, siteN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersPartialUpdate(id: number, data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersRead(id: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersUpdate(id: number, data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for circuitsCircuitTerminationsBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsBulkUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsCreateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsCreateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsCreate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsDeleteRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsListRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly termSide?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeed?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeed?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly circuitId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly termSideN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly circuitIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitTerminationsPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsPartialUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsReadRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsReadRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsTrace operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsTraceRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsTraceRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsTrace
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsUpdateRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTypesBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesBulkPartialUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesBulkUpdateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesBulkUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesCreateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesCreateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesCreate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitTypesDeleteRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTypesList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesListRequest
 */
export interface CircuitsApiCircuitsCircuitTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitTypesPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesPartialUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesReadRequest
 */
export interface CircuitsApiCircuitsCircuitTypesReadRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTypesUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesUpdateRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitsBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsBulkPartialUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsBulkUpdateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsBulkUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsCreateRequest
 */
export interface CircuitsApiCircuitsCircuitsCreateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsCreate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitsDeleteRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitsList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsListRequest
 */
export interface CircuitsApiCircuitsCircuitsListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cid?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDate?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRate?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly provider?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitsPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsPartialUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsReadRequest
 */
export interface CircuitsApiCircuitsCircuitsReadRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitsUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsUpdateRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsProvidersBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersBulkPartialUpdateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersBulkPartialUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersBulkUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersBulkUpdateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersBulkUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersCreateRequest
 */
export interface CircuitsApiCircuitsProvidersCreateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersCreate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersDeleteRequest
 */
export interface CircuitsApiCircuitsProvidersDeleteRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsProvidersList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersListRequest
 */
export interface CircuitsApiCircuitsProvidersListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asn?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly account?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsProvidersPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersPartialUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersPartialUpdateRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersPartialUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersReadRequest
 */
export interface CircuitsApiCircuitsProvidersReadRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsProvidersUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersUpdateRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersUpdate
     */
    readonly data: Provider
}

/**
 * CircuitsApi - object-oriented interface
 * @export
 * @class CircuitsApi
 * @extends {BaseAPI}
 */
export class CircuitsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsCreate(requestParameters: CircuitsApiCircuitsCircuitTerminationsCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsDelete(requestParameters: CircuitsApiCircuitsCircuitTerminationsDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsList(requestParameters: CircuitsApiCircuitsCircuitTerminationsListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsList(requestParameters.termSide, requestParameters.portSpeed, requestParameters.upstreamSpeed, requestParameters.xconnectId, requestParameters.cabled, requestParameters.connected, requestParameters.q, requestParameters.circuitId, requestParameters.siteId, requestParameters.site, requestParameters.termSideN, requestParameters.portSpeedN, requestParameters.portSpeedLte, requestParameters.portSpeedLt, requestParameters.portSpeedGte, requestParameters.portSpeedGt, requestParameters.upstreamSpeedN, requestParameters.upstreamSpeedLte, requestParameters.upstreamSpeedLt, requestParameters.upstreamSpeedGte, requestParameters.upstreamSpeedGt, requestParameters.xconnectIdN, requestParameters.xconnectIdIc, requestParameters.xconnectIdNic, requestParameters.xconnectIdIew, requestParameters.xconnectIdNiew, requestParameters.xconnectIdIsw, requestParameters.xconnectIdNisw, requestParameters.xconnectIdIe, requestParameters.xconnectIdNie, requestParameters.circuitIdN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsRead(requestParameters: CircuitsApiCircuitsCircuitTerminationsReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {CircuitsApiCircuitsCircuitTerminationsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsTrace(requestParameters: CircuitsApiCircuitsCircuitTerminationsTraceRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesCreate(requestParameters: CircuitsApiCircuitsCircuitTypesCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesDelete(requestParameters: CircuitsApiCircuitsCircuitTypesDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesList(requestParameters: CircuitsApiCircuitsCircuitTypesListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesRead(requestParameters: CircuitsApiCircuitsCircuitTypesReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitsBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsCreate(requestParameters: CircuitsApiCircuitsCircuitsCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsDelete(requestParameters: CircuitsApiCircuitsCircuitsDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsList(requestParameters: CircuitsApiCircuitsCircuitsListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsList(requestParameters.id, requestParameters.cid, requestParameters.installDate, requestParameters.commitRate, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.providerId, requestParameters.provider, requestParameters.typeId, requestParameters.type, requestParameters.status, requestParameters.siteId, requestParameters.site, requestParameters.regionId, requestParameters.region, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.cidN, requestParameters.cidIc, requestParameters.cidNic, requestParameters.cidIew, requestParameters.cidNiew, requestParameters.cidIsw, requestParameters.cidNisw, requestParameters.cidIe, requestParameters.cidNie, requestParameters.installDateN, requestParameters.installDateLte, requestParameters.installDateLt, requestParameters.installDateGte, requestParameters.installDateGt, requestParameters.commitRateN, requestParameters.commitRateLte, requestParameters.commitRateLt, requestParameters.commitRateGte, requestParameters.commitRateGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.providerIdN, requestParameters.providerN, requestParameters.typeIdN, requestParameters.typeN, requestParameters.statusN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitsPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsRead(requestParameters: CircuitsApiCircuitsCircuitsReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsUpdate(requestParameters: CircuitsApiCircuitsCircuitsUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkPartialUpdate(requestParameters: CircuitsApiCircuitsProvidersBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkUpdate(requestParameters: CircuitsApiCircuitsProvidersBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersCreate(requestParameters: CircuitsApiCircuitsProvidersCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersDelete(requestParameters: CircuitsApiCircuitsProvidersDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersList(requestParameters: CircuitsApiCircuitsProvidersListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.asn, requestParameters.account, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.asnN, requestParameters.asnLte, requestParameters.asnLt, requestParameters.asnGte, requestParameters.asnGt, requestParameters.accountN, requestParameters.accountIc, requestParameters.accountNic, requestParameters.accountIew, requestParameters.accountNiew, requestParameters.accountIsw, requestParameters.accountNisw, requestParameters.accountIe, requestParameters.accountNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersPartialUpdate(requestParameters: CircuitsApiCircuitsProvidersPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersRead(requestParameters: CircuitsApiCircuitsProvidersReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersUpdate(requestParameters: CircuitsApiCircuitsProvidersUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DcimApi - axios parameter creator
 * @export
 */
export const DcimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkPartialUpdate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkUpdate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesCreate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesCreate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesDelete', 'id', id)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesList: async (id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['length_unit'] = lengthUnit;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (rack !== undefined) {
                localVarQueryParameter['rack'] = rack;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (labelN !== undefined) {
                localVarQueryParameter['label__n'] = labelN;
            }

            if (labelIc !== undefined) {
                localVarQueryParameter['label__ic'] = labelIc;
            }

            if (labelNic !== undefined) {
                localVarQueryParameter['label__nic'] = labelNic;
            }

            if (labelIew !== undefined) {
                localVarQueryParameter['label__iew'] = labelIew;
            }

            if (labelNiew !== undefined) {
                localVarQueryParameter['label__niew'] = labelNiew;
            }

            if (labelIsw !== undefined) {
                localVarQueryParameter['label__isw'] = labelIsw;
            }

            if (labelNisw !== undefined) {
                localVarQueryParameter['label__nisw'] = labelNisw;
            }

            if (labelIe !== undefined) {
                localVarQueryParameter['label__ie'] = labelIe;
            }

            if (labelNie !== undefined) {
                localVarQueryParameter['label__nie'] = labelNie;
            }

            if (lengthN !== undefined) {
                localVarQueryParameter['length__n'] = lengthN;
            }

            if (lengthLte !== undefined) {
                localVarQueryParameter['length__lte'] = lengthLte;
            }

            if (lengthLt !== undefined) {
                localVarQueryParameter['length__lt'] = lengthLt;
            }

            if (lengthGte !== undefined) {
                localVarQueryParameter['length__gte'] = lengthGte;
            }

            if (lengthGt !== undefined) {
                localVarQueryParameter['length__gt'] = lengthGt;
            }

            if (lengthUnitN !== undefined) {
                localVarQueryParameter['length_unit__n'] = lengthUnitN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesPartialUpdate: async (id: number, data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesRead', 'id', id)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesUpdate: async (id: number, data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesUpdate', 'data', data)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConnectedDeviceList: async (peerDevice: string, peerInterface: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerDevice' is not null or undefined
            assertParamExists('dcimConnectedDeviceList', 'peerDevice', peerDevice)
            // verify required parameter 'peerInterface' is not null or undefined
            assertParamExists('dcimConnectedDeviceList', 'peerInterface', peerInterface)
            const localVarPath = `/dcim/connected-device/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (peerDevice !== undefined) {
                localVarQueryParameter['peer_device'] = peerDevice;
            }

            if (peerInterface !== undefined) {
                localVarQueryParameter['peer_interface'] = peerInterface;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleConnectionsList: async (name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkPartialUpdate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkUpdate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesCreate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesPartialUpdate: async (id: number, data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesUpdate: async (id: number, data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkPartialUpdate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkUpdate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsCreate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsCreate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsDelete', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsPartialUpdate: async (id: number, data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsRead', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsTrace', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsUpdate: async (id: number, data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkPartialUpdate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkUpdate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesCreate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesPartialUpdate: async (id: number, data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesUpdate: async (id: number, data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkPartialUpdate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkUpdate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsCreate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsCreate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsDelete', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsPartialUpdate: async (id: number, data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsRead', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsTrace', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsUpdate: async (id: number, data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkPartialUpdate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkUpdate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesCreate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesList: async (id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesPartialUpdate: async (id: number, data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesRead', 'id', id)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesUpdate: async (id: number, data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkPartialUpdate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkUpdate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysCreate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysCreate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysDelete', 'id', id)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysPartialUpdate: async (id: number, data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysRead', 'id', id)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysUpdate: async (id: number, data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkPartialUpdate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkUpdate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesCreate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesCreate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesDelete', 'id', id)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesList: async (id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (vmRole !== undefined) {
                localVarQueryParameter['vm_role'] = vmRole;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (colorIc !== undefined) {
                localVarQueryParameter['color__ic'] = colorIc;
            }

            if (colorNic !== undefined) {
                localVarQueryParameter['color__nic'] = colorNic;
            }

            if (colorIew !== undefined) {
                localVarQueryParameter['color__iew'] = colorIew;
            }

            if (colorNiew !== undefined) {
                localVarQueryParameter['color__niew'] = colorNiew;
            }

            if (colorIsw !== undefined) {
                localVarQueryParameter['color__isw'] = colorIsw;
            }

            if (colorNisw !== undefined) {
                localVarQueryParameter['color__nisw'] = colorNisw;
            }

            if (colorIe !== undefined) {
                localVarQueryParameter['color__ie'] = colorIe;
            }

            if (colorNie !== undefined) {
                localVarQueryParameter['color__nie'] = colorNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesPartialUpdate: async (id: number, data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesRead', 'id', id)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesUpdate: async (id: number, data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkPartialUpdate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkUpdate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesCreate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesCreate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesDelete', 'id', id)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesList: async (id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (partNumber !== undefined) {
                localVarQueryParameter['part_number'] = partNumber;
            }

            if (uHeight !== undefined) {
                localVarQueryParameter['u_height'] = uHeight;
            }

            if (isFullDepth !== undefined) {
                localVarQueryParameter['is_full_depth'] = isFullDepth;
            }

            if (subdeviceRole !== undefined) {
                localVarQueryParameter['subdevice_role'] = subdeviceRole;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (consolePorts !== undefined) {
                localVarQueryParameter['console_ports'] = consolePorts;
            }

            if (consoleServerPorts !== undefined) {
                localVarQueryParameter['console_server_ports'] = consoleServerPorts;
            }

            if (powerPorts !== undefined) {
                localVarQueryParameter['power_ports'] = powerPorts;
            }

            if (powerOutlets !== undefined) {
                localVarQueryParameter['power_outlets'] = powerOutlets;
            }

            if (interfaces !== undefined) {
                localVarQueryParameter['interfaces'] = interfaces;
            }

            if (passThroughPorts !== undefined) {
                localVarQueryParameter['pass_through_ports'] = passThroughPorts;
            }

            if (deviceBays !== undefined) {
                localVarQueryParameter['device_bays'] = deviceBays;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (modelN !== undefined) {
                localVarQueryParameter['model__n'] = modelN;
            }

            if (modelIc !== undefined) {
                localVarQueryParameter['model__ic'] = modelIc;
            }

            if (modelNic !== undefined) {
                localVarQueryParameter['model__nic'] = modelNic;
            }

            if (modelIew !== undefined) {
                localVarQueryParameter['model__iew'] = modelIew;
            }

            if (modelNiew !== undefined) {
                localVarQueryParameter['model__niew'] = modelNiew;
            }

            if (modelIsw !== undefined) {
                localVarQueryParameter['model__isw'] = modelIsw;
            }

            if (modelNisw !== undefined) {
                localVarQueryParameter['model__nisw'] = modelNisw;
            }

            if (modelIe !== undefined) {
                localVarQueryParameter['model__ie'] = modelIe;
            }

            if (modelNie !== undefined) {
                localVarQueryParameter['model__nie'] = modelNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (partNumberN !== undefined) {
                localVarQueryParameter['part_number__n'] = partNumberN;
            }

            if (partNumberIc !== undefined) {
                localVarQueryParameter['part_number__ic'] = partNumberIc;
            }

            if (partNumberNic !== undefined) {
                localVarQueryParameter['part_number__nic'] = partNumberNic;
            }

            if (partNumberIew !== undefined) {
                localVarQueryParameter['part_number__iew'] = partNumberIew;
            }

            if (partNumberNiew !== undefined) {
                localVarQueryParameter['part_number__niew'] = partNumberNiew;
            }

            if (partNumberIsw !== undefined) {
                localVarQueryParameter['part_number__isw'] = partNumberIsw;
            }

            if (partNumberNisw !== undefined) {
                localVarQueryParameter['part_number__nisw'] = partNumberNisw;
            }

            if (partNumberIe !== undefined) {
                localVarQueryParameter['part_number__ie'] = partNumberIe;
            }

            if (partNumberNie !== undefined) {
                localVarQueryParameter['part_number__nie'] = partNumberNie;
            }

            if (uHeightN !== undefined) {
                localVarQueryParameter['u_height__n'] = uHeightN;
            }

            if (uHeightLte !== undefined) {
                localVarQueryParameter['u_height__lte'] = uHeightLte;
            }

            if (uHeightLt !== undefined) {
                localVarQueryParameter['u_height__lt'] = uHeightLt;
            }

            if (uHeightGte !== undefined) {
                localVarQueryParameter['u_height__gte'] = uHeightGte;
            }

            if (uHeightGt !== undefined) {
                localVarQueryParameter['u_height__gt'] = uHeightGt;
            }

            if (subdeviceRoleN !== undefined) {
                localVarQueryParameter['subdevice_role__n'] = subdeviceRoleN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesPartialUpdate: async (id: number, data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesRead', 'id', id)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesUpdate: async (id: number, data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkPartialUpdate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkUpdate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesCreate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesCreate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesDelete', 'id', id)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesList: async (id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }

            if (vcPosition !== undefined) {
                localVarQueryParameter['vc_position'] = vcPosition;
            }

            if (vcPriority !== undefined) {
                localVarQueryParameter['vc_priority'] = vcPriority;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (localContextData !== undefined) {
                localVarQueryParameter['local_context_data'] = localContextData;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (deviceTypeId !== undefined) {
                localVarQueryParameter['device_type_id'] = deviceTypeId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (platformId !== undefined) {
                localVarQueryParameter['platform_id'] = platformId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (rackGroupId !== undefined) {
                localVarQueryParameter['rack_group_id'] = rackGroupId;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isFullDepth !== undefined) {
                localVarQueryParameter['is_full_depth'] = isFullDepth;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (hasPrimaryIp !== undefined) {
                localVarQueryParameter['has_primary_ip'] = hasPrimaryIp;
            }

            if (virtualChassisId !== undefined) {
                localVarQueryParameter['virtual_chassis_id'] = virtualChassisId;
            }

            if (virtualChassisMember !== undefined) {
                localVarQueryParameter['virtual_chassis_member'] = virtualChassisMember;
            }

            if (consolePorts !== undefined) {
                localVarQueryParameter['console_ports'] = consolePorts;
            }

            if (consoleServerPorts !== undefined) {
                localVarQueryParameter['console_server_ports'] = consoleServerPorts;
            }

            if (powerPorts !== undefined) {
                localVarQueryParameter['power_ports'] = powerPorts;
            }

            if (powerOutlets !== undefined) {
                localVarQueryParameter['power_outlets'] = powerOutlets;
            }

            if (interfaces !== undefined) {
                localVarQueryParameter['interfaces'] = interfaces;
            }

            if (passThroughPorts !== undefined) {
                localVarQueryParameter['pass_through_ports'] = passThroughPorts;
            }

            if (deviceBays !== undefined) {
                localVarQueryParameter['device_bays'] = deviceBays;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (faceN !== undefined) {
                localVarQueryParameter['face__n'] = faceN;
            }

            if (positionN !== undefined) {
                localVarQueryParameter['position__n'] = positionN;
            }

            if (positionLte !== undefined) {
                localVarQueryParameter['position__lte'] = positionLte;
            }

            if (positionLt !== undefined) {
                localVarQueryParameter['position__lt'] = positionLt;
            }

            if (positionGte !== undefined) {
                localVarQueryParameter['position__gte'] = positionGte;
            }

            if (positionGt !== undefined) {
                localVarQueryParameter['position__gt'] = positionGt;
            }

            if (vcPositionN !== undefined) {
                localVarQueryParameter['vc_position__n'] = vcPositionN;
            }

            if (vcPositionLte !== undefined) {
                localVarQueryParameter['vc_position__lte'] = vcPositionLte;
            }

            if (vcPositionLt !== undefined) {
                localVarQueryParameter['vc_position__lt'] = vcPositionLt;
            }

            if (vcPositionGte !== undefined) {
                localVarQueryParameter['vc_position__gte'] = vcPositionGte;
            }

            if (vcPositionGt !== undefined) {
                localVarQueryParameter['vc_position__gt'] = vcPositionGt;
            }

            if (vcPriorityN !== undefined) {
                localVarQueryParameter['vc_priority__n'] = vcPriorityN;
            }

            if (vcPriorityLte !== undefined) {
                localVarQueryParameter['vc_priority__lte'] = vcPriorityLte;
            }

            if (vcPriorityLt !== undefined) {
                localVarQueryParameter['vc_priority__lt'] = vcPriorityLt;
            }

            if (vcPriorityGte !== undefined) {
                localVarQueryParameter['vc_priority__gte'] = vcPriorityGte;
            }

            if (vcPriorityGt !== undefined) {
                localVarQueryParameter['vc_priority__gt'] = vcPriorityGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (deviceTypeIdN !== undefined) {
                localVarQueryParameter['device_type_id__n'] = deviceTypeIdN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (platformIdN !== undefined) {
                localVarQueryParameter['platform_id__n'] = platformIdN;
            }

            if (platformN !== undefined) {
                localVarQueryParameter['platform__n'] = platformN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (rackGroupIdN !== undefined) {
                localVarQueryParameter['rack_group_id__n'] = rackGroupIdN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (modelN !== undefined) {
                localVarQueryParameter['model__n'] = modelN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (virtualChassisIdN !== undefined) {
                localVarQueryParameter['virtual_chassis_id__n'] = virtualChassisIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesNapalm: async (id: number, method: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesNapalm', 'id', id)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('dcimDevicesNapalm', 'method', method)
            const localVarPath = `/dcim/devices/{id}/napalm/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesPartialUpdate: async (id: number, data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesRead', 'id', id)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesUpdate: async (id: number, data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesUpdate', 'data', data)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkPartialUpdate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkUpdate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesCreate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesPartialUpdate: async (id: number, data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesUpdate: async (id: number, data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkPartialUpdate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkUpdate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsCreate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsCreate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsDelete', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsList: async (id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPartialUpdate: async (id: number, data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPaths: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsPaths', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/paths/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsRead', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsUpdate: async (id: number, data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceConnectionsList: async (site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkPartialUpdate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkUpdate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesCreate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesList: async (id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mgmtOnly !== undefined) {
                localVarQueryParameter['mgmt_only'] = mgmtOnly;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesPartialUpdate: async (id: number, data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesRead', 'id', id)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesUpdate: async (id: number, data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkPartialUpdate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkUpdate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesCreate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesCreate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesDelete', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesList: async (id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (mtu !== undefined) {
                localVarQueryParameter['mtu'] = mtu;
            }

            if (mgmtOnly !== undefined) {
                localVarQueryParameter['mgmt_only'] = mgmtOnly;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (lagId !== undefined) {
                localVarQueryParameter['lag_id'] = lagId;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (vlanId !== undefined) {
                localVarQueryParameter['vlan_id'] = vlanId;
            }

            if (vlan !== undefined) {
                localVarQueryParameter['vlan'] = vlan;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (mtuN !== undefined) {
                localVarQueryParameter['mtu__n'] = mtuN;
            }

            if (mtuLte !== undefined) {
                localVarQueryParameter['mtu__lte'] = mtuLte;
            }

            if (mtuLt !== undefined) {
                localVarQueryParameter['mtu__lt'] = mtuLt;
            }

            if (mtuGte !== undefined) {
                localVarQueryParameter['mtu__gte'] = mtuGte;
            }

            if (mtuGt !== undefined) {
                localVarQueryParameter['mtu__gt'] = mtuGt;
            }

            if (modeN !== undefined) {
                localVarQueryParameter['mode__n'] = modeN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (lagIdN !== undefined) {
                localVarQueryParameter['lag_id__n'] = lagIdN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesPartialUpdate: async (id: number, data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesRead', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesTrace', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesUpdate: async (id: number, data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkPartialUpdate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkUpdate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsCreate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsCreate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsDelete', 'id', id)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsList: async (id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (partId !== undefined) {
                localVarQueryParameter['part_id'] = partId;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (discovered !== undefined) {
                localVarQueryParameter['discovered'] = discovered;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (partIdN !== undefined) {
                localVarQueryParameter['part_id__n'] = partIdN;
            }

            if (partIdIc !== undefined) {
                localVarQueryParameter['part_id__ic'] = partIdIc;
            }

            if (partIdNic !== undefined) {
                localVarQueryParameter['part_id__nic'] = partIdNic;
            }

            if (partIdIew !== undefined) {
                localVarQueryParameter['part_id__iew'] = partIdIew;
            }

            if (partIdNiew !== undefined) {
                localVarQueryParameter['part_id__niew'] = partIdNiew;
            }

            if (partIdIsw !== undefined) {
                localVarQueryParameter['part_id__isw'] = partIdIsw;
            }

            if (partIdNisw !== undefined) {
                localVarQueryParameter['part_id__nisw'] = partIdNisw;
            }

            if (partIdIe !== undefined) {
                localVarQueryParameter['part_id__ie'] = partIdIe;
            }

            if (partIdNie !== undefined) {
                localVarQueryParameter['part_id__nie'] = partIdNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsPartialUpdate: async (id: number, data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsRead', 'id', id)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsUpdate: async (id: number, data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkPartialUpdate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkUpdate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersBulkUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersCreate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersCreate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersDelete', 'id', id)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersPartialUpdate: async (id: number, data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersPartialUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersRead', 'id', id)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersUpdate: async (id: number, data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkPartialUpdate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkUpdate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsCreate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsCreate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsDelete', 'id', id)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsList: async (id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (napalmDriver !== undefined) {
                localVarQueryParameter['napalm_driver'] = napalmDriver;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (napalmDriverN !== undefined) {
                localVarQueryParameter['napalm_driver__n'] = napalmDriverN;
            }

            if (napalmDriverIc !== undefined) {
                localVarQueryParameter['napalm_driver__ic'] = napalmDriverIc;
            }

            if (napalmDriverNic !== undefined) {
                localVarQueryParameter['napalm_driver__nic'] = napalmDriverNic;
            }

            if (napalmDriverIew !== undefined) {
                localVarQueryParameter['napalm_driver__iew'] = napalmDriverIew;
            }

            if (napalmDriverNiew !== undefined) {
                localVarQueryParameter['napalm_driver__niew'] = napalmDriverNiew;
            }

            if (napalmDriverIsw !== undefined) {
                localVarQueryParameter['napalm_driver__isw'] = napalmDriverIsw;
            }

            if (napalmDriverNisw !== undefined) {
                localVarQueryParameter['napalm_driver__nisw'] = napalmDriverNisw;
            }

            if (napalmDriverIe !== undefined) {
                localVarQueryParameter['napalm_driver__ie'] = napalmDriverIe;
            }

            if (napalmDriverNie !== undefined) {
                localVarQueryParameter['napalm_driver__nie'] = napalmDriverNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsPartialUpdate: async (id: number, data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsRead', 'id', id)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsUpdate: async (id: number, data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerConnectionsList: async (name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkPartialUpdate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkUpdate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsCreate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsCreate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsDelete', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsList: async (id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (supply !== undefined) {
                localVarQueryParameter['supply'] = supply;
            }

            if (phase !== undefined) {
                localVarQueryParameter['phase'] = phase;
            }

            if (voltage !== undefined) {
                localVarQueryParameter['voltage'] = voltage;
            }

            if (amperage !== undefined) {
                localVarQueryParameter['amperage'] = amperage;
            }

            if (maxUtilization !== undefined) {
                localVarQueryParameter['max_utilization'] = maxUtilization;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (powerPanelId !== undefined) {
                localVarQueryParameter['power_panel_id'] = powerPanelId;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (supplyN !== undefined) {
                localVarQueryParameter['supply__n'] = supplyN;
            }

            if (phaseN !== undefined) {
                localVarQueryParameter['phase__n'] = phaseN;
            }

            if (voltageN !== undefined) {
                localVarQueryParameter['voltage__n'] = voltageN;
            }

            if (voltageLte !== undefined) {
                localVarQueryParameter['voltage__lte'] = voltageLte;
            }

            if (voltageLt !== undefined) {
                localVarQueryParameter['voltage__lt'] = voltageLt;
            }

            if (voltageGte !== undefined) {
                localVarQueryParameter['voltage__gte'] = voltageGte;
            }

            if (voltageGt !== undefined) {
                localVarQueryParameter['voltage__gt'] = voltageGt;
            }

            if (amperageN !== undefined) {
                localVarQueryParameter['amperage__n'] = amperageN;
            }

            if (amperageLte !== undefined) {
                localVarQueryParameter['amperage__lte'] = amperageLte;
            }

            if (amperageLt !== undefined) {
                localVarQueryParameter['amperage__lt'] = amperageLt;
            }

            if (amperageGte !== undefined) {
                localVarQueryParameter['amperage__gte'] = amperageGte;
            }

            if (amperageGt !== undefined) {
                localVarQueryParameter['amperage__gt'] = amperageGt;
            }

            if (maxUtilizationN !== undefined) {
                localVarQueryParameter['max_utilization__n'] = maxUtilizationN;
            }

            if (maxUtilizationLte !== undefined) {
                localVarQueryParameter['max_utilization__lte'] = maxUtilizationLte;
            }

            if (maxUtilizationLt !== undefined) {
                localVarQueryParameter['max_utilization__lt'] = maxUtilizationLt;
            }

            if (maxUtilizationGte !== undefined) {
                localVarQueryParameter['max_utilization__gte'] = maxUtilizationGte;
            }

            if (maxUtilizationGt !== undefined) {
                localVarQueryParameter['max_utilization__gt'] = maxUtilizationGt;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (powerPanelIdN !== undefined) {
                localVarQueryParameter['power_panel_id__n'] = powerPanelIdN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsPartialUpdate: async (id: number, data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsRead', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsTrace', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsUpdate: async (id: number, data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkPartialUpdate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkUpdate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesCreate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesList: async (id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (feedLeg !== undefined) {
                localVarQueryParameter['feed_leg'] = feedLeg;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (feedLegN !== undefined) {
                localVarQueryParameter['feed_leg__n'] = feedLegN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesPartialUpdate: async (id: number, data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesRead', 'id', id)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesUpdate: async (id: number, data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkPartialUpdate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkUpdate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsCreate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsCreate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsDelete', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsList: async (id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (feedLeg !== undefined) {
                localVarQueryParameter['feed_leg'] = feedLeg;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (feedLegN !== undefined) {
                localVarQueryParameter['feed_leg__n'] = feedLegN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsPartialUpdate: async (id: number, data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsRead', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsTrace', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsUpdate: async (id: number, data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkPartialUpdate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkUpdate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsCreate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsCreate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsDelete', 'id', id)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsList: async (id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (rackGroupId !== undefined) {
                localVarQueryParameter['rack_group_id'] = rackGroupId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (rackGroupIdN !== undefined) {
                localVarQueryParameter['rack_group_id__n'] = rackGroupIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsPartialUpdate: async (id: number, data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsRead', 'id', id)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsUpdate: async (id: number, data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkPartialUpdate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkUpdate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesCreate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesList: async (id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (maximumDraw !== undefined) {
                localVarQueryParameter['maximum_draw'] = maximumDraw;
            }

            if (allocatedDraw !== undefined) {
                localVarQueryParameter['allocated_draw'] = allocatedDraw;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (maximumDrawN !== undefined) {
                localVarQueryParameter['maximum_draw__n'] = maximumDrawN;
            }

            if (maximumDrawLte !== undefined) {
                localVarQueryParameter['maximum_draw__lte'] = maximumDrawLte;
            }

            if (maximumDrawLt !== undefined) {
                localVarQueryParameter['maximum_draw__lt'] = maximumDrawLt;
            }

            if (maximumDrawGte !== undefined) {
                localVarQueryParameter['maximum_draw__gte'] = maximumDrawGte;
            }

            if (maximumDrawGt !== undefined) {
                localVarQueryParameter['maximum_draw__gt'] = maximumDrawGt;
            }

            if (allocatedDrawN !== undefined) {
                localVarQueryParameter['allocated_draw__n'] = allocatedDrawN;
            }

            if (allocatedDrawLte !== undefined) {
                localVarQueryParameter['allocated_draw__lte'] = allocatedDrawLte;
            }

            if (allocatedDrawLt !== undefined) {
                localVarQueryParameter['allocated_draw__lt'] = allocatedDrawLt;
            }

            if (allocatedDrawGte !== undefined) {
                localVarQueryParameter['allocated_draw__gte'] = allocatedDrawGte;
            }

            if (allocatedDrawGt !== undefined) {
                localVarQueryParameter['allocated_draw__gt'] = allocatedDrawGt;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesPartialUpdate: async (id: number, data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesUpdate: async (id: number, data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkPartialUpdate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkUpdate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsCreate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsCreate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsDelete', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsList: async (id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (maximumDraw !== undefined) {
                localVarQueryParameter['maximum_draw'] = maximumDraw;
            }

            if (allocatedDraw !== undefined) {
                localVarQueryParameter['allocated_draw'] = allocatedDraw;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (maximumDrawN !== undefined) {
                localVarQueryParameter['maximum_draw__n'] = maximumDrawN;
            }

            if (maximumDrawLte !== undefined) {
                localVarQueryParameter['maximum_draw__lte'] = maximumDrawLte;
            }

            if (maximumDrawLt !== undefined) {
                localVarQueryParameter['maximum_draw__lt'] = maximumDrawLt;
            }

            if (maximumDrawGte !== undefined) {
                localVarQueryParameter['maximum_draw__gte'] = maximumDrawGte;
            }

            if (maximumDrawGt !== undefined) {
                localVarQueryParameter['maximum_draw__gt'] = maximumDrawGt;
            }

            if (allocatedDrawN !== undefined) {
                localVarQueryParameter['allocated_draw__n'] = allocatedDrawN;
            }

            if (allocatedDrawLte !== undefined) {
                localVarQueryParameter['allocated_draw__lte'] = allocatedDrawLte;
            }

            if (allocatedDrawLt !== undefined) {
                localVarQueryParameter['allocated_draw__lt'] = allocatedDrawLt;
            }

            if (allocatedDrawGte !== undefined) {
                localVarQueryParameter['allocated_draw__gte'] = allocatedDrawGte;
            }

            if (allocatedDrawGt !== undefined) {
                localVarQueryParameter['allocated_draw__gt'] = allocatedDrawGt;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsPartialUpdate: async (id: number, data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsRead', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsTrace', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsUpdate: async (id: number, data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkPartialUpdate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkUpdate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsCreate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsCreate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsDelete', 'id', id)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (parentN !== undefined) {
                localVarQueryParameter['parent__n'] = parentN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsPartialUpdate: async (id: number, data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsRead', 'id', id)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsUpdate: async (id: number, data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkPartialUpdate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkUpdate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsCreate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsCreate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsDelete', 'id', id)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsList: async (id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (createdN !== undefined) {
                localVarQueryParameter['created__n'] = createdN;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (createdLt !== undefined) {
                localVarQueryParameter['created__lt'] = createdLt;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdGt !== undefined) {
                localVarQueryParameter['created__gt'] = createdGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (userIdN !== undefined) {
                localVarQueryParameter['user_id__n'] = userIdN;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsPartialUpdate: async (id: number, data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsRead', 'id', id)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsUpdate: async (id: number, data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkPartialUpdate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkUpdate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesCreate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesCreate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesDelete', 'id', id)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesList: async (id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (colorIc !== undefined) {
                localVarQueryParameter['color__ic'] = colorIc;
            }

            if (colorNic !== undefined) {
                localVarQueryParameter['color__nic'] = colorNic;
            }

            if (colorIew !== undefined) {
                localVarQueryParameter['color__iew'] = colorIew;
            }

            if (colorNiew !== undefined) {
                localVarQueryParameter['color__niew'] = colorNiew;
            }

            if (colorIsw !== undefined) {
                localVarQueryParameter['color__isw'] = colorIsw;
            }

            if (colorNisw !== undefined) {
                localVarQueryParameter['color__nisw'] = colorNisw;
            }

            if (colorIe !== undefined) {
                localVarQueryParameter['color__ie'] = colorIe;
            }

            if (colorNie !== undefined) {
                localVarQueryParameter['color__nie'] = colorNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesPartialUpdate: async (id: number, data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesRead', 'id', id)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesUpdate: async (id: number, data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkPartialUpdate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkUpdate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksBulkUpdate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksCreate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksCreate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksDelete', 'id', id)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksElevationRead: async (id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksElevationRead', 'id', id)
            const localVarPath = `/dcim/racks/{id}/elevation/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            if (render !== undefined) {
                localVarQueryParameter['render'] = render;
            }

            if (unitWidth !== undefined) {
                localVarQueryParameter['unit_width'] = unitWidth;
            }

            if (unitHeight !== undefined) {
                localVarQueryParameter['unit_height'] = unitHeight;
            }

            if (legendWidth !== undefined) {
                localVarQueryParameter['legend_width'] = legendWidth;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (expandDevices !== undefined) {
                localVarQueryParameter['expand_devices'] = expandDevices;
            }

            if (includeImages !== undefined) {
                localVarQueryParameter['include_images'] = includeImages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksList: async (id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (facilityId !== undefined) {
                localVarQueryParameter['facility_id'] = facilityId;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (uHeight !== undefined) {
                localVarQueryParameter['u_height'] = uHeight;
            }

            if (descUnits !== undefined) {
                localVarQueryParameter['desc_units'] = descUnits;
            }

            if (outerWidth !== undefined) {
                localVarQueryParameter['outer_width'] = outerWidth;
            }

            if (outerDepth !== undefined) {
                localVarQueryParameter['outer_depth'] = outerDepth;
            }

            if (outerUnit !== undefined) {
                localVarQueryParameter['outer_unit'] = outerUnit;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (facilityIdN !== undefined) {
                localVarQueryParameter['facility_id__n'] = facilityIdN;
            }

            if (facilityIdIc !== undefined) {
                localVarQueryParameter['facility_id__ic'] = facilityIdIc;
            }

            if (facilityIdNic !== undefined) {
                localVarQueryParameter['facility_id__nic'] = facilityIdNic;
            }

            if (facilityIdIew !== undefined) {
                localVarQueryParameter['facility_id__iew'] = facilityIdIew;
            }

            if (facilityIdNiew !== undefined) {
                localVarQueryParameter['facility_id__niew'] = facilityIdNiew;
            }

            if (facilityIdIsw !== undefined) {
                localVarQueryParameter['facility_id__isw'] = facilityIdIsw;
            }

            if (facilityIdNisw !== undefined) {
                localVarQueryParameter['facility_id__nisw'] = facilityIdNisw;
            }

            if (facilityIdIe !== undefined) {
                localVarQueryParameter['facility_id__ie'] = facilityIdIe;
            }

            if (facilityIdNie !== undefined) {
                localVarQueryParameter['facility_id__nie'] = facilityIdNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (widthN !== undefined) {
                localVarQueryParameter['width__n'] = widthN;
            }

            if (uHeightN !== undefined) {
                localVarQueryParameter['u_height__n'] = uHeightN;
            }

            if (uHeightLte !== undefined) {
                localVarQueryParameter['u_height__lte'] = uHeightLte;
            }

            if (uHeightLt !== undefined) {
                localVarQueryParameter['u_height__lt'] = uHeightLt;
            }

            if (uHeightGte !== undefined) {
                localVarQueryParameter['u_height__gte'] = uHeightGte;
            }

            if (uHeightGt !== undefined) {
                localVarQueryParameter['u_height__gt'] = uHeightGt;
            }

            if (outerWidthN !== undefined) {
                localVarQueryParameter['outer_width__n'] = outerWidthN;
            }

            if (outerWidthLte !== undefined) {
                localVarQueryParameter['outer_width__lte'] = outerWidthLte;
            }

            if (outerWidthLt !== undefined) {
                localVarQueryParameter['outer_width__lt'] = outerWidthLt;
            }

            if (outerWidthGte !== undefined) {
                localVarQueryParameter['outer_width__gte'] = outerWidthGte;
            }

            if (outerWidthGt !== undefined) {
                localVarQueryParameter['outer_width__gt'] = outerWidthGt;
            }

            if (outerDepthN !== undefined) {
                localVarQueryParameter['outer_depth__n'] = outerDepthN;
            }

            if (outerDepthLte !== undefined) {
                localVarQueryParameter['outer_depth__lte'] = outerDepthLte;
            }

            if (outerDepthLt !== undefined) {
                localVarQueryParameter['outer_depth__lt'] = outerDepthLt;
            }

            if (outerDepthGte !== undefined) {
                localVarQueryParameter['outer_depth__gte'] = outerDepthGte;
            }

            if (outerDepthGt !== undefined) {
                localVarQueryParameter['outer_depth__gt'] = outerDepthGt;
            }

            if (outerUnitN !== undefined) {
                localVarQueryParameter['outer_unit__n'] = outerUnitN;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksPartialUpdate: async (id: number, data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksPartialUpdate', 'data', data)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksRead', 'id', id)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksUpdate: async (id: number, data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksUpdate', 'data', data)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkPartialUpdate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkUpdate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesCreate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesList: async (id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (positions !== undefined) {
                localVarQueryParameter['positions'] = positions;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (positionsN !== undefined) {
                localVarQueryParameter['positions__n'] = positionsN;
            }

            if (positionsLte !== undefined) {
                localVarQueryParameter['positions__lte'] = positionsLte;
            }

            if (positionsLt !== undefined) {
                localVarQueryParameter['positions__lt'] = positionsLt;
            }

            if (positionsGte !== undefined) {
                localVarQueryParameter['positions__gte'] = positionsGte;
            }

            if (positionsGt !== undefined) {
                localVarQueryParameter['positions__gt'] = positionsGt;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesPartialUpdate: async (id: number, data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesUpdate: async (id: number, data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkPartialUpdate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkUpdate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsCreate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsCreate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsDelete', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsList: async (id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (positions !== undefined) {
                localVarQueryParameter['positions'] = positions;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (positionsN !== undefined) {
                localVarQueryParameter['positions__n'] = positionsN;
            }

            if (positionsLte !== undefined) {
                localVarQueryParameter['positions__lte'] = positionsLte;
            }

            if (positionsLt !== undefined) {
                localVarQueryParameter['positions__lt'] = positionsLt;
            }

            if (positionsGte !== undefined) {
                localVarQueryParameter['positions__gte'] = positionsGte;
            }

            if (positionsGt !== undefined) {
                localVarQueryParameter['positions__gt'] = positionsGt;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPartialUpdate: async (id: number, data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPaths: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsPaths', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/paths/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsRead', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsUpdate: async (id: number, data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkPartialUpdate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkUpdate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsCreate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsCreate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsDelete', 'id', id)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (parentN !== undefined) {
                localVarQueryParameter['parent__n'] = parentN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsPartialUpdate: async (id: number, data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsRead', 'id', id)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsUpdate: async (id: number, data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsUpdate', 'data', data)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkPartialUpdate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkUpdate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesCreate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesCreate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesDelete', 'id', id)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesList: async (id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (facility !== undefined) {
                localVarQueryParameter['facility'] = facility;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (contactName !== undefined) {
                localVarQueryParameter['contact_name'] = contactName;
            }

            if (contactPhone !== undefined) {
                localVarQueryParameter['contact_phone'] = contactPhone;
            }

            if (contactEmail !== undefined) {
                localVarQueryParameter['contact_email'] = contactEmail;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (facilityN !== undefined) {
                localVarQueryParameter['facility__n'] = facilityN;
            }

            if (facilityIc !== undefined) {
                localVarQueryParameter['facility__ic'] = facilityIc;
            }

            if (facilityNic !== undefined) {
                localVarQueryParameter['facility__nic'] = facilityNic;
            }

            if (facilityIew !== undefined) {
                localVarQueryParameter['facility__iew'] = facilityIew;
            }

            if (facilityNiew !== undefined) {
                localVarQueryParameter['facility__niew'] = facilityNiew;
            }

            if (facilityIsw !== undefined) {
                localVarQueryParameter['facility__isw'] = facilityIsw;
            }

            if (facilityNisw !== undefined) {
                localVarQueryParameter['facility__nisw'] = facilityNisw;
            }

            if (facilityIe !== undefined) {
                localVarQueryParameter['facility__ie'] = facilityIe;
            }

            if (facilityNie !== undefined) {
                localVarQueryParameter['facility__nie'] = facilityNie;
            }

            if (asnN !== undefined) {
                localVarQueryParameter['asn__n'] = asnN;
            }

            if (asnLte !== undefined) {
                localVarQueryParameter['asn__lte'] = asnLte;
            }

            if (asnLt !== undefined) {
                localVarQueryParameter['asn__lt'] = asnLt;
            }

            if (asnGte !== undefined) {
                localVarQueryParameter['asn__gte'] = asnGte;
            }

            if (asnGt !== undefined) {
                localVarQueryParameter['asn__gt'] = asnGt;
            }

            if (latitudeN !== undefined) {
                localVarQueryParameter['latitude__n'] = latitudeN;
            }

            if (latitudeLte !== undefined) {
                localVarQueryParameter['latitude__lte'] = latitudeLte;
            }

            if (latitudeLt !== undefined) {
                localVarQueryParameter['latitude__lt'] = latitudeLt;
            }

            if (latitudeGte !== undefined) {
                localVarQueryParameter['latitude__gte'] = latitudeGte;
            }

            if (latitudeGt !== undefined) {
                localVarQueryParameter['latitude__gt'] = latitudeGt;
            }

            if (longitudeN !== undefined) {
                localVarQueryParameter['longitude__n'] = longitudeN;
            }

            if (longitudeLte !== undefined) {
                localVarQueryParameter['longitude__lte'] = longitudeLte;
            }

            if (longitudeLt !== undefined) {
                localVarQueryParameter['longitude__lt'] = longitudeLt;
            }

            if (longitudeGte !== undefined) {
                localVarQueryParameter['longitude__gte'] = longitudeGte;
            }

            if (longitudeGt !== undefined) {
                localVarQueryParameter['longitude__gt'] = longitudeGt;
            }

            if (contactNameN !== undefined) {
                localVarQueryParameter['contact_name__n'] = contactNameN;
            }

            if (contactNameIc !== undefined) {
                localVarQueryParameter['contact_name__ic'] = contactNameIc;
            }

            if (contactNameNic !== undefined) {
                localVarQueryParameter['contact_name__nic'] = contactNameNic;
            }

            if (contactNameIew !== undefined) {
                localVarQueryParameter['contact_name__iew'] = contactNameIew;
            }

            if (contactNameNiew !== undefined) {
                localVarQueryParameter['contact_name__niew'] = contactNameNiew;
            }

            if (contactNameIsw !== undefined) {
                localVarQueryParameter['contact_name__isw'] = contactNameIsw;
            }

            if (contactNameNisw !== undefined) {
                localVarQueryParameter['contact_name__nisw'] = contactNameNisw;
            }

            if (contactNameIe !== undefined) {
                localVarQueryParameter['contact_name__ie'] = contactNameIe;
            }

            if (contactNameNie !== undefined) {
                localVarQueryParameter['contact_name__nie'] = contactNameNie;
            }

            if (contactPhoneN !== undefined) {
                localVarQueryParameter['contact_phone__n'] = contactPhoneN;
            }

            if (contactPhoneIc !== undefined) {
                localVarQueryParameter['contact_phone__ic'] = contactPhoneIc;
            }

            if (contactPhoneNic !== undefined) {
                localVarQueryParameter['contact_phone__nic'] = contactPhoneNic;
            }

            if (contactPhoneIew !== undefined) {
                localVarQueryParameter['contact_phone__iew'] = contactPhoneIew;
            }

            if (contactPhoneNiew !== undefined) {
                localVarQueryParameter['contact_phone__niew'] = contactPhoneNiew;
            }

            if (contactPhoneIsw !== undefined) {
                localVarQueryParameter['contact_phone__isw'] = contactPhoneIsw;
            }

            if (contactPhoneNisw !== undefined) {
                localVarQueryParameter['contact_phone__nisw'] = contactPhoneNisw;
            }

            if (contactPhoneIe !== undefined) {
                localVarQueryParameter['contact_phone__ie'] = contactPhoneIe;
            }

            if (contactPhoneNie !== undefined) {
                localVarQueryParameter['contact_phone__nie'] = contactPhoneNie;
            }

            if (contactEmailN !== undefined) {
                localVarQueryParameter['contact_email__n'] = contactEmailN;
            }

            if (contactEmailIc !== undefined) {
                localVarQueryParameter['contact_email__ic'] = contactEmailIc;
            }

            if (contactEmailNic !== undefined) {
                localVarQueryParameter['contact_email__nic'] = contactEmailNic;
            }

            if (contactEmailIew !== undefined) {
                localVarQueryParameter['contact_email__iew'] = contactEmailIew;
            }

            if (contactEmailNiew !== undefined) {
                localVarQueryParameter['contact_email__niew'] = contactEmailNiew;
            }

            if (contactEmailIsw !== undefined) {
                localVarQueryParameter['contact_email__isw'] = contactEmailIsw;
            }

            if (contactEmailNisw !== undefined) {
                localVarQueryParameter['contact_email__nisw'] = contactEmailNisw;
            }

            if (contactEmailIe !== undefined) {
                localVarQueryParameter['contact_email__ie'] = contactEmailIe;
            }

            if (contactEmailNie !== undefined) {
                localVarQueryParameter['contact_email__nie'] = contactEmailNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesPartialUpdate: async (id: number, data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesRead', 'id', id)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesUpdate: async (id: number, data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesUpdate', 'data', data)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkPartialUpdate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkUpdate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisBulkUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisCreate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisCreate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisDelete', 'id', id)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisList: async (id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (domainN !== undefined) {
                localVarQueryParameter['domain__n'] = domainN;
            }

            if (domainIc !== undefined) {
                localVarQueryParameter['domain__ic'] = domainIc;
            }

            if (domainNic !== undefined) {
                localVarQueryParameter['domain__nic'] = domainNic;
            }

            if (domainIew !== undefined) {
                localVarQueryParameter['domain__iew'] = domainIew;
            }

            if (domainNiew !== undefined) {
                localVarQueryParameter['domain__niew'] = domainNiew;
            }

            if (domainIsw !== undefined) {
                localVarQueryParameter['domain__isw'] = domainIsw;
            }

            if (domainNisw !== undefined) {
                localVarQueryParameter['domain__nisw'] = domainNisw;
            }

            if (domainIe !== undefined) {
                localVarQueryParameter['domain__ie'] = domainIe;
            }

            if (domainNie !== undefined) {
                localVarQueryParameter['domain__nie'] = domainNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisPartialUpdate: async (id: number, data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisPartialUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisRead', 'id', id)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisUpdate: async (id: number, data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DcimApi - functional programming interface
 * @export
 */
export const DcimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DcimApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkPartialUpdate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkUpdate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesCreate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesList(id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesList(id, label, length, lengthUnit, q, type, status, color, deviceId, device, rackId, rack, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, labelN, labelIc, labelNic, labelIew, labelNiew, labelIsw, labelNisw, labelIe, labelNie, lengthN, lengthLte, lengthLt, lengthGte, lengthGt, lengthUnitN, typeN, statusN, colorN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesPartialUpdate(id: number, data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesUpdate(id: number, data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConnectedDeviceList(peerDevice: string, peerInterface: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConnectedDeviceList(peerDevice, peerInterface, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkPartialUpdate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkUpdate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesCreate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesPartialUpdate(id: number, data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesUpdate(id: number, data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkPartialUpdate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkUpdate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsCreate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsPartialUpdate(id: number, data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsUpdate(id: number, data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkPartialUpdate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkUpdate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesCreate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesPartialUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkPartialUpdate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkUpdate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsCreate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsPartialUpdate(id: number, data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsUpdate(id: number, data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkPartialUpdate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkUpdate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesCreate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesList(id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesList(id, name, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesPartialUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkPartialUpdate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkUpdate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysCreate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysPartialUpdate(id: number, data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysUpdate(id: number, data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkPartialUpdate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkUpdate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesCreate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesList(id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesList(id, name, slug, color, vmRole, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesPartialUpdate(id: number, data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesUpdate(id: number, data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkPartialUpdate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkUpdate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesCreate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesList(id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesList(id, model, slug, partNumber, uHeight, isFullDepth, subdeviceRole, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, modelN, modelIc, modelNic, modelIew, modelNiew, modelIsw, modelNisw, modelIe, modelNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, partNumberN, partNumberIc, partNumberNic, partNumberIew, partNumberNiew, partNumberIsw, partNumberNisw, partNumberIe, partNumberNie, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, subdeviceRoleN, manufacturerIdN, manufacturerN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesPartialUpdate(id: number, data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesUpdate(id: number, data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkPartialUpdate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkUpdate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesCreate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesList(id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesList(id, name, assetTag, face, position, vcPosition, vcPriority, tenantGroupId, tenantGroup, tenantId, tenant, localContextData, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, deviceTypeId, roleId, role, platformId, platform, regionId, region, siteId, site, rackGroupId, rackId, clusterId, model, status, isFullDepth, macAddress, serial, hasPrimaryIp, virtualChassisId, virtualChassisMember, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, faceN, positionN, positionLte, positionLt, positionGte, positionGt, vcPositionN, vcPositionLte, vcPositionLt, vcPositionGte, vcPositionGt, vcPriorityN, vcPriorityLte, vcPriorityLt, vcPriorityGte, vcPriorityGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, manufacturerIdN, manufacturerN, deviceTypeIdN, roleIdN, roleN, platformIdN, platformN, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, rackIdN, clusterIdN, modelN, statusN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, virtualChassisIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesNapalm(id: number, method: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceNAPALM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesNapalm(id, method, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesPartialUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkPartialUpdate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkUpdate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesCreate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesPartialUpdate(id: number, data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesUpdate(id: number, data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkPartialUpdate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkUpdate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsCreate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsList(id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsList(id, name, type, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsPartialUpdate(id: number, data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsPaths(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsPaths(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsUpdate(id: number, data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceConnectionsList(site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceConnectionsList(site, deviceId, device, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkPartialUpdate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkUpdate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesCreate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesList(id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesList(id, name, type, mgmtOnly, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesPartialUpdate(id: number, data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesUpdate(id: number, data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkPartialUpdate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkUpdate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesCreate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesList(id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesList(id, name, type, enabled, mtu, mgmtOnly, mode, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, kind, lagId, macAddress, vlanId, vlan, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, modeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, tagN, lagIdN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesPartialUpdate(id: number, data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesUpdate(id: number, data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkPartialUpdate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkUpdate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsCreate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsList(id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsList(id, name, partId, assetTag, discovered, q, regionId, region, siteId, site, deviceId, device, tag, parentId, manufacturerId, manufacturer, serial, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, partIdN, partIdIc, partIdNic, partIdIew, partIdNiew, partIdIsw, partIdNisw, partIdIe, partIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, parentIdN, manufacturerIdN, manufacturerN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsPartialUpdate(id: number, data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsUpdate(id: number, data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkPartialUpdate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkUpdate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersCreate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersPartialUpdate(id: number, data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersUpdate(id: number, data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkPartialUpdate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkUpdate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsCreate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsList(id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsList(id, name, slug, napalmDriver, description, q, manufacturerId, manufacturer, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, napalmDriverN, napalmDriverIc, napalmDriverNic, napalmDriverIew, napalmDriverNiew, napalmDriverIsw, napalmDriverNisw, napalmDriverIe, napalmDriverNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, manufacturerIdN, manufacturerN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsPartialUpdate(id: number, data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsUpdate(id: number, data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkPartialUpdate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkUpdate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsCreate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsList(id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsList(id, name, status, type, supply, phase, voltage, amperage, maxUtilization, cabled, connected, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, powerPanelId, rackId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, statusN, typeN, supplyN, phaseN, voltageN, voltageLte, voltageLt, voltageGte, voltageGt, amperageN, amperageLte, amperageLt, amperageGte, amperageGt, maxUtilizationN, maxUtilizationLte, maxUtilizationLt, maxUtilizationGte, maxUtilizationGt, regionIdN, regionN, siteIdN, siteN, powerPanelIdN, rackIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsPartialUpdate(id: number, data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsUpdate(id: number, data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkPartialUpdate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkUpdate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesCreate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesList(id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesList(id, name, type, feedLeg, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, feedLegN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesPartialUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkPartialUpdate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkUpdate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsCreate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsList(id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsList(id, name, feedLeg, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, feedLegN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsPartialUpdate(id: number, data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsUpdate(id: number, data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkPartialUpdate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkUpdate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsCreate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsList(id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsList(id, name, q, regionId, region, siteId, site, rackGroupId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsPartialUpdate(id: number, data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsUpdate(id: number, data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkPartialUpdate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkUpdate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesCreate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesList(id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesList(id, name, type, maximumDraw, allocatedDraw, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesPartialUpdate(id: number, data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesUpdate(id: number, data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkPartialUpdate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkUpdate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsCreate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsList(id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsList(id, name, maximumDraw, allocatedDraw, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsPartialUpdate(id: number, data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsUpdate(id: number, data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkPartialUpdate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkUpdate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsCreate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsList(id, name, slug, description, q, regionId, region, siteId, site, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, parentIdN, parentN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsPartialUpdate(id: number, data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsUpdate(id: number, data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkPartialUpdate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkUpdate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsCreate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsList(id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsList(id, created, tenantGroupId, tenantGroup, tenantId, tenant, q, rackId, siteId, site, groupId, group, userId, user, tag, idN, idLte, idLt, idGte, idGt, createdN, createdLte, createdLt, createdGte, createdGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rackIdN, siteIdN, siteN, groupIdN, groupN, userIdN, userN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsPartialUpdate(id: number, data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsUpdate(id: number, data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkPartialUpdate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkUpdate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesCreate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesPartialUpdate(id: number, data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesUpdate(id: number, data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkPartialUpdate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkUpdate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksCreate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksElevationRead(id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RackUnit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksElevationRead(id, q, face, render, unitWidth, unitHeight, legendWidth, exclude, expandDevices, includeImages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksList(id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksList(id, name, facilityId, assetTag, type, width, uHeight, descUnits, outerWidth, outerDepth, outerUnit, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, status, roleId, role, serial, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, facilityIdN, facilityIdIc, facilityIdNic, facilityIdIew, facilityIdNiew, facilityIdIsw, facilityIdNisw, facilityIdIe, facilityIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, typeN, widthN, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, outerWidthN, outerWidthLte, outerWidthLt, outerWidthGte, outerWidthGt, outerDepthN, outerDepthLte, outerDepthLt, outerDepthGte, outerDepthGt, outerUnitN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, statusN, roleIdN, roleN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksPartialUpdate(id: number, data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksUpdate(id: number, data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkPartialUpdate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkUpdate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesCreate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesList(id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesList(id, name, type, positions, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesPartialUpdate(id: number, data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesUpdate(id: number, data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkPartialUpdate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkUpdate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsCreate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsList(id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsList(id, name, type, positions, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsPartialUpdate(id: number, data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsPaths(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsPaths(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsUpdate(id: number, data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkPartialUpdate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkUpdate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsCreate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsPartialUpdate(id: number, data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsUpdate(id: number, data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkPartialUpdate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkUpdate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesCreate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesList(id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesList(id, name, slug, facility, asn, latitude, longitude, contactName, contactPhone, contactEmail, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, regionId, region, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, facilityN, facilityIc, facilityNic, facilityIew, facilityNiew, facilityIsw, facilityNisw, facilityIe, facilityNie, asnN, asnLte, asnLt, asnGte, asnGt, latitudeN, latitudeLte, latitudeLt, latitudeGte, latitudeGt, longitudeN, longitudeLte, longitudeLt, longitudeGte, longitudeGt, contactNameN, contactNameIc, contactNameNic, contactNameIew, contactNameNiew, contactNameIsw, contactNameNisw, contactNameIe, contactNameNie, contactPhoneN, contactPhoneIc, contactPhoneNic, contactPhoneIew, contactPhoneNiew, contactPhoneIsw, contactPhoneNisw, contactPhoneIe, contactPhoneNie, contactEmailN, contactEmailIc, contactEmailNic, contactEmailIew, contactEmailNiew, contactEmailIsw, contactEmailNisw, contactEmailIe, contactEmailNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, regionIdN, regionN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesPartialUpdate(id: number, data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesUpdate(id: number, data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkPartialUpdate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkUpdate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisCreate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisList(id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisList(id, domain, q, regionId, region, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, domainN, domainIc, domainNic, domainIew, domainNiew, domainIsw, domainNisw, domainIe, domainNie, regionIdN, regionN, siteIdN, siteN, tenantIdN, tenantN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisPartialUpdate(id: number, data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisUpdate(id: number, data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DcimApi - factory interface
 * @export
 */
export const DcimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DcimApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimCablesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkPartialUpdate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkUpdate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesCreate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimCablesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesList(id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.dcimCablesList(id, label, length, lengthUnit, q, type, status, color, deviceId, device, rackId, rack, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, labelN, labelIc, labelNic, labelIew, labelNiew, labelIsw, labelNisw, labelIe, labelNie, lengthN, lengthLte, lengthLt, lengthGte, lengthGt, lengthUnitN, typeN, statusN, colorN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesPartialUpdate(id: number, data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesRead(id: number, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesUpdate(id: number, data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConnectedDeviceList(peerDevice: string, peerInterface: string, options?: any): AxiosPromise<Device> {
            return localVarFp.dcimConnectedDeviceList(peerDevice, peerInterface, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.dcimConsoleConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkPartialUpdate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkUpdate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesCreate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.dcimConsolePortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesPartialUpdate(id: number, data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesRead(id: number, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesUpdate(id: number, data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkPartialUpdate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkUpdate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsCreate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.dcimConsolePortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsPartialUpdate(id: number, data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsRead(id: number, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsTrace(id: number, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsUpdate(id: number, data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkPartialUpdate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkUpdate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesCreate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.dcimConsoleServerPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesPartialUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesRead(id: number, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkPartialUpdate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkUpdate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsCreate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.dcimConsoleServerPortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsPartialUpdate(id: number, data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsRead(id: number, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsTrace(id: number, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsUpdate(id: number, data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBayTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkPartialUpdate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkUpdate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesCreate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBayTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesList(id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.dcimDeviceBayTemplatesList(id, name, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesPartialUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesRead(id: number, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBaysBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkPartialUpdate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkUpdate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysCreate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBaysDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.dcimDeviceBaysList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysPartialUpdate(id: number, data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysRead(id: number, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysUpdate(id: number, data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkPartialUpdate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkUpdate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesCreate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesList(id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.dcimDeviceRolesList(id, name, slug, color, vmRole, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesPartialUpdate(id: number, data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesRead(id: number, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesUpdate(id: number, data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkPartialUpdate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkUpdate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesCreate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesList(id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.dcimDeviceTypesList(id, model, slug, partNumber, uHeight, isFullDepth, subdeviceRole, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, modelN, modelIc, modelNic, modelIew, modelNiew, modelIsw, modelNisw, modelIe, modelNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, partNumberN, partNumberIc, partNumberNic, partNumberIew, partNumberNiew, partNumberIsw, partNumberNisw, partNumberIe, partNumberNie, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, subdeviceRoleN, manufacturerIdN, manufacturerN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesPartialUpdate(id: number, data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesRead(id: number, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesUpdate(id: number, data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDevicesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkPartialUpdate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkUpdate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesCreate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDevicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesList(id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.dcimDevicesList(id, name, assetTag, face, position, vcPosition, vcPriority, tenantGroupId, tenantGroup, tenantId, tenant, localContextData, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, deviceTypeId, roleId, role, platformId, platform, regionId, region, siteId, site, rackGroupId, rackId, clusterId, model, status, isFullDepth, macAddress, serial, hasPrimaryIp, virtualChassisId, virtualChassisMember, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, faceN, positionN, positionLte, positionLt, positionGte, positionGt, vcPositionN, vcPositionLte, vcPositionLt, vcPositionGte, vcPositionGt, vcPriorityN, vcPriorityLte, vcPriorityLt, vcPriorityGte, vcPriorityGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, manufacturerIdN, manufacturerN, deviceTypeIdN, roleIdN, roleN, platformIdN, platformN, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, rackIdN, clusterIdN, modelN, statusN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, virtualChassisIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesNapalm(id: number, method: string, options?: any): AxiosPromise<DeviceNAPALM> {
            return localVarFp.dcimDevicesNapalm(id, method, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesPartialUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesRead(id: number, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkPartialUpdate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkUpdate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesCreate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.dcimFrontPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesPartialUpdate(id: number, data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesRead(id: number, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesUpdate(id: number, data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkPartialUpdate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkUpdate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsCreate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsList(id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.dcimFrontPortsList(id, name, type, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPartialUpdate(id: number, data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPaths(id: number, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsPaths(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsRead(id: number, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsUpdate(id: number, data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceConnectionsList(site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.dcimInterfaceConnectionsList(site, deviceId, device, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfaceTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkPartialUpdate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkUpdate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesCreate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfaceTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesList(id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.dcimInterfaceTemplatesList(id, name, type, mgmtOnly, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesPartialUpdate(id: number, data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesRead(id: number, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesUpdate(id: number, data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfacesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkPartialUpdate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkUpdate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesCreate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfacesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesList(id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.dcimInterfacesList(id, name, type, enabled, mtu, mgmtOnly, mode, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, kind, lagId, macAddress, vlanId, vlan, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, modeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, tagN, lagIdN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesPartialUpdate(id: number, data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesRead(id: number, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesTrace(id: number, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesUpdate(id: number, data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInventoryItemsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkPartialUpdate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkUpdate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsCreate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInventoryItemsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsList(id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.dcimInventoryItemsList(id, name, partId, assetTag, discovered, q, regionId, region, siteId, site, deviceId, device, tag, parentId, manufacturerId, manufacturer, serial, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, partIdN, partIdIc, partIdNic, partIdIew, partIdNiew, partIdIsw, partIdNisw, partIdIe, partIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, parentIdN, manufacturerIdN, manufacturerN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsPartialUpdate(id: number, data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsRead(id: number, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsUpdate(id: number, data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimManufacturersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkPartialUpdate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkUpdate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersCreate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimManufacturersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.dcimManufacturersList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersPartialUpdate(id: number, data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersRead(id: number, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersUpdate(id: number, data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPlatformsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkPartialUpdate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkUpdate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsCreate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPlatformsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsList(id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.dcimPlatformsList(id, name, slug, napalmDriver, description, q, manufacturerId, manufacturer, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, napalmDriverN, napalmDriverIc, napalmDriverNic, napalmDriverIew, napalmDriverNiew, napalmDriverIsw, napalmDriverNisw, napalmDriverIe, napalmDriverNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, manufacturerIdN, manufacturerN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsPartialUpdate(id: number, data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsRead(id: number, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsUpdate(id: number, data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.dcimPowerConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerFeedsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkPartialUpdate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkUpdate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsCreate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerFeedsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsList(id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.dcimPowerFeedsList(id, name, status, type, supply, phase, voltage, amperage, maxUtilization, cabled, connected, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, powerPanelId, rackId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, statusN, typeN, supplyN, phaseN, voltageN, voltageLte, voltageLt, voltageGte, voltageGt, amperageN, amperageLte, amperageLt, amperageGte, amperageGt, maxUtilizationN, maxUtilizationLte, maxUtilizationLt, maxUtilizationGte, maxUtilizationGt, regionIdN, regionN, siteIdN, siteN, powerPanelIdN, rackIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsPartialUpdate(id: number, data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsRead(id: number, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsTrace(id: number, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsUpdate(id: number, data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkPartialUpdate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkUpdate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesCreate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesList(id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.dcimPowerOutletTemplatesList(id, name, type, feedLeg, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, feedLegN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesPartialUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesRead(id: number, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkPartialUpdate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkUpdate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsCreate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsList(id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.dcimPowerOutletsList(id, name, feedLeg, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, feedLegN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsPartialUpdate(id: number, data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsRead(id: number, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsTrace(id: number, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsUpdate(id: number, data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPanelsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkPartialUpdate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkUpdate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsCreate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPanelsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsList(id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.dcimPowerPanelsList(id, name, q, regionId, region, siteId, site, rackGroupId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsPartialUpdate(id: number, data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsRead(id: number, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsUpdate(id: number, data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkPartialUpdate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkUpdate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesCreate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesList(id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.dcimPowerPortTemplatesList(id, name, type, maximumDraw, allocatedDraw, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesPartialUpdate(id: number, data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesRead(id: number, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesUpdate(id: number, data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkPartialUpdate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkUpdate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsCreate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsList(id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.dcimPowerPortsList(id, name, maximumDraw, allocatedDraw, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsPartialUpdate(id: number, data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsRead(id: number, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsTrace(id: number, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsUpdate(id: number, data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkPartialUpdate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkUpdate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsCreate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.dcimRackGroupsList(id, name, slug, description, q, regionId, region, siteId, site, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, parentIdN, parentN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsPartialUpdate(id: number, data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsRead(id: number, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsUpdate(id: number, data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackReservationsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkPartialUpdate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkUpdate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsCreate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackReservationsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsList(id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.dcimRackReservationsList(id, created, tenantGroupId, tenantGroup, tenantId, tenant, q, rackId, siteId, site, groupId, group, userId, user, tag, idN, idLte, idLt, idGte, idGt, createdN, createdLte, createdLt, createdGte, createdGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rackIdN, siteIdN, siteN, groupIdN, groupN, userIdN, userN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsPartialUpdate(id: number, data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsRead(id: number, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsUpdate(id: number, data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkPartialUpdate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkUpdate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesCreate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.dcimRackRolesList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesPartialUpdate(id: number, data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesRead(id: number, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesUpdate(id: number, data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRacksBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkPartialUpdate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkUpdate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksCreate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRacksDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksElevationRead(id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options?: any): AxiosPromise<Array<RackUnit>> {
            return localVarFp.dcimRacksElevationRead(id, q, face, render, unitWidth, unitHeight, legendWidth, exclude, expandDevices, includeImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksList(id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.dcimRacksList(id, name, facilityId, assetTag, type, width, uHeight, descUnits, outerWidth, outerDepth, outerUnit, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, status, roleId, role, serial, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, facilityIdN, facilityIdIc, facilityIdNic, facilityIdIew, facilityIdNiew, facilityIdIsw, facilityIdNisw, facilityIdIe, facilityIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, typeN, widthN, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, outerWidthN, outerWidthLte, outerWidthLt, outerWidthGte, outerWidthGt, outerDepthN, outerDepthLte, outerDepthLt, outerDepthGte, outerDepthGt, outerUnitN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, statusN, roleIdN, roleN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksPartialUpdate(id: number, data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksRead(id: number, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksUpdate(id: number, data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkPartialUpdate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkUpdate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesCreate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesList(id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.dcimRearPortTemplatesList(id, name, type, positions, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesPartialUpdate(id: number, data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesRead(id: number, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesUpdate(id: number, data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkPartialUpdate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkUpdate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsCreate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsList(id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.dcimRearPortsList(id, name, type, positions, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPartialUpdate(id: number, data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPaths(id: number, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsPaths(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsRead(id: number, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsUpdate(id: number, data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRegionsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkPartialUpdate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkUpdate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsCreate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRegionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.dcimRegionsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsPartialUpdate(id: number, data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsRead(id: number, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsUpdate(id: number, data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimSitesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkPartialUpdate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkUpdate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesCreate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimSitesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesList(id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.dcimSitesList(id, name, slug, facility, asn, latitude, longitude, contactName, contactPhone, contactEmail, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, regionId, region, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, facilityN, facilityIc, facilityNic, facilityIew, facilityNiew, facilityIsw, facilityNisw, facilityIe, facilityNie, asnN, asnLte, asnLt, asnGte, asnGt, latitudeN, latitudeLte, latitudeLt, latitudeGte, latitudeGt, longitudeN, longitudeLte, longitudeLt, longitudeGte, longitudeGt, contactNameN, contactNameIc, contactNameNic, contactNameIew, contactNameNiew, contactNameIsw, contactNameNisw, contactNameIe, contactNameNie, contactPhoneN, contactPhoneIc, contactPhoneNic, contactPhoneIew, contactPhoneNiew, contactPhoneIsw, contactPhoneNisw, contactPhoneIe, contactPhoneNie, contactEmailN, contactEmailIc, contactEmailNic, contactEmailIew, contactEmailNiew, contactEmailIsw, contactEmailNisw, contactEmailIe, contactEmailNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, regionIdN, regionN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesPartialUpdate(id: number, data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesRead(id: number, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesUpdate(id: number, data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimVirtualChassisBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkPartialUpdate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkUpdate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisCreate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimVirtualChassisDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisList(id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.dcimVirtualChassisList(id, domain, q, regionId, region, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, domainN, domainIc, domainNic, domainIew, domainNiew, domainIsw, domainNisw, domainIe, domainNie, regionIdN, regionN, siteIdN, siteN, tenantIdN, tenantN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisPartialUpdate(id: number, data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisRead(id: number, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisUpdate(id: number, data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dcimCablesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesBulkPartialUpdateRequest
 */
export interface DcimApiDcimCablesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesBulkPartialUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesBulkUpdateRequest
 */
export interface DcimApiDcimCablesBulkUpdateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesBulkUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesCreateRequest
 */
export interface DcimApiDcimCablesCreateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesCreate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesDeleteRequest
 */
export interface DcimApiDcimCablesDeleteRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimCablesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesListRequest
 */
export interface DcimApiDcimCablesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly label?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly length?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthUnit?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly rack?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthUnitN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimCablesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimCablesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimCablesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesPartialUpdateRequest
 */
export interface DcimApiDcimCablesPartialUpdateRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesPartialUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesReadRequest
 */
export interface DcimApiDcimCablesReadRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimCablesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesUpdateRequest
 */
export interface DcimApiDcimCablesUpdateRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimConnectedDeviceList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConnectedDeviceListRequest
 */
export interface DcimApiDcimConnectedDeviceListRequest {
    /**
     * The name of the peer device
     * @type {string}
     * @memberof DcimApiDcimConnectedDeviceList
     */
    readonly peerDevice: string

    /**
     * The name of the peer interface
     * @type {string}
     * @memberof DcimApiDcimConnectedDeviceList
     */
    readonly peerInterface: string
}

/**
 * Request parameters for dcimConsoleConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleConnectionsListRequest
 */
export interface DcimApiDcimConsoleConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesBulkPartialUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesBulkUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesCreateRequest
 */
export interface DcimApiDcimConsolePortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesCreate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesDeleteRequest
 */
export interface DcimApiDcimConsolePortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesListRequest
 */
export interface DcimApiDcimConsolePortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesPartialUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesReadRequest
 */
export interface DcimApiDcimConsolePortTemplatesReadRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsBulkPartialUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsBulkUpdateRequest
 */
export interface DcimApiDcimConsolePortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsBulkUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsCreateRequest
 */
export interface DcimApiDcimConsolePortsCreateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsCreate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsDeleteRequest
 */
export interface DcimApiDcimConsolePortsDeleteRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsListRequest
 */
export interface DcimApiDcimConsolePortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsPartialUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsReadRequest
 */
export interface DcimApiDcimConsolePortsReadRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsTraceRequest
 */
export interface DcimApiDcimConsolePortsTraceRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsUpdateRequest
 */
export interface DcimApiDcimConsolePortsUpdateRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesBulkUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesCreateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesCreate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesDeleteRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesListRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesPartialUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesReadRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsBulkPartialUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsBulkUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsBulkUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsCreateRequest
 */
export interface DcimApiDcimConsoleServerPortsCreateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsCreate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsDeleteRequest
 */
export interface DcimApiDcimConsoleServerPortsDeleteRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsListRequest
 */
export interface DcimApiDcimConsoleServerPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsoleServerPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsPartialUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsReadRequest
 */
export interface DcimApiDcimConsoleServerPortsReadRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsTraceRequest
 */
export interface DcimApiDcimConsoleServerPortsTraceRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsUpdateRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimDeviceBayTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesBulkPartialUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesBulkUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesCreateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesCreateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesCreate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesDeleteRequest
 */
export interface DcimApiDcimDeviceBayTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesListRequest
 */
export interface DcimApiDcimDeviceBayTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesPartialUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesReadRequest
 */
export interface DcimApiDcimDeviceBayTemplatesReadRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBaysBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBaysBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysBulkPartialUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysBulkUpdateRequest
 */
export interface DcimApiDcimDeviceBaysBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysBulkUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysCreateRequest
 */
export interface DcimApiDcimDeviceBaysCreateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysCreate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysDeleteRequest
 */
export interface DcimApiDcimDeviceBaysDeleteRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBaysList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysListRequest
 */
export interface DcimApiDcimDeviceBaysListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceBaysPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBaysPartialUpdateRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysPartialUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysReadRequest
 */
export interface DcimApiDcimDeviceBaysReadRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBaysUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysUpdateRequest
 */
export interface DcimApiDcimDeviceBaysUpdateRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceRolesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesBulkPartialUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceRolesBulkUpdateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesBulkUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesCreateRequest
 */
export interface DcimApiDcimDeviceRolesCreateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesCreate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesDeleteRequest
 */
export interface DcimApiDcimDeviceRolesDeleteRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceRolesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesListRequest
 */
export interface DcimApiDcimDeviceRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly vmRole?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceRolesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesPartialUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesReadRequest
 */
export interface DcimApiDcimDeviceRolesReadRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceRolesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesUpdateRequest
 */
export interface DcimApiDcimDeviceRolesUpdateRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceTypesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesBulkPartialUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceTypesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesBulkUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesCreateRequest
 */
export interface DcimApiDcimDeviceTypesCreateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesCreate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesDeleteRequest
 */
export interface DcimApiDcimDeviceTypesDeleteRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceTypesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesListRequest
 */
export interface DcimApiDcimDeviceTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly model?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumber?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeight?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly isFullDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly subdeviceRole?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly consolePorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly consoleServerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly powerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly powerOutlets?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly interfaces?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly passThroughPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly deviceBays?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly subdeviceRoleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceTypesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesPartialUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesReadRequest
 */
export interface DcimApiDcimDeviceTypesReadRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceTypesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesUpdateRequest
 */
export interface DcimApiDcimDeviceTypesUpdateRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDevicesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDevicesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesBulkPartialUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesBulkUpdateRequest
 */
export interface DcimApiDcimDevicesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesBulkUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesCreateRequest
 */
export interface DcimApiDcimDevicesCreateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesCreate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesDeleteRequest
 */
export interface DcimApiDcimDevicesDeleteRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDevicesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesListRequest
 */
export interface DcimApiDcimDevicesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly face?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly position?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPosition?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriority?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly localContextData?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platform?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly model?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly isFullDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly hasPrimaryIp?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisMember?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly consolePorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly consoleServerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly powerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly powerOutlets?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly interfaces?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly passThroughPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceBays?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly faceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly modelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDevicesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDevicesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDevicesNapalm operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesNapalmRequest
 */
export interface DcimApiDcimDevicesNapalmRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesNapalm
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesNapalm
     */
    readonly method: string
}

/**
 * Request parameters for dcimDevicesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesPartialUpdateRequest
 */
export interface DcimApiDcimDevicesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesPartialUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesReadRequest
 */
export interface DcimApiDcimDevicesReadRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDevicesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesUpdateRequest
 */
export interface DcimApiDcimDevicesUpdateRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimFrontPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesBulkUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesCreateRequest
 */
export interface DcimApiDcimFrontPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesCreate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesDeleteRequest
 */
export interface DcimApiDcimFrontPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesListRequest
 */
export interface DcimApiDcimFrontPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimFrontPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesPartialUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesReadRequest
 */
export interface DcimApiDcimFrontPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsBulkPartialUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsBulkUpdateRequest
 */
export interface DcimApiDcimFrontPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsBulkUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsCreateRequest
 */
export interface DcimApiDcimFrontPortsCreateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsCreate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsDeleteRequest
 */
export interface DcimApiDcimFrontPortsDeleteRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsListRequest
 */
export interface DcimApiDcimFrontPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimFrontPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsPartialUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsPaths operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsPathsRequest
 */
export interface DcimApiDcimFrontPortsPathsRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsPaths
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsReadRequest
 */
export interface DcimApiDcimFrontPortsReadRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsUpdateRequest
 */
export interface DcimApiDcimFrontPortsUpdateRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimInterfaceConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceConnectionsListRequest
 */
export interface DcimApiDcimInterfaceConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly device?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfaceTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesBulkPartialUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesBulkUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesCreateRequest
 */
export interface DcimApiDcimInterfaceTemplatesCreateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesCreate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesDeleteRequest
 */
export interface DcimApiDcimInterfaceTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfaceTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesListRequest
 */
export interface DcimApiDcimInterfaceTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly mgmtOnly?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfaceTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesPartialUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesReadRequest
 */
export interface DcimApiDcimInterfaceTemplatesReadRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfaceTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfacesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesBulkPartialUpdateRequest
 */
export interface DcimApiDcimInterfacesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesBulkPartialUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesBulkUpdateRequest
 */
export interface DcimApiDcimInterfacesBulkUpdateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesBulkUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesCreateRequest
 */
export interface DcimApiDcimInterfacesCreateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesCreate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesDeleteRequest
 */
export interface DcimApiDcimInterfacesDeleteRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesListRequest
 */
export interface DcimApiDcimInterfacesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtu?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mgmtOnly?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mode?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly kind?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly lagId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly vlanId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly vlan?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly modeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly lagIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfacesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesPartialUpdateRequest
 */
export interface DcimApiDcimInterfacesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesPartialUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesReadRequest
 */
export interface DcimApiDcimInterfacesReadRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesTraceRequest
 */
export interface DcimApiDcimInterfacesTraceRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesUpdateRequest
 */
export interface DcimApiDcimInterfacesUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInventoryItemsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsBulkPartialUpdateRequest
 */
export interface DcimApiDcimInventoryItemsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsBulkPartialUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsBulkUpdateRequest
 */
export interface DcimApiDcimInventoryItemsBulkUpdateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsBulkUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsCreateRequest
 */
export interface DcimApiDcimInventoryItemsCreateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsCreate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsDeleteRequest
 */
export interface DcimApiDcimInventoryItemsDeleteRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInventoryItemsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsListRequest
 */
export interface DcimApiDcimInventoryItemsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly discovered?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInventoryItemsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsPartialUpdateRequest
 */
export interface DcimApiDcimInventoryItemsPartialUpdateRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsPartialUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsReadRequest
 */
export interface DcimApiDcimInventoryItemsReadRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInventoryItemsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsUpdateRequest
 */
export interface DcimApiDcimInventoryItemsUpdateRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimManufacturersBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersBulkPartialUpdateRequest
 */
export interface DcimApiDcimManufacturersBulkPartialUpdateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersBulkPartialUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersBulkUpdateRequest
 */
export interface DcimApiDcimManufacturersBulkUpdateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersBulkUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersCreateRequest
 */
export interface DcimApiDcimManufacturersCreateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersCreate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersDeleteRequest
 */
export interface DcimApiDcimManufacturersDeleteRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimManufacturersList operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersListRequest
 */
export interface DcimApiDcimManufacturersListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimManufacturersPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersPartialUpdateRequest
 */
export interface DcimApiDcimManufacturersPartialUpdateRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersPartialUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersReadRequest
 */
export interface DcimApiDcimManufacturersReadRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimManufacturersUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersUpdateRequest
 */
export interface DcimApiDcimManufacturersUpdateRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimPlatformsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPlatformsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsBulkPartialUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsBulkUpdateRequest
 */
export interface DcimApiDcimPlatformsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsBulkUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsCreateRequest
 */
export interface DcimApiDcimPlatformsCreateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsCreate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsDeleteRequest
 */
export interface DcimApiDcimPlatformsDeleteRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPlatformsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsListRequest
 */
export interface DcimApiDcimPlatformsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriver?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPlatformsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsPartialUpdateRequest
 */
export interface DcimApiDcimPlatformsPartialUpdateRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsPartialUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsReadRequest
 */
export interface DcimApiDcimPlatformsReadRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPlatformsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsUpdateRequest
 */
export interface DcimApiDcimPlatformsUpdateRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPowerConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerConnectionsListRequest
 */
export interface DcimApiDcimPowerConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerFeedsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerFeedsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsBulkPartialUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsBulkUpdateRequest
 */
export interface DcimApiDcimPowerFeedsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsBulkUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsCreateRequest
 */
export interface DcimApiDcimPowerFeedsCreateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsCreate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsDeleteRequest
 */
export interface DcimApiDcimPowerFeedsDeleteRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsListRequest
 */
export interface DcimApiDcimPowerFeedsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly supply?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly phase?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltage?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperage?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilization?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly powerPanelId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly supplyN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly phaseN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly powerPanelIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerFeedsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsPartialUpdateRequest
 */
export interface DcimApiDcimPowerFeedsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsPartialUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsReadRequest
 */
export interface DcimApiDcimPowerFeedsReadRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsTraceRequest
 */
export interface DcimApiDcimPowerFeedsTraceRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsUpdateRequest
 */
export interface DcimApiDcimPowerFeedsUpdateRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerOutletTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesBulkPartialUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesBulkUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesCreateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesCreateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesCreate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesDeleteRequest
 */
export interface DcimApiDcimPowerOutletTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesListRequest
 */
export interface DcimApiDcimPowerOutletTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly feedLeg?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly feedLegN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesPartialUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesReadRequest
 */
export interface DcimApiDcimPowerOutletTemplatesReadRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsBulkPartialUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsBulkUpdateRequest
 */
export interface DcimApiDcimPowerOutletsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsBulkUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsCreateRequest
 */
export interface DcimApiDcimPowerOutletsCreateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsCreate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsDeleteRequest
 */
export interface DcimApiDcimPowerOutletsDeleteRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsListRequest
 */
export interface DcimApiDcimPowerOutletsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly feedLeg?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly feedLegN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerOutletsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsPartialUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsReadRequest
 */
export interface DcimApiDcimPowerOutletsReadRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsTraceRequest
 */
export interface DcimApiDcimPowerOutletsTraceRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsUpdateRequest
 */
export interface DcimApiDcimPowerOutletsUpdateRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerPanelsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPanelsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsBulkPartialUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsBulkUpdateRequest
 */
export interface DcimApiDcimPowerPanelsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsBulkUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsCreateRequest
 */
export interface DcimApiDcimPowerPanelsCreateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsCreate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsDeleteRequest
 */
export interface DcimApiDcimPowerPanelsDeleteRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPanelsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsListRequest
 */
export interface DcimApiDcimPowerPanelsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly rackGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly rackGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPanelsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsPartialUpdateRequest
 */
export interface DcimApiDcimPowerPanelsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsPartialUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsReadRequest
 */
export interface DcimApiDcimPowerPanelsReadRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPanelsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsUpdateRequest
 */
export interface DcimApiDcimPowerPanelsUpdateRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesBulkPartialUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesBulkUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesCreateRequest
 */
export interface DcimApiDcimPowerPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesCreate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesDeleteRequest
 */
export interface DcimApiDcimPowerPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesListRequest
 */
export interface DcimApiDcimPowerPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesPartialUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesReadRequest
 */
export interface DcimApiDcimPowerPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsBulkPartialUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsBulkUpdateRequest
 */
export interface DcimApiDcimPowerPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsBulkUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsCreateRequest
 */
export interface DcimApiDcimPowerPortsCreateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsCreate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsDeleteRequest
 */
export interface DcimApiDcimPowerPortsDeleteRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsListRequest
 */
export interface DcimApiDcimPowerPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsPartialUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsReadRequest
 */
export interface DcimApiDcimPowerPortsReadRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsTraceRequest
 */
export interface DcimApiDcimPowerPortsTraceRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsUpdateRequest
 */
export interface DcimApiDcimPowerPortsUpdateRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimRackGroupsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsBulkPartialUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsBulkUpdateRequest
 */
export interface DcimApiDcimRackGroupsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsBulkUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsCreateRequest
 */
export interface DcimApiDcimRackGroupsCreateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsCreate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsDeleteRequest
 */
export interface DcimApiDcimRackGroupsDeleteRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackGroupsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsListRequest
 */
export interface DcimApiDcimRackGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackGroupsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsPartialUpdateRequest
 */
export interface DcimApiDcimRackGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsPartialUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsReadRequest
 */
export interface DcimApiDcimRackGroupsReadRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackGroupsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsUpdateRequest
 */
export interface DcimApiDcimRackGroupsUpdateRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackReservationsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackReservationsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsBulkPartialUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsBulkUpdateRequest
 */
export interface DcimApiDcimRackReservationsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsBulkUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsCreateRequest
 */
export interface DcimApiDcimRackReservationsCreateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsCreate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsDeleteRequest
 */
export interface DcimApiDcimRackReservationsDeleteRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackReservationsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsListRequest
 */
export interface DcimApiDcimRackReservationsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackReservationsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsPartialUpdateRequest
 */
export interface DcimApiDcimRackReservationsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsPartialUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsReadRequest
 */
export interface DcimApiDcimRackReservationsReadRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackReservationsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsUpdateRequest
 */
export interface DcimApiDcimRackReservationsUpdateRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackRolesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesBulkPartialUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesBulkUpdateRequest
 */
export interface DcimApiDcimRackRolesBulkUpdateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesBulkUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesCreateRequest
 */
export interface DcimApiDcimRackRolesCreateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesCreate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesDeleteRequest
 */
export interface DcimApiDcimRackRolesDeleteRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackRolesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesListRequest
 */
export interface DcimApiDcimRackRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackRolesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesPartialUpdateRequest
 */
export interface DcimApiDcimRackRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesPartialUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesReadRequest
 */
export interface DcimApiDcimRackRolesReadRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackRolesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesUpdateRequest
 */
export interface DcimApiDcimRackRolesUpdateRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRacksBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksBulkPartialUpdateRequest
 */
export interface DcimApiDcimRacksBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksBulkPartialUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksBulkUpdateRequest
 */
export interface DcimApiDcimRacksBulkUpdateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksBulkUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksCreateRequest
 */
export interface DcimApiDcimRacksCreateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksCreate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksDeleteRequest
 */
export interface DcimApiDcimRacksDeleteRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRacksElevationRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksElevationReadRequest
 */
export interface DcimApiDcimRacksElevationReadRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly q?: string

    /**
     * 
     * @type {'front' | 'rear'}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly face?: 'front' | 'rear'

    /**
     * 
     * @type {'json' | 'svg'}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly render?: 'json' | 'svg'

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly unitWidth?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly unitHeight?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly legendWidth?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly exclude?: number

    /**
     * 
     * @type {boolean}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly expandDevices?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly includeImages?: boolean
}

/**
 * Request parameters for dcimRacksList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksListRequest
 */
export interface DcimApiDcimRacksListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly width?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeight?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly descUnits?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerUnit?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly widthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerUnitN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRacksList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRacksList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRacksPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksPartialUpdateRequest
 */
export interface DcimApiDcimRacksPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksPartialUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksReadRequest
 */
export interface DcimApiDcimRacksReadRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRacksUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksUpdateRequest
 */
export interface DcimApiDcimRacksUpdateRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRearPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesBulkUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesCreateRequest
 */
export interface DcimApiDcimRearPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesCreate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesDeleteRequest
 */
export interface DcimApiDcimRearPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesListRequest
 */
export interface DcimApiDcimRearPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positions?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRearPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesPartialUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesReadRequest
 */
export interface DcimApiDcimRearPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRearPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsBulkPartialUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsBulkUpdateRequest
 */
export interface DcimApiDcimRearPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsBulkUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsCreateRequest
 */
export interface DcimApiDcimRearPortsCreateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsCreate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsDeleteRequest
 */
export interface DcimApiDcimRearPortsDeleteRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsListRequest
 */
export interface DcimApiDcimRearPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positions?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRearPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsPartialUpdateRequest
 */
export interface DcimApiDcimRearPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsPartialUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsPaths operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsPathsRequest
 */
export interface DcimApiDcimRearPortsPathsRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsPaths
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsReadRequest
 */
export interface DcimApiDcimRearPortsReadRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsUpdateRequest
 */
export interface DcimApiDcimRearPortsUpdateRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRegionsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRegionsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsBulkPartialUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsBulkUpdateRequest
 */
export interface DcimApiDcimRegionsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsBulkUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsCreateRequest
 */
export interface DcimApiDcimRegionsCreateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsCreate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsDeleteRequest
 */
export interface DcimApiDcimRegionsDeleteRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRegionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsListRequest
 */
export interface DcimApiDcimRegionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRegionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRegionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRegionsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsPartialUpdateRequest
 */
export interface DcimApiDcimRegionsPartialUpdateRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsPartialUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsReadRequest
 */
export interface DcimApiDcimRegionsReadRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRegionsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsUpdateRequest
 */
export interface DcimApiDcimRegionsUpdateRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimSitesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesBulkPartialUpdateRequest
 */
export interface DcimApiDcimSitesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesBulkPartialUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesBulkUpdateRequest
 */
export interface DcimApiDcimSitesBulkUpdateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesBulkUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesCreateRequest
 */
export interface DcimApiDcimSitesCreateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesCreate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesDeleteRequest
 */
export interface DcimApiDcimSitesDeleteRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimSitesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesListRequest
 */
export interface DcimApiDcimSitesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facility?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asn?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitude?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitude?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactName?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhone?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmail?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimSitesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimSitesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimSitesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesPartialUpdateRequest
 */
export interface DcimApiDcimSitesPartialUpdateRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesPartialUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesReadRequest
 */
export interface DcimApiDcimSitesReadRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimSitesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesUpdateRequest
 */
export interface DcimApiDcimSitesUpdateRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimVirtualChassisBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisBulkPartialUpdateRequest
 */
export interface DcimApiDcimVirtualChassisBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisBulkPartialUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisBulkUpdateRequest
 */
export interface DcimApiDcimVirtualChassisBulkUpdateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisBulkUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisCreateRequest
 */
export interface DcimApiDcimVirtualChassisCreateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisCreate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisDeleteRequest
 */
export interface DcimApiDcimVirtualChassisDeleteRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimVirtualChassisList operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisListRequest
 */
export interface DcimApiDcimVirtualChassisListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domain?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimVirtualChassisPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisPartialUpdateRequest
 */
export interface DcimApiDcimVirtualChassisPartialUpdateRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisPartialUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisReadRequest
 */
export interface DcimApiDcimVirtualChassisReadRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimVirtualChassisUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisUpdateRequest
 */
export interface DcimApiDcimVirtualChassisUpdateRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * DcimApi - object-oriented interface
 * @export
 * @class DcimApi
 * @extends {BaseAPI}
 */
export class DcimApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkPartialUpdate(requestParameters: DcimApiDcimCablesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkUpdate(requestParameters: DcimApiDcimCablesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesCreate(requestParameters: DcimApiDcimCablesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesDelete(requestParameters: DcimApiDcimCablesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesList(requestParameters: DcimApiDcimCablesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesList(requestParameters.id, requestParameters.label, requestParameters.length, requestParameters.lengthUnit, requestParameters.q, requestParameters.type, requestParameters.status, requestParameters.color, requestParameters.deviceId, requestParameters.device, requestParameters.rackId, requestParameters.rack, requestParameters.siteId, requestParameters.site, requestParameters.tenantId, requestParameters.tenant, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.labelN, requestParameters.labelIc, requestParameters.labelNic, requestParameters.labelIew, requestParameters.labelNiew, requestParameters.labelIsw, requestParameters.labelNisw, requestParameters.labelIe, requestParameters.labelNie, requestParameters.lengthN, requestParameters.lengthLte, requestParameters.lengthLt, requestParameters.lengthGte, requestParameters.lengthGt, requestParameters.lengthUnitN, requestParameters.typeN, requestParameters.statusN, requestParameters.colorN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesPartialUpdate(requestParameters: DcimApiDcimCablesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesRead(requestParameters: DcimApiDcimCablesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesUpdate(requestParameters: DcimApiDcimCablesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
     * @param {DcimApiDcimConnectedDeviceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConnectedDeviceList(requestParameters: DcimApiDcimConnectedDeviceListRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConnectedDeviceList(requestParameters.peerDevice, requestParameters.peerInterface, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleConnectionsList(requestParameters: DcimApiDcimConsoleConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleConnectionsList(requestParameters.name, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkUpdate(requestParameters: DcimApiDcimConsolePortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesCreate(requestParameters: DcimApiDcimConsolePortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesDelete(requestParameters: DcimApiDcimConsolePortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesList(requestParameters: DcimApiDcimConsolePortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesPartialUpdate(requestParameters: DcimApiDcimConsolePortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesRead(requestParameters: DcimApiDcimConsolePortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesUpdate(requestParameters: DcimApiDcimConsolePortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkPartialUpdate(requestParameters: DcimApiDcimConsolePortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkUpdate(requestParameters: DcimApiDcimConsolePortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsCreate(requestParameters: DcimApiDcimConsolePortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsDelete(requestParameters: DcimApiDcimConsolePortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsList(requestParameters: DcimApiDcimConsolePortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsPartialUpdate(requestParameters: DcimApiDcimConsolePortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsRead(requestParameters: DcimApiDcimConsolePortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimConsolePortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsTrace(requestParameters: DcimApiDcimConsolePortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsUpdate(requestParameters: DcimApiDcimConsolePortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesCreate(requestParameters: DcimApiDcimConsoleServerPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesDelete(requestParameters: DcimApiDcimConsoleServerPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesList(requestParameters: DcimApiDcimConsoleServerPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesRead(requestParameters: DcimApiDcimConsoleServerPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkUpdate(requestParameters: DcimApiDcimConsoleServerPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsCreate(requestParameters: DcimApiDcimConsoleServerPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsDelete(requestParameters: DcimApiDcimConsoleServerPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsList(requestParameters: DcimApiDcimConsoleServerPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsRead(requestParameters: DcimApiDcimConsoleServerPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimConsoleServerPortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsTrace(requestParameters: DcimApiDcimConsoleServerPortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsUpdate(requestParameters: DcimApiDcimConsoleServerPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesCreate(requestParameters: DcimApiDcimDeviceBayTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesDelete(requestParameters: DcimApiDcimDeviceBayTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesList(requestParameters: DcimApiDcimDeviceBayTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesPartialUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesRead(requestParameters: DcimApiDcimDeviceBayTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkPartialUpdate(requestParameters: DcimApiDcimDeviceBaysBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkUpdate(requestParameters: DcimApiDcimDeviceBaysBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysCreate(requestParameters: DcimApiDcimDeviceBaysCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysDelete(requestParameters: DcimApiDcimDeviceBaysDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysList(requestParameters: DcimApiDcimDeviceBaysListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysPartialUpdate(requestParameters: DcimApiDcimDeviceBaysPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysRead(requestParameters: DcimApiDcimDeviceBaysReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysUpdate(requestParameters: DcimApiDcimDeviceBaysUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceRolesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkUpdate(requestParameters: DcimApiDcimDeviceRolesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesCreate(requestParameters: DcimApiDcimDeviceRolesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesDelete(requestParameters: DcimApiDcimDeviceRolesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesList(requestParameters: DcimApiDcimDeviceRolesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.color, requestParameters.vmRole, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.colorN, requestParameters.colorIc, requestParameters.colorNic, requestParameters.colorIew, requestParameters.colorNiew, requestParameters.colorIsw, requestParameters.colorNisw, requestParameters.colorIe, requestParameters.colorNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesPartialUpdate(requestParameters: DcimApiDcimDeviceRolesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesRead(requestParameters: DcimApiDcimDeviceRolesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesUpdate(requestParameters: DcimApiDcimDeviceRolesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceTypesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkUpdate(requestParameters: DcimApiDcimDeviceTypesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesCreate(requestParameters: DcimApiDcimDeviceTypesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesDelete(requestParameters: DcimApiDcimDeviceTypesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesList(requestParameters: DcimApiDcimDeviceTypesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesList(requestParameters.id, requestParameters.model, requestParameters.slug, requestParameters.partNumber, requestParameters.uHeight, requestParameters.isFullDepth, requestParameters.subdeviceRole, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.consolePorts, requestParameters.consoleServerPorts, requestParameters.powerPorts, requestParameters.powerOutlets, requestParameters.interfaces, requestParameters.passThroughPorts, requestParameters.deviceBays, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.modelN, requestParameters.modelIc, requestParameters.modelNic, requestParameters.modelIew, requestParameters.modelNiew, requestParameters.modelIsw, requestParameters.modelNisw, requestParameters.modelIe, requestParameters.modelNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.partNumberN, requestParameters.partNumberIc, requestParameters.partNumberNic, requestParameters.partNumberIew, requestParameters.partNumberNiew, requestParameters.partNumberIsw, requestParameters.partNumberNisw, requestParameters.partNumberIe, requestParameters.partNumberNie, requestParameters.uHeightN, requestParameters.uHeightLte, requestParameters.uHeightLt, requestParameters.uHeightGte, requestParameters.uHeightGt, requestParameters.subdeviceRoleN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesPartialUpdate(requestParameters: DcimApiDcimDeviceTypesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesRead(requestParameters: DcimApiDcimDeviceTypesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesUpdate(requestParameters: DcimApiDcimDeviceTypesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkPartialUpdate(requestParameters: DcimApiDcimDevicesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkUpdate(requestParameters: DcimApiDcimDevicesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesCreate(requestParameters: DcimApiDcimDevicesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesDelete(requestParameters: DcimApiDcimDevicesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesList(requestParameters: DcimApiDcimDevicesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesList(requestParameters.id, requestParameters.name, requestParameters.assetTag, requestParameters.face, requestParameters.position, requestParameters.vcPosition, requestParameters.vcPriority, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.localContextData, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.deviceTypeId, requestParameters.roleId, requestParameters.role, requestParameters.platformId, requestParameters.platform, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.rackGroupId, requestParameters.rackId, requestParameters.clusterId, requestParameters.model, requestParameters.status, requestParameters.isFullDepth, requestParameters.macAddress, requestParameters.serial, requestParameters.hasPrimaryIp, requestParameters.virtualChassisId, requestParameters.virtualChassisMember, requestParameters.consolePorts, requestParameters.consoleServerPorts, requestParameters.powerPorts, requestParameters.powerOutlets, requestParameters.interfaces, requestParameters.passThroughPorts, requestParameters.deviceBays, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.faceN, requestParameters.positionN, requestParameters.positionLte, requestParameters.positionLt, requestParameters.positionGte, requestParameters.positionGt, requestParameters.vcPositionN, requestParameters.vcPositionLte, requestParameters.vcPositionLt, requestParameters.vcPositionGte, requestParameters.vcPositionGt, requestParameters.vcPriorityN, requestParameters.vcPriorityLte, requestParameters.vcPriorityLt, requestParameters.vcPriorityGte, requestParameters.vcPriorityGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.deviceTypeIdN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.platformIdN, requestParameters.platformN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.rackGroupIdN, requestParameters.rackIdN, requestParameters.clusterIdN, requestParameters.modelN, requestParameters.statusN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.virtualChassisIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a NAPALM method on a Device
     * @param {DcimApiDcimDevicesNapalmRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesNapalm(requestParameters: DcimApiDcimDevicesNapalmRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesNapalm(requestParameters.id, requestParameters.method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesPartialUpdate(requestParameters: DcimApiDcimDevicesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesRead(requestParameters: DcimApiDcimDevicesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesUpdate(requestParameters: DcimApiDcimDevicesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkUpdate(requestParameters: DcimApiDcimFrontPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesCreate(requestParameters: DcimApiDcimFrontPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesDelete(requestParameters: DcimApiDcimFrontPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesList(requestParameters: DcimApiDcimFrontPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesPartialUpdate(requestParameters: DcimApiDcimFrontPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesRead(requestParameters: DcimApiDcimFrontPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesUpdate(requestParameters: DcimApiDcimFrontPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkPartialUpdate(requestParameters: DcimApiDcimFrontPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkUpdate(requestParameters: DcimApiDcimFrontPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsCreate(requestParameters: DcimApiDcimFrontPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsDelete(requestParameters: DcimApiDcimFrontPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsList(requestParameters: DcimApiDcimFrontPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsPartialUpdate(requestParameters: DcimApiDcimFrontPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all CablePaths which traverse a given pass-through port.
     * @param {DcimApiDcimFrontPortsPathsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsPaths(requestParameters: DcimApiDcimFrontPortsPathsRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsPaths(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsRead(requestParameters: DcimApiDcimFrontPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsUpdate(requestParameters: DcimApiDcimFrontPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceConnectionsList(requestParameters: DcimApiDcimInterfaceConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceConnectionsList(requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkUpdate(requestParameters: DcimApiDcimInterfaceTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesCreate(requestParameters: DcimApiDcimInterfaceTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesDelete(requestParameters: DcimApiDcimInterfaceTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesList(requestParameters: DcimApiDcimInterfaceTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.mgmtOnly, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesPartialUpdate(requestParameters: DcimApiDcimInterfaceTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesRead(requestParameters: DcimApiDcimInterfaceTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesUpdate(requestParameters: DcimApiDcimInterfaceTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkPartialUpdate(requestParameters: DcimApiDcimInterfacesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkUpdate(requestParameters: DcimApiDcimInterfacesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesCreate(requestParameters: DcimApiDcimInterfacesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesDelete(requestParameters: DcimApiDcimInterfacesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesList(requestParameters: DcimApiDcimInterfacesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.enabled, requestParameters.mtu, requestParameters.mgmtOnly, requestParameters.mode, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.kind, requestParameters.lagId, requestParameters.macAddress, requestParameters.vlanId, requestParameters.vlan, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.mtuN, requestParameters.mtuLte, requestParameters.mtuLt, requestParameters.mtuGte, requestParameters.mtuGt, requestParameters.modeN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tagN, requestParameters.lagIdN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesPartialUpdate(requestParameters: DcimApiDcimInterfacesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesRead(requestParameters: DcimApiDcimInterfacesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimInterfacesTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesTrace(requestParameters: DcimApiDcimInterfacesTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesUpdate(requestParameters: DcimApiDcimInterfacesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkPartialUpdate(requestParameters: DcimApiDcimInventoryItemsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkUpdate(requestParameters: DcimApiDcimInventoryItemsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsCreate(requestParameters: DcimApiDcimInventoryItemsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsDelete(requestParameters: DcimApiDcimInventoryItemsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsList(requestParameters: DcimApiDcimInventoryItemsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsList(requestParameters.id, requestParameters.name, requestParameters.partId, requestParameters.assetTag, requestParameters.discovered, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.parentId, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.serial, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.partIdN, requestParameters.partIdIc, requestParameters.partIdNic, requestParameters.partIdIew, requestParameters.partIdNiew, requestParameters.partIdIsw, requestParameters.partIdNisw, requestParameters.partIdIe, requestParameters.partIdNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.parentIdN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsPartialUpdate(requestParameters: DcimApiDcimInventoryItemsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsRead(requestParameters: DcimApiDcimInventoryItemsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsUpdate(requestParameters: DcimApiDcimInventoryItemsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkPartialUpdate(requestParameters: DcimApiDcimManufacturersBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkUpdate(requestParameters: DcimApiDcimManufacturersBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersCreate(requestParameters: DcimApiDcimManufacturersCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersDelete(requestParameters: DcimApiDcimManufacturersDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersList(requestParameters: DcimApiDcimManufacturersListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersPartialUpdate(requestParameters: DcimApiDcimManufacturersPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersRead(requestParameters: DcimApiDcimManufacturersReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersUpdate(requestParameters: DcimApiDcimManufacturersUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkPartialUpdate(requestParameters: DcimApiDcimPlatformsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkUpdate(requestParameters: DcimApiDcimPlatformsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsCreate(requestParameters: DcimApiDcimPlatformsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsDelete(requestParameters: DcimApiDcimPlatformsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsList(requestParameters: DcimApiDcimPlatformsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.napalmDriver, requestParameters.description, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.napalmDriverN, requestParameters.napalmDriverIc, requestParameters.napalmDriverNic, requestParameters.napalmDriverIew, requestParameters.napalmDriverNiew, requestParameters.napalmDriverIsw, requestParameters.napalmDriverNisw, requestParameters.napalmDriverIe, requestParameters.napalmDriverNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsPartialUpdate(requestParameters: DcimApiDcimPlatformsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsRead(requestParameters: DcimApiDcimPlatformsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsUpdate(requestParameters: DcimApiDcimPlatformsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerConnectionsList(requestParameters: DcimApiDcimPowerConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerConnectionsList(requestParameters.name, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkPartialUpdate(requestParameters: DcimApiDcimPowerFeedsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkUpdate(requestParameters: DcimApiDcimPowerFeedsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsCreate(requestParameters: DcimApiDcimPowerFeedsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsDelete(requestParameters: DcimApiDcimPowerFeedsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsList(requestParameters: DcimApiDcimPowerFeedsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsList(requestParameters.id, requestParameters.name, requestParameters.status, requestParameters.type, requestParameters.supply, requestParameters.phase, requestParameters.voltage, requestParameters.amperage, requestParameters.maxUtilization, requestParameters.cabled, requestParameters.connected, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.powerPanelId, requestParameters.rackId, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.statusN, requestParameters.typeN, requestParameters.supplyN, requestParameters.phaseN, requestParameters.voltageN, requestParameters.voltageLte, requestParameters.voltageLt, requestParameters.voltageGte, requestParameters.voltageGt, requestParameters.amperageN, requestParameters.amperageLte, requestParameters.amperageLt, requestParameters.amperageGte, requestParameters.amperageGt, requestParameters.maxUtilizationN, requestParameters.maxUtilizationLte, requestParameters.maxUtilizationLt, requestParameters.maxUtilizationGte, requestParameters.maxUtilizationGt, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.powerPanelIdN, requestParameters.rackIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsPartialUpdate(requestParameters: DcimApiDcimPowerFeedsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsRead(requestParameters: DcimApiDcimPowerFeedsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerFeedsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsTrace(requestParameters: DcimApiDcimPowerFeedsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsUpdate(requestParameters: DcimApiDcimPowerFeedsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesCreate(requestParameters: DcimApiDcimPowerOutletTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesDelete(requestParameters: DcimApiDcimPowerOutletTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesList(requestParameters: DcimApiDcimPowerOutletTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.feedLeg, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.feedLegN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesPartialUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesRead(requestParameters: DcimApiDcimPowerOutletTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkPartialUpdate(requestParameters: DcimApiDcimPowerOutletsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkUpdate(requestParameters: DcimApiDcimPowerOutletsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsCreate(requestParameters: DcimApiDcimPowerOutletsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsDelete(requestParameters: DcimApiDcimPowerOutletsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsList(requestParameters: DcimApiDcimPowerOutletsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsList(requestParameters.id, requestParameters.name, requestParameters.feedLeg, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.feedLegN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsPartialUpdate(requestParameters: DcimApiDcimPowerOutletsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsRead(requestParameters: DcimApiDcimPowerOutletsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerOutletsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsTrace(requestParameters: DcimApiDcimPowerOutletsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsUpdate(requestParameters: DcimApiDcimPowerOutletsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkPartialUpdate(requestParameters: DcimApiDcimPowerPanelsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkUpdate(requestParameters: DcimApiDcimPowerPanelsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsCreate(requestParameters: DcimApiDcimPowerPanelsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsDelete(requestParameters: DcimApiDcimPowerPanelsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsList(requestParameters: DcimApiDcimPowerPanelsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.rackGroupId, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.rackGroupIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsPartialUpdate(requestParameters: DcimApiDcimPowerPanelsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsRead(requestParameters: DcimApiDcimPowerPanelsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsUpdate(requestParameters: DcimApiDcimPowerPanelsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkUpdate(requestParameters: DcimApiDcimPowerPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesCreate(requestParameters: DcimApiDcimPowerPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesDelete(requestParameters: DcimApiDcimPowerPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesList(requestParameters: DcimApiDcimPowerPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.maximumDraw, requestParameters.allocatedDraw, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.maximumDrawN, requestParameters.maximumDrawLte, requestParameters.maximumDrawLt, requestParameters.maximumDrawGte, requestParameters.maximumDrawGt, requestParameters.allocatedDrawN, requestParameters.allocatedDrawLte, requestParameters.allocatedDrawLt, requestParameters.allocatedDrawGte, requestParameters.allocatedDrawGt, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesPartialUpdate(requestParameters: DcimApiDcimPowerPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesRead(requestParameters: DcimApiDcimPowerPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesUpdate(requestParameters: DcimApiDcimPowerPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkPartialUpdate(requestParameters: DcimApiDcimPowerPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkUpdate(requestParameters: DcimApiDcimPowerPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsCreate(requestParameters: DcimApiDcimPowerPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsDelete(requestParameters: DcimApiDcimPowerPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsList(requestParameters: DcimApiDcimPowerPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsList(requestParameters.id, requestParameters.name, requestParameters.maximumDraw, requestParameters.allocatedDraw, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.maximumDrawN, requestParameters.maximumDrawLte, requestParameters.maximumDrawLt, requestParameters.maximumDrawGte, requestParameters.maximumDrawGt, requestParameters.allocatedDrawN, requestParameters.allocatedDrawLte, requestParameters.allocatedDrawLt, requestParameters.allocatedDrawGte, requestParameters.allocatedDrawGt, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsPartialUpdate(requestParameters: DcimApiDcimPowerPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsRead(requestParameters: DcimApiDcimPowerPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerPortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsTrace(requestParameters: DcimApiDcimPowerPortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsUpdate(requestParameters: DcimApiDcimPowerPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkPartialUpdate(requestParameters: DcimApiDcimRackGroupsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkUpdate(requestParameters: DcimApiDcimRackGroupsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsCreate(requestParameters: DcimApiDcimRackGroupsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsDelete(requestParameters: DcimApiDcimRackGroupsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsList(requestParameters: DcimApiDcimRackGroupsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.parentId, requestParameters.parent, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.parentIdN, requestParameters.parentN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsPartialUpdate(requestParameters: DcimApiDcimRackGroupsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsRead(requestParameters: DcimApiDcimRackGroupsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsUpdate(requestParameters: DcimApiDcimRackGroupsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkPartialUpdate(requestParameters: DcimApiDcimRackReservationsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkUpdate(requestParameters: DcimApiDcimRackReservationsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsCreate(requestParameters: DcimApiDcimRackReservationsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsDelete(requestParameters: DcimApiDcimRackReservationsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsList(requestParameters: DcimApiDcimRackReservationsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsList(requestParameters.id, requestParameters.created, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.q, requestParameters.rackId, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.userId, requestParameters.user, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.createdN, requestParameters.createdLte, requestParameters.createdLt, requestParameters.createdGte, requestParameters.createdGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.rackIdN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.userIdN, requestParameters.userN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsPartialUpdate(requestParameters: DcimApiDcimRackReservationsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsRead(requestParameters: DcimApiDcimRackReservationsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsUpdate(requestParameters: DcimApiDcimRackReservationsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkPartialUpdate(requestParameters: DcimApiDcimRackRolesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkUpdate(requestParameters: DcimApiDcimRackRolesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesCreate(requestParameters: DcimApiDcimRackRolesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesDelete(requestParameters: DcimApiDcimRackRolesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesList(requestParameters: DcimApiDcimRackRolesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.color, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.colorN, requestParameters.colorIc, requestParameters.colorNic, requestParameters.colorIew, requestParameters.colorNiew, requestParameters.colorIsw, requestParameters.colorNisw, requestParameters.colorIe, requestParameters.colorNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesPartialUpdate(requestParameters: DcimApiDcimRackRolesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesRead(requestParameters: DcimApiDcimRackRolesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesUpdate(requestParameters: DcimApiDcimRackRolesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkPartialUpdate(requestParameters: DcimApiDcimRacksBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkUpdate(requestParameters: DcimApiDcimRacksBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksCreate(requestParameters: DcimApiDcimRacksCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksDelete(requestParameters: DcimApiDcimRacksDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
     * @param {DcimApiDcimRacksElevationReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksElevationRead(requestParameters: DcimApiDcimRacksElevationReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksElevationRead(requestParameters.id, requestParameters.q, requestParameters.face, requestParameters.render, requestParameters.unitWidth, requestParameters.unitHeight, requestParameters.legendWidth, requestParameters.exclude, requestParameters.expandDevices, requestParameters.includeImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksList(requestParameters: DcimApiDcimRacksListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksList(requestParameters.id, requestParameters.name, requestParameters.facilityId, requestParameters.assetTag, requestParameters.type, requestParameters.width, requestParameters.uHeight, requestParameters.descUnits, requestParameters.outerWidth, requestParameters.outerDepth, requestParameters.outerUnit, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.status, requestParameters.roleId, requestParameters.role, requestParameters.serial, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.facilityIdN, requestParameters.facilityIdIc, requestParameters.facilityIdNic, requestParameters.facilityIdIew, requestParameters.facilityIdNiew, requestParameters.facilityIdIsw, requestParameters.facilityIdNisw, requestParameters.facilityIdIe, requestParameters.facilityIdNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.typeN, requestParameters.widthN, requestParameters.uHeightN, requestParameters.uHeightLte, requestParameters.uHeightLt, requestParameters.uHeightGte, requestParameters.uHeightGt, requestParameters.outerWidthN, requestParameters.outerWidthLte, requestParameters.outerWidthLt, requestParameters.outerWidthGte, requestParameters.outerWidthGt, requestParameters.outerDepthN, requestParameters.outerDepthLte, requestParameters.outerDepthLt, requestParameters.outerDepthGte, requestParameters.outerDepthGt, requestParameters.outerUnitN, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.statusN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksPartialUpdate(requestParameters: DcimApiDcimRacksPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksRead(requestParameters: DcimApiDcimRacksReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksUpdate(requestParameters: DcimApiDcimRacksUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkUpdate(requestParameters: DcimApiDcimRearPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesCreate(requestParameters: DcimApiDcimRearPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesDelete(requestParameters: DcimApiDcimRearPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesList(requestParameters: DcimApiDcimRearPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.positions, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.positionsN, requestParameters.positionsLte, requestParameters.positionsLt, requestParameters.positionsGte, requestParameters.positionsGt, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesPartialUpdate(requestParameters: DcimApiDcimRearPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesRead(requestParameters: DcimApiDcimRearPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesUpdate(requestParameters: DcimApiDcimRearPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkPartialUpdate(requestParameters: DcimApiDcimRearPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkUpdate(requestParameters: DcimApiDcimRearPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsCreate(requestParameters: DcimApiDcimRearPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsDelete(requestParameters: DcimApiDcimRearPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsList(requestParameters: DcimApiDcimRearPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.positions, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.positionsN, requestParameters.positionsLte, requestParameters.positionsLt, requestParameters.positionsGte, requestParameters.positionsGt, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsPartialUpdate(requestParameters: DcimApiDcimRearPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all CablePaths which traverse a given pass-through port.
     * @param {DcimApiDcimRearPortsPathsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsPaths(requestParameters: DcimApiDcimRearPortsPathsRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsPaths(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsRead(requestParameters: DcimApiDcimRearPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsUpdate(requestParameters: DcimApiDcimRearPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkPartialUpdate(requestParameters: DcimApiDcimRegionsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkUpdate(requestParameters: DcimApiDcimRegionsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsCreate(requestParameters: DcimApiDcimRegionsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsDelete(requestParameters: DcimApiDcimRegionsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsList(requestParameters: DcimApiDcimRegionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.parentId, requestParameters.parent, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.parentIdN, requestParameters.parentN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsPartialUpdate(requestParameters: DcimApiDcimRegionsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsRead(requestParameters: DcimApiDcimRegionsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsUpdate(requestParameters: DcimApiDcimRegionsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkPartialUpdate(requestParameters: DcimApiDcimSitesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkUpdate(requestParameters: DcimApiDcimSitesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesCreate(requestParameters: DcimApiDcimSitesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesDelete(requestParameters: DcimApiDcimSitesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesList(requestParameters: DcimApiDcimSitesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.facility, requestParameters.asn, requestParameters.latitude, requestParameters.longitude, requestParameters.contactName, requestParameters.contactPhone, requestParameters.contactEmail, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.status, requestParameters.regionId, requestParameters.region, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.facilityN, requestParameters.facilityIc, requestParameters.facilityNic, requestParameters.facilityIew, requestParameters.facilityNiew, requestParameters.facilityIsw, requestParameters.facilityNisw, requestParameters.facilityIe, requestParameters.facilityNie, requestParameters.asnN, requestParameters.asnLte, requestParameters.asnLt, requestParameters.asnGte, requestParameters.asnGt, requestParameters.latitudeN, requestParameters.latitudeLte, requestParameters.latitudeLt, requestParameters.latitudeGte, requestParameters.latitudeGt, requestParameters.longitudeN, requestParameters.longitudeLte, requestParameters.longitudeLt, requestParameters.longitudeGte, requestParameters.longitudeGt, requestParameters.contactNameN, requestParameters.contactNameIc, requestParameters.contactNameNic, requestParameters.contactNameIew, requestParameters.contactNameNiew, requestParameters.contactNameIsw, requestParameters.contactNameNisw, requestParameters.contactNameIe, requestParameters.contactNameNie, requestParameters.contactPhoneN, requestParameters.contactPhoneIc, requestParameters.contactPhoneNic, requestParameters.contactPhoneIew, requestParameters.contactPhoneNiew, requestParameters.contactPhoneIsw, requestParameters.contactPhoneNisw, requestParameters.contactPhoneIe, requestParameters.contactPhoneNie, requestParameters.contactEmailN, requestParameters.contactEmailIc, requestParameters.contactEmailNic, requestParameters.contactEmailIew, requestParameters.contactEmailNiew, requestParameters.contactEmailIsw, requestParameters.contactEmailNisw, requestParameters.contactEmailIe, requestParameters.contactEmailNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.statusN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesPartialUpdate(requestParameters: DcimApiDcimSitesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesRead(requestParameters: DcimApiDcimSitesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesUpdate(requestParameters: DcimApiDcimSitesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkPartialUpdate(requestParameters: DcimApiDcimVirtualChassisBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkUpdate(requestParameters: DcimApiDcimVirtualChassisBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisCreate(requestParameters: DcimApiDcimVirtualChassisCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisDelete(requestParameters: DcimApiDcimVirtualChassisDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisList(requestParameters: DcimApiDcimVirtualChassisListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisList(requestParameters.id, requestParameters.domain, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.tenantId, requestParameters.tenant, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.domainN, requestParameters.domainIc, requestParameters.domainNic, requestParameters.domainIew, requestParameters.domainNiew, requestParameters.domainIsw, requestParameters.domainNisw, requestParameters.domainIe, requestParameters.domainNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisPartialUpdate(requestParameters: DcimApiDcimVirtualChassisPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisRead(requestParameters: DcimApiDcimVirtualChassisReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisUpdate(requestParameters: DcimApiDcimVirtualChassisUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ExtrasApi - axios parameter creator
 * @export
 */
export const ExtrasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/config-contexts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkPartialUpdate: async (data: WritableConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasConfigContextsBulkPartialUpdate', 'data', data)
            const localVarPath = `/extras/config-contexts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkUpdate: async (data: WritableConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasConfigContextsBulkUpdate', 'data', data)
            const localVarPath = `/extras/config-contexts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsCreate: async (data: WritableConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasConfigContextsCreate', 'data', data)
            const localVarPath = `/extras/config-contexts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasConfigContextsDelete', 'id', id)
            const localVarPath = `/extras/config-contexts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterId] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterIdN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsList: async (id?: string, name?: string, isActive?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, clusterGroupId?: string, clusterGroup?: string, clusterId?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterIdN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/config-contexts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (platformId !== undefined) {
                localVarQueryParameter['platform_id'] = platformId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (clusterGroupId !== undefined) {
                localVarQueryParameter['cluster_group_id'] = clusterGroupId;
            }

            if (clusterGroup !== undefined) {
                localVarQueryParameter['cluster_group'] = clusterGroup;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (platformIdN !== undefined) {
                localVarQueryParameter['platform_id__n'] = platformIdN;
            }

            if (platformN !== undefined) {
                localVarQueryParameter['platform__n'] = platformN;
            }

            if (clusterGroupIdN !== undefined) {
                localVarQueryParameter['cluster_group_id__n'] = clusterGroupIdN;
            }

            if (clusterGroupN !== undefined) {
                localVarQueryParameter['cluster_group__n'] = clusterGroupN;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsPartialUpdate: async (id: number, data: WritableConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasConfigContextsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasConfigContextsPartialUpdate', 'data', data)
            const localVarPath = `/extras/config-contexts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasConfigContextsRead', 'id', id)
            const localVarPath = `/extras/config-contexts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsUpdate: async (id: number, data: WritableConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasConfigContextsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasConfigContextsUpdate', 'data', data)
            const localVarPath = `/extras/config-contexts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} [id] 
         * @param {string} [appLabel] 
         * @param {string} [model] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasContentTypesList: async (id?: number, appLabel?: string, model?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/content-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (appLabel !== undefined) {
                localVarQueryParameter['app_label'] = appLabel;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} id A unique integer value identifying this content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasContentTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasContentTypesRead', 'id', id)
            const localVarPath = `/extras/content-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/custom-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkPartialUpdate: async (data: WritableCustomField, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasCustomFieldsBulkPartialUpdate', 'data', data)
            const localVarPath = `/extras/custom-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkUpdate: async (data: WritableCustomField, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasCustomFieldsBulkUpdate', 'data', data)
            const localVarPath = `/extras/custom-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsCreate: async (data: WritableCustomField, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasCustomFieldsCreate', 'data', data)
            const localVarPath = `/extras/custom-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasCustomFieldsDelete', 'id', id)
            const localVarPath = `/extras/custom-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [contentTypes] 
         * @param {string} [name] 
         * @param {string} [required] 
         * @param {string} [filterLogic] 
         * @param {number} [weight] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsList: async (id?: number, contentTypes?: string, name?: string, required?: string, filterLogic?: string, weight?: number, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/custom-fields/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (contentTypes !== undefined) {
                localVarQueryParameter['content_types'] = contentTypes;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (required !== undefined) {
                localVarQueryParameter['required'] = required;
            }

            if (filterLogic !== undefined) {
                localVarQueryParameter['filter_logic'] = filterLogic;
            }

            if (weight !== undefined) {
                localVarQueryParameter['weight'] = weight;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsPartialUpdate: async (id: number, data: WritableCustomField, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasCustomFieldsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasCustomFieldsPartialUpdate', 'data', data)
            const localVarPath = `/extras/custom-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasCustomFieldsRead', 'id', id)
            const localVarPath = `/extras/custom-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsUpdate: async (id: number, data: WritableCustomField, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasCustomFieldsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasCustomFieldsUpdate', 'data', data)
            const localVarPath = `/extras/custom-fields/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/export-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkPartialUpdate: async (data: ExportTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasExportTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/extras/export-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkUpdate: async (data: ExportTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasExportTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/extras/export-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesCreate: async (data: ExportTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasExportTemplatesCreate', 'data', data)
            const localVarPath = `/extras/export-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasExportTemplatesDelete', 'id', id)
            const localVarPath = `/extras/export-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesList: async (id?: string, contentType?: string, name?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/export-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (contentTypeN !== undefined) {
                localVarQueryParameter['content_type__n'] = contentTypeN;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesPartialUpdate: async (id: number, data: ExportTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasExportTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasExportTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/extras/export-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasExportTemplatesRead', 'id', id)
            const localVarPath = `/extras/export-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesUpdate: async (id: number, data: ExportTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasExportTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasExportTemplatesUpdate', 'data', data)
            const localVarPath = `/extras/export-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/image-attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkPartialUpdate: async (data: ImageAttachment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasImageAttachmentsBulkPartialUpdate', 'data', data)
            const localVarPath = `/extras/image-attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkUpdate: async (data: ImageAttachment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasImageAttachmentsBulkUpdate', 'data', data)
            const localVarPath = `/extras/image-attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsCreate: async (data: ImageAttachment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasImageAttachmentsCreate', 'data', data)
            const localVarPath = `/extras/image-attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasImageAttachmentsDelete', 'id', id)
            const localVarPath = `/extras/image-attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentTypeId] 
         * @param {string} [objectId] 
         * @param {string} [name] 
         * @param {string} [contentType] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeIdN] 
         * @param {string} [objectIdN] 
         * @param {string} [objectIdLte] 
         * @param {string} [objectIdLt] 
         * @param {string} [objectIdGte] 
         * @param {string} [objectIdGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [contentTypeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsList: async (id?: string, contentTypeId?: string, objectId?: string, name?: string, contentType?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeIdN?: string, objectIdN?: string, objectIdLte?: string, objectIdLt?: string, objectIdGte?: string, objectIdGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, contentTypeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/image-attachments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (contentTypeId !== undefined) {
                localVarQueryParameter['content_type_id'] = contentTypeId;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (contentTypeIdN !== undefined) {
                localVarQueryParameter['content_type_id__n'] = contentTypeIdN;
            }

            if (objectIdN !== undefined) {
                localVarQueryParameter['object_id__n'] = objectIdN;
            }

            if (objectIdLte !== undefined) {
                localVarQueryParameter['object_id__lte'] = objectIdLte;
            }

            if (objectIdLt !== undefined) {
                localVarQueryParameter['object_id__lt'] = objectIdLt;
            }

            if (objectIdGte !== undefined) {
                localVarQueryParameter['object_id__gte'] = objectIdGte;
            }

            if (objectIdGt !== undefined) {
                localVarQueryParameter['object_id__gt'] = objectIdGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (contentTypeN !== undefined) {
                localVarQueryParameter['content_type__n'] = contentTypeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsPartialUpdate: async (id: number, data: ImageAttachment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasImageAttachmentsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasImageAttachmentsPartialUpdate', 'data', data)
            const localVarPath = `/extras/image-attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasImageAttachmentsRead', 'id', id)
            const localVarPath = `/extras/image-attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsUpdate: async (id: number, data: ImageAttachment, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasImageAttachmentsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasImageAttachmentsUpdate', 'data', data)
            const localVarPath = `/extras/image-attachments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of job results
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [completed] 
         * @param {string} [status] 
         * @param {string} [user] 
         * @param {string} [objType] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [statusN] 
         * @param {string} [userN] 
         * @param {string} [objTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasJobResultsList: async (id?: string, created?: string, completed?: string, status?: string, user?: string, objType?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, statusN?: string, userN?: string, objTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/job-results/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (completed !== undefined) {
                localVarQueryParameter['completed'] = completed;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (objType !== undefined) {
                localVarQueryParameter['obj_type'] = objType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (objTypeN !== undefined) {
                localVarQueryParameter['obj_type__n'] = objTypeN;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of job results
         * @param {number} id A unique integer value identifying this job result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasJobResultsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasJobResultsRead', 'id', id)
            const localVarPath = `/extras/job-results/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of recent changes.
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [userName] 
         * @param {string} [requestId] 
         * @param {string} [action] 
         * @param {string} [changedObjectTypeId] 
         * @param {string} [changedObjectId] 
         * @param {string} [objectRepr] 
         * @param {string} [q] 
         * @param {string} [time] 
         * @param {string} [changedObjectType] 
         * @param {string} [userId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [userN] 
         * @param {string} [userNameN] 
         * @param {string} [userNameIc] 
         * @param {string} [userNameNic] 
         * @param {string} [userNameIew] 
         * @param {string} [userNameNiew] 
         * @param {string} [userNameIsw] 
         * @param {string} [userNameNisw] 
         * @param {string} [userNameIe] 
         * @param {string} [userNameNie] 
         * @param {string} [actionN] 
         * @param {string} [changedObjectTypeIdN] 
         * @param {string} [changedObjectIdN] 
         * @param {string} [changedObjectIdLte] 
         * @param {string} [changedObjectIdLt] 
         * @param {string} [changedObjectIdGte] 
         * @param {string} [changedObjectIdGt] 
         * @param {string} [objectReprN] 
         * @param {string} [objectReprIc] 
         * @param {string} [objectReprNic] 
         * @param {string} [objectReprIew] 
         * @param {string} [objectReprNiew] 
         * @param {string} [objectReprIsw] 
         * @param {string} [objectReprNisw] 
         * @param {string} [objectReprIe] 
         * @param {string} [objectReprNie] 
         * @param {string} [changedObjectTypeN] 
         * @param {string} [userIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasObjectChangesList: async (id?: string, user?: string, userName?: string, requestId?: string, action?: string, changedObjectTypeId?: string, changedObjectId?: string, objectRepr?: string, q?: string, time?: string, changedObjectType?: string, userId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, userN?: string, userNameN?: string, userNameIc?: string, userNameNic?: string, userNameIew?: string, userNameNiew?: string, userNameIsw?: string, userNameNisw?: string, userNameIe?: string, userNameNie?: string, actionN?: string, changedObjectTypeIdN?: string, changedObjectIdN?: string, changedObjectIdLte?: string, changedObjectIdLt?: string, changedObjectIdGte?: string, changedObjectIdGt?: string, objectReprN?: string, objectReprIc?: string, objectReprNic?: string, objectReprIew?: string, objectReprNiew?: string, objectReprIsw?: string, objectReprNisw?: string, objectReprIe?: string, objectReprNie?: string, changedObjectTypeN?: string, userIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/object-changes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (userName !== undefined) {
                localVarQueryParameter['user_name'] = userName;
            }

            if (requestId !== undefined) {
                localVarQueryParameter['request_id'] = requestId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (changedObjectTypeId !== undefined) {
                localVarQueryParameter['changed_object_type_id'] = changedObjectTypeId;
            }

            if (changedObjectId !== undefined) {
                localVarQueryParameter['changed_object_id'] = changedObjectId;
            }

            if (objectRepr !== undefined) {
                localVarQueryParameter['object_repr'] = objectRepr;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (time !== undefined) {
                localVarQueryParameter['time'] = time;
            }

            if (changedObjectType !== undefined) {
                localVarQueryParameter['changed_object_type'] = changedObjectType;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (userNameN !== undefined) {
                localVarQueryParameter['user_name__n'] = userNameN;
            }

            if (userNameIc !== undefined) {
                localVarQueryParameter['user_name__ic'] = userNameIc;
            }

            if (userNameNic !== undefined) {
                localVarQueryParameter['user_name__nic'] = userNameNic;
            }

            if (userNameIew !== undefined) {
                localVarQueryParameter['user_name__iew'] = userNameIew;
            }

            if (userNameNiew !== undefined) {
                localVarQueryParameter['user_name__niew'] = userNameNiew;
            }

            if (userNameIsw !== undefined) {
                localVarQueryParameter['user_name__isw'] = userNameIsw;
            }

            if (userNameNisw !== undefined) {
                localVarQueryParameter['user_name__nisw'] = userNameNisw;
            }

            if (userNameIe !== undefined) {
                localVarQueryParameter['user_name__ie'] = userNameIe;
            }

            if (userNameNie !== undefined) {
                localVarQueryParameter['user_name__nie'] = userNameNie;
            }

            if (actionN !== undefined) {
                localVarQueryParameter['action__n'] = actionN;
            }

            if (changedObjectTypeIdN !== undefined) {
                localVarQueryParameter['changed_object_type_id__n'] = changedObjectTypeIdN;
            }

            if (changedObjectIdN !== undefined) {
                localVarQueryParameter['changed_object_id__n'] = changedObjectIdN;
            }

            if (changedObjectIdLte !== undefined) {
                localVarQueryParameter['changed_object_id__lte'] = changedObjectIdLte;
            }

            if (changedObjectIdLt !== undefined) {
                localVarQueryParameter['changed_object_id__lt'] = changedObjectIdLt;
            }

            if (changedObjectIdGte !== undefined) {
                localVarQueryParameter['changed_object_id__gte'] = changedObjectIdGte;
            }

            if (changedObjectIdGt !== undefined) {
                localVarQueryParameter['changed_object_id__gt'] = changedObjectIdGt;
            }

            if (objectReprN !== undefined) {
                localVarQueryParameter['object_repr__n'] = objectReprN;
            }

            if (objectReprIc !== undefined) {
                localVarQueryParameter['object_repr__ic'] = objectReprIc;
            }

            if (objectReprNic !== undefined) {
                localVarQueryParameter['object_repr__nic'] = objectReprNic;
            }

            if (objectReprIew !== undefined) {
                localVarQueryParameter['object_repr__iew'] = objectReprIew;
            }

            if (objectReprNiew !== undefined) {
                localVarQueryParameter['object_repr__niew'] = objectReprNiew;
            }

            if (objectReprIsw !== undefined) {
                localVarQueryParameter['object_repr__isw'] = objectReprIsw;
            }

            if (objectReprNisw !== undefined) {
                localVarQueryParameter['object_repr__nisw'] = objectReprNisw;
            }

            if (objectReprIe !== undefined) {
                localVarQueryParameter['object_repr__ie'] = objectReprIe;
            }

            if (objectReprNie !== undefined) {
                localVarQueryParameter['object_repr__nie'] = objectReprNie;
            }

            if (changedObjectTypeN !== undefined) {
                localVarQueryParameter['changed_object_type__n'] = changedObjectTypeN;
            }

            if (userIdN !== undefined) {
                localVarQueryParameter['user_id__n'] = userIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a list of recent changes.
         * @param {number} id A unique integer value identifying this object change.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasObjectChangesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasObjectChangesRead', 'id', id)
            const localVarPath = `/extras/object-changes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Compile all reports and their related results (if any). Result data is deferred in the list view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/reports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single Report identified as \"<module>.<report>\".
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsRead: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasReportsRead', 'id', id)
            const localVarPath = `/extras/reports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Run a Report identified as \"<module>.<script>\" and return the pending JobResult as the result
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsRun: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasReportsRun', 'id', id)
            const localVarPath = `/extras/reports/{id}/run/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasScriptsList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/scripts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasScriptsRead: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasScriptsRead', 'id', id)
            const localVarPath = `/extras/scripts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkPartialUpdate: async (data: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasTagsBulkPartialUpdate', 'data', data)
            const localVarPath = `/extras/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkUpdate: async (data: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasTagsBulkUpdate', 'data', data)
            const localVarPath = `/extras/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsCreate: async (data: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasTagsCreate', 'data', data)
            const localVarPath = `/extras/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasTagsDelete', 'id', id)
            const localVarPath = `/extras/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsList: async (id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/extras/tags/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (colorIc !== undefined) {
                localVarQueryParameter['color__ic'] = colorIc;
            }

            if (colorNic !== undefined) {
                localVarQueryParameter['color__nic'] = colorNic;
            }

            if (colorIew !== undefined) {
                localVarQueryParameter['color__iew'] = colorIew;
            }

            if (colorNiew !== undefined) {
                localVarQueryParameter['color__niew'] = colorNiew;
            }

            if (colorIsw !== undefined) {
                localVarQueryParameter['color__isw'] = colorIsw;
            }

            if (colorNisw !== undefined) {
                localVarQueryParameter['color__nisw'] = colorNisw;
            }

            if (colorIe !== undefined) {
                localVarQueryParameter['color__ie'] = colorIe;
            }

            if (colorNie !== undefined) {
                localVarQueryParameter['color__nie'] = colorNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsPartialUpdate: async (id: number, data: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasTagsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasTagsPartialUpdate', 'data', data)
            const localVarPath = `/extras/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasTagsRead', 'id', id)
            const localVarPath = `/extras/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsUpdate: async (id: number, data: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extrasTagsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('extrasTagsUpdate', 'data', data)
            const localVarPath = `/extras/tags/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtrasApi - functional programming interface
 * @export
 */
export const ExtrasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtrasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsBulkPartialUpdate(data: WritableConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsBulkUpdate(data: WritableConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsCreate(data: WritableConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterId] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterIdN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsList(id?: string, name?: string, isActive?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, clusterGroupId?: string, clusterGroup?: string, clusterId?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterIdN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20037>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsList(id, name, isActive, q, regionId, region, siteId, site, roleId, role, platformId, platform, clusterGroupId, clusterGroup, clusterId, tenantGroupId, tenantGroup, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, clusterGroupIdN, clusterGroupN, clusterIdN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsPartialUpdate(id: number, data: WritableConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasConfigContextsUpdate(id: number, data: WritableConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasConfigContextsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} [id] 
         * @param {string} [appLabel] 
         * @param {string} [model] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasContentTypesList(id?: number, appLabel?: string, model?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20038>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasContentTypesList(id, appLabel, model, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} id A unique integer value identifying this content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasContentTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContentType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasContentTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsBulkPartialUpdate(data: WritableCustomField, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsBulkUpdate(data: WritableCustomField, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsCreate(data: WritableCustomField, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [contentTypes] 
         * @param {string} [name] 
         * @param {string} [required] 
         * @param {string} [filterLogic] 
         * @param {number} [weight] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsList(id?: number, contentTypes?: string, name?: string, required?: string, filterLogic?: string, weight?: number, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20039>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsList(id, contentTypes, name, required, filterLogic, weight, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsPartialUpdate(id: number, data: WritableCustomField, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasCustomFieldsUpdate(id: number, data: WritableCustomField, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomField>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasCustomFieldsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesBulkPartialUpdate(data: ExportTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesBulkUpdate(data: ExportTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesCreate(data: ExportTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesList(id?: string, contentType?: string, name?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20040>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesList(id, contentType, name, idN, idLte, idLt, idGte, idGt, contentTypeN, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesPartialUpdate(id: number, data: ExportTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasExportTemplatesUpdate(id: number, data: ExportTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExportTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasExportTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsBulkPartialUpdate(data: ImageAttachment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsBulkUpdate(data: ImageAttachment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsCreate(data: ImageAttachment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentTypeId] 
         * @param {string} [objectId] 
         * @param {string} [name] 
         * @param {string} [contentType] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeIdN] 
         * @param {string} [objectIdN] 
         * @param {string} [objectIdLte] 
         * @param {string} [objectIdLt] 
         * @param {string} [objectIdGte] 
         * @param {string} [objectIdGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [contentTypeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsList(id?: string, contentTypeId?: string, objectId?: string, name?: string, contentType?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeIdN?: string, objectIdN?: string, objectIdLte?: string, objectIdLt?: string, objectIdGte?: string, objectIdGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, contentTypeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20041>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsList(id, contentTypeId, objectId, name, contentType, idN, idLte, idLt, idGte, idGt, contentTypeIdN, objectIdN, objectIdLte, objectIdLt, objectIdGte, objectIdGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, contentTypeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsPartialUpdate(id: number, data: ImageAttachment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasImageAttachmentsUpdate(id: number, data: ImageAttachment, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageAttachment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasImageAttachmentsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of job results
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [completed] 
         * @param {string} [status] 
         * @param {string} [user] 
         * @param {string} [objType] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [statusN] 
         * @param {string} [userN] 
         * @param {string} [objTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasJobResultsList(id?: string, created?: string, completed?: string, status?: string, user?: string, objType?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, statusN?: string, userN?: string, objTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20042>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasJobResultsList(id, created, completed, status, user, objType, name, q, idN, idLte, idLt, idGte, idGt, statusN, userN, objTypeN, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of job results
         * @param {number} id A unique integer value identifying this job result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasJobResultsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasJobResultsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of recent changes.
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [userName] 
         * @param {string} [requestId] 
         * @param {string} [action] 
         * @param {string} [changedObjectTypeId] 
         * @param {string} [changedObjectId] 
         * @param {string} [objectRepr] 
         * @param {string} [q] 
         * @param {string} [time] 
         * @param {string} [changedObjectType] 
         * @param {string} [userId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [userN] 
         * @param {string} [userNameN] 
         * @param {string} [userNameIc] 
         * @param {string} [userNameNic] 
         * @param {string} [userNameIew] 
         * @param {string} [userNameNiew] 
         * @param {string} [userNameIsw] 
         * @param {string} [userNameNisw] 
         * @param {string} [userNameIe] 
         * @param {string} [userNameNie] 
         * @param {string} [actionN] 
         * @param {string} [changedObjectTypeIdN] 
         * @param {string} [changedObjectIdN] 
         * @param {string} [changedObjectIdLte] 
         * @param {string} [changedObjectIdLt] 
         * @param {string} [changedObjectIdGte] 
         * @param {string} [changedObjectIdGt] 
         * @param {string} [objectReprN] 
         * @param {string} [objectReprIc] 
         * @param {string} [objectReprNic] 
         * @param {string} [objectReprIew] 
         * @param {string} [objectReprNiew] 
         * @param {string} [objectReprIsw] 
         * @param {string} [objectReprNisw] 
         * @param {string} [objectReprIe] 
         * @param {string} [objectReprNie] 
         * @param {string} [changedObjectTypeN] 
         * @param {string} [userIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasObjectChangesList(id?: string, user?: string, userName?: string, requestId?: string, action?: string, changedObjectTypeId?: string, changedObjectId?: string, objectRepr?: string, q?: string, time?: string, changedObjectType?: string, userId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, userN?: string, userNameN?: string, userNameIc?: string, userNameNic?: string, userNameIew?: string, userNameNiew?: string, userNameIsw?: string, userNameNisw?: string, userNameIe?: string, userNameNie?: string, actionN?: string, changedObjectTypeIdN?: string, changedObjectIdN?: string, changedObjectIdLte?: string, changedObjectIdLt?: string, changedObjectIdGte?: string, changedObjectIdGt?: string, objectReprN?: string, objectReprIc?: string, objectReprNic?: string, objectReprIew?: string, objectReprNiew?: string, objectReprIsw?: string, objectReprNisw?: string, objectReprIe?: string, objectReprNie?: string, changedObjectTypeN?: string, userIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20043>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasObjectChangesList(id, user, userName, requestId, action, changedObjectTypeId, changedObjectId, objectRepr, q, time, changedObjectType, userId, idN, idLte, idLt, idGte, idGt, userN, userNameN, userNameIc, userNameNic, userNameIew, userNameNiew, userNameIsw, userNameNisw, userNameIe, userNameNie, actionN, changedObjectTypeIdN, changedObjectIdN, changedObjectIdLte, changedObjectIdLt, changedObjectIdGte, changedObjectIdGt, objectReprN, objectReprIc, objectReprNic, objectReprIew, objectReprNiew, objectReprIsw, objectReprNisw, objectReprIe, objectReprNie, changedObjectTypeN, userIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a list of recent changes.
         * @param {number} id A unique integer value identifying this object change.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasObjectChangesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectChange>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasObjectChangesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Compile all reports and their related results (if any). Result data is deferred in the list view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasReportsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasReportsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a single Report identified as \"<module>.<report>\".
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasReportsRead(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasReportsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Run a Report identified as \"<module>.<script>\" and return the pending JobResult as the result
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasReportsRun(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasReportsRun(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasScriptsList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasScriptsList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasScriptsRead(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasScriptsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsBulkPartialUpdate(data: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsBulkUpdate(data: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsCreate(data: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20044>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsPartialUpdate(id: number, data: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasTagsUpdate(id: number, data: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasTagsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ExtrasApi - factory interface
 * @export
 */
export const ExtrasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtrasApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.extrasConfigContextsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkPartialUpdate(data: WritableConfigContext, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsBulkUpdate(data: WritableConfigContext, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsCreate(data: WritableConfigContext, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.extrasConfigContextsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterId] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterIdN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsList(id?: string, name?: string, isActive?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, clusterGroupId?: string, clusterGroup?: string, clusterId?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterIdN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20037> {
            return localVarFp.extrasConfigContextsList(id, name, isActive, q, regionId, region, siteId, site, roleId, role, platformId, platform, clusterGroupId, clusterGroup, clusterId, tenantGroupId, tenantGroup, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, clusterGroupIdN, clusterGroupN, clusterIdN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsPartialUpdate(id: number, data: WritableConfigContext, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsRead(id: number, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this config context.
         * @param {WritableConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasConfigContextsUpdate(id: number, data: WritableConfigContext, options?: any): AxiosPromise<ConfigContext> {
            return localVarFp.extrasConfigContextsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} [id] 
         * @param {string} [appLabel] 
         * @param {string} [model] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasContentTypesList(id?: number, appLabel?: string, model?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20038> {
            return localVarFp.extrasContentTypesList(id, appLabel, model, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
         * @param {number} id A unique integer value identifying this content type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasContentTypesRead(id: number, options?: any): AxiosPromise<ContentType> {
            return localVarFp.extrasContentTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.extrasCustomFieldsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkPartialUpdate(data: WritableCustomField, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsBulkUpdate(data: WritableCustomField, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsCreate(data: WritableCustomField, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.extrasCustomFieldsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} [id] 
         * @param {string} [contentTypes] 
         * @param {string} [name] 
         * @param {string} [required] 
         * @param {string} [filterLogic] 
         * @param {number} [weight] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsList(id?: number, contentTypes?: string, name?: string, required?: string, filterLogic?: string, weight?: number, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20039> {
            return localVarFp.extrasCustomFieldsList(id, contentTypes, name, required, filterLogic, weight, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsPartialUpdate(id: number, data: WritableCustomField, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsRead(id: number, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this custom field.
         * @param {WritableCustomField} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasCustomFieldsUpdate(id: number, data: WritableCustomField, options?: any): AxiosPromise<CustomField> {
            return localVarFp.extrasCustomFieldsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.extrasExportTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkPartialUpdate(data: ExportTemplate, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesBulkUpdate(data: ExportTemplate, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesCreate(data: ExportTemplate, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.extrasExportTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentType] 
         * @param {string} [name] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesList(id?: string, contentType?: string, name?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20040> {
            return localVarFp.extrasExportTemplatesList(id, contentType, name, idN, idLte, idLt, idGte, idGt, contentTypeN, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesPartialUpdate(id: number, data: ExportTemplate, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesRead(id: number, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this export template.
         * @param {ExportTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasExportTemplatesUpdate(id: number, data: ExportTemplate, options?: any): AxiosPromise<ExportTemplate> {
            return localVarFp.extrasExportTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.extrasImageAttachmentsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkPartialUpdate(data: ImageAttachment, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsBulkUpdate(data: ImageAttachment, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsCreate(data: ImageAttachment, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.extrasImageAttachmentsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [contentTypeId] 
         * @param {string} [objectId] 
         * @param {string} [name] 
         * @param {string} [contentType] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [contentTypeIdN] 
         * @param {string} [objectIdN] 
         * @param {string} [objectIdLte] 
         * @param {string} [objectIdLt] 
         * @param {string} [objectIdGte] 
         * @param {string} [objectIdGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [contentTypeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsList(id?: string, contentTypeId?: string, objectId?: string, name?: string, contentType?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, contentTypeIdN?: string, objectIdN?: string, objectIdLte?: string, objectIdLt?: string, objectIdGte?: string, objectIdGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, contentTypeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20041> {
            return localVarFp.extrasImageAttachmentsList(id, contentTypeId, objectId, name, contentType, idN, idLte, idLt, idGte, idGt, contentTypeIdN, objectIdN, objectIdLte, objectIdLt, objectIdGte, objectIdGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, contentTypeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsPartialUpdate(id: number, data: ImageAttachment, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsRead(id: number, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this image attachment.
         * @param {ImageAttachment} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasImageAttachmentsUpdate(id: number, data: ImageAttachment, options?: any): AxiosPromise<ImageAttachment> {
            return localVarFp.extrasImageAttachmentsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of job results
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [completed] 
         * @param {string} [status] 
         * @param {string} [user] 
         * @param {string} [objType] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [statusN] 
         * @param {string} [userN] 
         * @param {string} [objTypeN] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasJobResultsList(id?: string, created?: string, completed?: string, status?: string, user?: string, objType?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, statusN?: string, userN?: string, objTypeN?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20042> {
            return localVarFp.extrasJobResultsList(id, created, completed, status, user, objType, name, q, idN, idLte, idLt, idGte, idGt, statusN, userN, objTypeN, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of job results
         * @param {number} id A unique integer value identifying this job result.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasJobResultsRead(id: number, options?: any): AxiosPromise<JobResult> {
            return localVarFp.extrasJobResultsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of recent changes.
         * @param {string} [id] 
         * @param {string} [user] 
         * @param {string} [userName] 
         * @param {string} [requestId] 
         * @param {string} [action] 
         * @param {string} [changedObjectTypeId] 
         * @param {string} [changedObjectId] 
         * @param {string} [objectRepr] 
         * @param {string} [q] 
         * @param {string} [time] 
         * @param {string} [changedObjectType] 
         * @param {string} [userId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [userN] 
         * @param {string} [userNameN] 
         * @param {string} [userNameIc] 
         * @param {string} [userNameNic] 
         * @param {string} [userNameIew] 
         * @param {string} [userNameNiew] 
         * @param {string} [userNameIsw] 
         * @param {string} [userNameNisw] 
         * @param {string} [userNameIe] 
         * @param {string} [userNameNie] 
         * @param {string} [actionN] 
         * @param {string} [changedObjectTypeIdN] 
         * @param {string} [changedObjectIdN] 
         * @param {string} [changedObjectIdLte] 
         * @param {string} [changedObjectIdLt] 
         * @param {string} [changedObjectIdGte] 
         * @param {string} [changedObjectIdGt] 
         * @param {string} [objectReprN] 
         * @param {string} [objectReprIc] 
         * @param {string} [objectReprNic] 
         * @param {string} [objectReprIew] 
         * @param {string} [objectReprNiew] 
         * @param {string} [objectReprIsw] 
         * @param {string} [objectReprNisw] 
         * @param {string} [objectReprIe] 
         * @param {string} [objectReprNie] 
         * @param {string} [changedObjectTypeN] 
         * @param {string} [userIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasObjectChangesList(id?: string, user?: string, userName?: string, requestId?: string, action?: string, changedObjectTypeId?: string, changedObjectId?: string, objectRepr?: string, q?: string, time?: string, changedObjectType?: string, userId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, userN?: string, userNameN?: string, userNameIc?: string, userNameNic?: string, userNameIew?: string, userNameNiew?: string, userNameIsw?: string, userNameNisw?: string, userNameIe?: string, userNameNie?: string, actionN?: string, changedObjectTypeIdN?: string, changedObjectIdN?: string, changedObjectIdLte?: string, changedObjectIdLt?: string, changedObjectIdGte?: string, changedObjectIdGt?: string, objectReprN?: string, objectReprIc?: string, objectReprNic?: string, objectReprIew?: string, objectReprNiew?: string, objectReprIsw?: string, objectReprNisw?: string, objectReprIe?: string, objectReprNie?: string, changedObjectTypeN?: string, userIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20043> {
            return localVarFp.extrasObjectChangesList(id, user, userName, requestId, action, changedObjectTypeId, changedObjectId, objectRepr, q, time, changedObjectType, userId, idN, idLte, idLt, idGte, idGt, userN, userNameN, userNameIc, userNameNic, userNameIew, userNameNiew, userNameIsw, userNameNisw, userNameIe, userNameNie, actionN, changedObjectTypeIdN, changedObjectIdN, changedObjectIdLte, changedObjectIdLt, changedObjectIdGte, changedObjectIdGt, objectReprN, objectReprIc, objectReprNic, objectReprIew, objectReprNiew, objectReprIsw, objectReprNisw, objectReprIe, objectReprNie, changedObjectTypeN, userIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a list of recent changes.
         * @param {number} id A unique integer value identifying this object change.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasObjectChangesRead(id: number, options?: any): AxiosPromise<ObjectChange> {
            return localVarFp.extrasObjectChangesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Compile all reports and their related results (if any). Result data is deferred in the list view.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsList(options?: any): AxiosPromise<void> {
            return localVarFp.extrasReportsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single Report identified as \"<module>.<report>\".
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsRead(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.extrasReportsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Run a Report identified as \"<module>.<script>\" and return the pending JobResult as the result
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasReportsRun(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.extrasReportsRun(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasScriptsList(options?: any): AxiosPromise<void> {
            return localVarFp.extrasScriptsList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasScriptsRead(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.extrasScriptsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.extrasTagsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkPartialUpdate(data: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsBulkUpdate(data: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsCreate(data: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.extrasTagsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20044> {
            return localVarFp.extrasTagsList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsPartialUpdate(id: number, data: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsRead(id: number, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tag.
         * @param {Tag} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasTagsUpdate(id: number, data: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.extrasTagsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for extrasConfigContextsBulkPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsBulkPartialUpdateRequest
 */
export interface ExtrasApiExtrasConfigContextsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConfigContext}
     * @memberof ExtrasApiExtrasConfigContextsBulkPartialUpdate
     */
    readonly data: WritableConfigContext
}

/**
 * Request parameters for extrasConfigContextsBulkUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsBulkUpdateRequest
 */
export interface ExtrasApiExtrasConfigContextsBulkUpdateRequest {
    /**
     * 
     * @type {WritableConfigContext}
     * @memberof ExtrasApiExtrasConfigContextsBulkUpdate
     */
    readonly data: WritableConfigContext
}

/**
 * Request parameters for extrasConfigContextsCreate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsCreateRequest
 */
export interface ExtrasApiExtrasConfigContextsCreateRequest {
    /**
     * 
     * @type {WritableConfigContext}
     * @memberof ExtrasApiExtrasConfigContextsCreate
     */
    readonly data: WritableConfigContext
}

/**
 * Request parameters for extrasConfigContextsDelete operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsDeleteRequest
 */
export interface ExtrasApiExtrasConfigContextsDeleteRequest {
    /**
     * A unique integer value identifying this config context.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsDelete
     */
    readonly id: number
}

/**
 * Request parameters for extrasConfigContextsList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsListRequest
 */
export interface ExtrasApiExtrasConfigContextsListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly isActive?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly platformId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly platform?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterGroup?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly platformIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly platformN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasConfigContextsPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsPartialUpdateRequest
 */
export interface ExtrasApiExtrasConfigContextsPartialUpdateRequest {
    /**
     * A unique integer value identifying this config context.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConfigContext}
     * @memberof ExtrasApiExtrasConfigContextsPartialUpdate
     */
    readonly data: WritableConfigContext
}

/**
 * Request parameters for extrasConfigContextsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsReadRequest
 */
export interface ExtrasApiExtrasConfigContextsReadRequest {
    /**
     * A unique integer value identifying this config context.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasConfigContextsUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasConfigContextsUpdateRequest
 */
export interface ExtrasApiExtrasConfigContextsUpdateRequest {
    /**
     * A unique integer value identifying this config context.
     * @type {number}
     * @memberof ExtrasApiExtrasConfigContextsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConfigContext}
     * @memberof ExtrasApiExtrasConfigContextsUpdate
     */
    readonly data: WritableConfigContext
}

/**
 * Request parameters for extrasContentTypesList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasContentTypesListRequest
 */
export interface ExtrasApiExtrasContentTypesListRequest {
    /**
     * 
     * @type {number}
     * @memberof ExtrasApiExtrasContentTypesList
     */
    readonly id?: number

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasContentTypesList
     */
    readonly appLabel?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasContentTypesList
     */
    readonly model?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasContentTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasContentTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasContentTypesRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasContentTypesReadRequest
 */
export interface ExtrasApiExtrasContentTypesReadRequest {
    /**
     * A unique integer value identifying this content type.
     * @type {number}
     * @memberof ExtrasApiExtrasContentTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasCustomFieldsBulkPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsBulkPartialUpdateRequest
 */
export interface ExtrasApiExtrasCustomFieldsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCustomField}
     * @memberof ExtrasApiExtrasCustomFieldsBulkPartialUpdate
     */
    readonly data: WritableCustomField
}

/**
 * Request parameters for extrasCustomFieldsBulkUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsBulkUpdateRequest
 */
export interface ExtrasApiExtrasCustomFieldsBulkUpdateRequest {
    /**
     * 
     * @type {WritableCustomField}
     * @memberof ExtrasApiExtrasCustomFieldsBulkUpdate
     */
    readonly data: WritableCustomField
}

/**
 * Request parameters for extrasCustomFieldsCreate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsCreateRequest
 */
export interface ExtrasApiExtrasCustomFieldsCreateRequest {
    /**
     * 
     * @type {WritableCustomField}
     * @memberof ExtrasApiExtrasCustomFieldsCreate
     */
    readonly data: WritableCustomField
}

/**
 * Request parameters for extrasCustomFieldsDelete operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsDeleteRequest
 */
export interface ExtrasApiExtrasCustomFieldsDeleteRequest {
    /**
     * A unique integer value identifying this custom field.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsDelete
     */
    readonly id: number
}

/**
 * Request parameters for extrasCustomFieldsList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsListRequest
 */
export interface ExtrasApiExtrasCustomFieldsListRequest {
    /**
     * 
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly id?: number

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly contentTypes?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly required?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly filterLogic?: string

    /**
     * 
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly weight?: number

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasCustomFieldsPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsPartialUpdateRequest
 */
export interface ExtrasApiExtrasCustomFieldsPartialUpdateRequest {
    /**
     * A unique integer value identifying this custom field.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCustomField}
     * @memberof ExtrasApiExtrasCustomFieldsPartialUpdate
     */
    readonly data: WritableCustomField
}

/**
 * Request parameters for extrasCustomFieldsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsReadRequest
 */
export interface ExtrasApiExtrasCustomFieldsReadRequest {
    /**
     * A unique integer value identifying this custom field.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasCustomFieldsUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasCustomFieldsUpdateRequest
 */
export interface ExtrasApiExtrasCustomFieldsUpdateRequest {
    /**
     * A unique integer value identifying this custom field.
     * @type {number}
     * @memberof ExtrasApiExtrasCustomFieldsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCustomField}
     * @memberof ExtrasApiExtrasCustomFieldsUpdate
     */
    readonly data: WritableCustomField
}

/**
 * Request parameters for extrasExportTemplatesBulkPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesBulkPartialUpdateRequest
 */
export interface ExtrasApiExtrasExportTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {ExportTemplate}
     * @memberof ExtrasApiExtrasExportTemplatesBulkPartialUpdate
     */
    readonly data: ExportTemplate
}

/**
 * Request parameters for extrasExportTemplatesBulkUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesBulkUpdateRequest
 */
export interface ExtrasApiExtrasExportTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {ExportTemplate}
     * @memberof ExtrasApiExtrasExportTemplatesBulkUpdate
     */
    readonly data: ExportTemplate
}

/**
 * Request parameters for extrasExportTemplatesCreate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesCreateRequest
 */
export interface ExtrasApiExtrasExportTemplatesCreateRequest {
    /**
     * 
     * @type {ExportTemplate}
     * @memberof ExtrasApiExtrasExportTemplatesCreate
     */
    readonly data: ExportTemplate
}

/**
 * Request parameters for extrasExportTemplatesDelete operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesDeleteRequest
 */
export interface ExtrasApiExtrasExportTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this export template.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for extrasExportTemplatesList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesListRequest
 */
export interface ExtrasApiExtrasExportTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly contentType?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly contentTypeN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasExportTemplatesPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesPartialUpdateRequest
 */
export interface ExtrasApiExtrasExportTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this export template.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ExportTemplate}
     * @memberof ExtrasApiExtrasExportTemplatesPartialUpdate
     */
    readonly data: ExportTemplate
}

/**
 * Request parameters for extrasExportTemplatesRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesReadRequest
 */
export interface ExtrasApiExtrasExportTemplatesReadRequest {
    /**
     * A unique integer value identifying this export template.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasExportTemplatesUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasExportTemplatesUpdateRequest
 */
export interface ExtrasApiExtrasExportTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this export template.
     * @type {number}
     * @memberof ExtrasApiExtrasExportTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ExportTemplate}
     * @memberof ExtrasApiExtrasExportTemplatesUpdate
     */
    readonly data: ExportTemplate
}

/**
 * Request parameters for extrasImageAttachmentsBulkPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsBulkPartialUpdateRequest
 */
export interface ExtrasApiExtrasImageAttachmentsBulkPartialUpdateRequest {
    /**
     * 
     * @type {ImageAttachment}
     * @memberof ExtrasApiExtrasImageAttachmentsBulkPartialUpdate
     */
    readonly data: ImageAttachment
}

/**
 * Request parameters for extrasImageAttachmentsBulkUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsBulkUpdateRequest
 */
export interface ExtrasApiExtrasImageAttachmentsBulkUpdateRequest {
    /**
     * 
     * @type {ImageAttachment}
     * @memberof ExtrasApiExtrasImageAttachmentsBulkUpdate
     */
    readonly data: ImageAttachment
}

/**
 * Request parameters for extrasImageAttachmentsCreate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsCreateRequest
 */
export interface ExtrasApiExtrasImageAttachmentsCreateRequest {
    /**
     * 
     * @type {ImageAttachment}
     * @memberof ExtrasApiExtrasImageAttachmentsCreate
     */
    readonly data: ImageAttachment
}

/**
 * Request parameters for extrasImageAttachmentsDelete operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsDeleteRequest
 */
export interface ExtrasApiExtrasImageAttachmentsDeleteRequest {
    /**
     * A unique integer value identifying this image attachment.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsDelete
     */
    readonly id: number
}

/**
 * Request parameters for extrasImageAttachmentsList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsListRequest
 */
export interface ExtrasApiExtrasImageAttachmentsListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly contentTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly contentType?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly contentTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectIdLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectIdLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectIdGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly objectIdGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly contentTypeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasImageAttachmentsPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsPartialUpdateRequest
 */
export interface ExtrasApiExtrasImageAttachmentsPartialUpdateRequest {
    /**
     * A unique integer value identifying this image attachment.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ImageAttachment}
     * @memberof ExtrasApiExtrasImageAttachmentsPartialUpdate
     */
    readonly data: ImageAttachment
}

/**
 * Request parameters for extrasImageAttachmentsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsReadRequest
 */
export interface ExtrasApiExtrasImageAttachmentsReadRequest {
    /**
     * A unique integer value identifying this image attachment.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasImageAttachmentsUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasImageAttachmentsUpdateRequest
 */
export interface ExtrasApiExtrasImageAttachmentsUpdateRequest {
    /**
     * A unique integer value identifying this image attachment.
     * @type {number}
     * @memberof ExtrasApiExtrasImageAttachmentsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ImageAttachment}
     * @memberof ExtrasApiExtrasImageAttachmentsUpdate
     */
    readonly data: ImageAttachment
}

/**
 * Request parameters for extrasJobResultsList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasJobResultsListRequest
 */
export interface ExtrasApiExtrasJobResultsListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly completed?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly objType?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly objTypeN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasJobResultsList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasJobResultsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasJobResultsReadRequest
 */
export interface ExtrasApiExtrasJobResultsReadRequest {
    /**
     * A unique integer value identifying this job result.
     * @type {number}
     * @memberof ExtrasApiExtrasJobResultsRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasObjectChangesList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasObjectChangesListRequest
 */
export interface ExtrasApiExtrasObjectChangesListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userName?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly requestId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly action?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectRepr?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly time?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectType?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly actionN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectIdN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectIdLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectIdLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectIdGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectIdGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly objectReprNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly changedObjectTypeN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly userIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasObjectChangesList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasObjectChangesRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasObjectChangesReadRequest
 */
export interface ExtrasApiExtrasObjectChangesReadRequest {
    /**
     * A unique integer value identifying this object change.
     * @type {number}
     * @memberof ExtrasApiExtrasObjectChangesRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasReportsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasReportsReadRequest
 */
export interface ExtrasApiExtrasReportsReadRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasReportsRead
     */
    readonly id: string
}

/**
 * Request parameters for extrasReportsRun operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasReportsRunRequest
 */
export interface ExtrasApiExtrasReportsRunRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasReportsRun
     */
    readonly id: string
}

/**
 * Request parameters for extrasScriptsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasScriptsReadRequest
 */
export interface ExtrasApiExtrasScriptsReadRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasScriptsRead
     */
    readonly id: string
}

/**
 * Request parameters for extrasTagsBulkPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsBulkPartialUpdateRequest
 */
export interface ExtrasApiExtrasTagsBulkPartialUpdateRequest {
    /**
     * 
     * @type {Tag}
     * @memberof ExtrasApiExtrasTagsBulkPartialUpdate
     */
    readonly data: Tag
}

/**
 * Request parameters for extrasTagsBulkUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsBulkUpdateRequest
 */
export interface ExtrasApiExtrasTagsBulkUpdateRequest {
    /**
     * 
     * @type {Tag}
     * @memberof ExtrasApiExtrasTagsBulkUpdate
     */
    readonly data: Tag
}

/**
 * Request parameters for extrasTagsCreate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsCreateRequest
 */
export interface ExtrasApiExtrasTagsCreateRequest {
    /**
     * 
     * @type {Tag}
     * @memberof ExtrasApiExtrasTagsCreate
     */
    readonly data: Tag
}

/**
 * Request parameters for extrasTagsDelete operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsDeleteRequest
 */
export interface ExtrasApiExtrasTagsDeleteRequest {
    /**
     * A unique integer value identifying this tag.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsDelete
     */
    readonly id: number
}

/**
 * Request parameters for extrasTagsList operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsListRequest
 */
export interface ExtrasApiExtrasTagsListRequest {
    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorIc?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorNic?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorIew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorNiew?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorIsw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorNisw?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorIe?: string

    /**
     * 
     * @type {string}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly colorNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsList
     */
    readonly offset?: number
}

/**
 * Request parameters for extrasTagsPartialUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsPartialUpdateRequest
 */
export interface ExtrasApiExtrasTagsPartialUpdateRequest {
    /**
     * A unique integer value identifying this tag.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Tag}
     * @memberof ExtrasApiExtrasTagsPartialUpdate
     */
    readonly data: Tag
}

/**
 * Request parameters for extrasTagsRead operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsReadRequest
 */
export interface ExtrasApiExtrasTagsReadRequest {
    /**
     * A unique integer value identifying this tag.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsRead
     */
    readonly id: number
}

/**
 * Request parameters for extrasTagsUpdate operation in ExtrasApi.
 * @export
 * @interface ExtrasApiExtrasTagsUpdateRequest
 */
export interface ExtrasApiExtrasTagsUpdateRequest {
    /**
     * A unique integer value identifying this tag.
     * @type {number}
     * @memberof ExtrasApiExtrasTagsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Tag}
     * @memberof ExtrasApiExtrasTagsUpdate
     */
    readonly data: Tag
}

/**
 * ExtrasApi - object-oriented interface
 * @export
 * @class ExtrasApi
 * @extends {BaseAPI}
 */
export class ExtrasApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsBulkDelete(options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsBulkPartialUpdate(requestParameters: ExtrasApiExtrasConfigContextsBulkPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsBulkUpdate(requestParameters: ExtrasApiExtrasConfigContextsBulkUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsCreate(requestParameters: ExtrasApiExtrasConfigContextsCreateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsDelete(requestParameters: ExtrasApiExtrasConfigContextsDeleteRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsList(requestParameters: ExtrasApiExtrasConfigContextsListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsList(requestParameters.id, requestParameters.name, requestParameters.isActive, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.roleId, requestParameters.role, requestParameters.platformId, requestParameters.platform, requestParameters.clusterGroupId, requestParameters.clusterGroup, requestParameters.clusterId, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.platformIdN, requestParameters.platformN, requestParameters.clusterGroupIdN, requestParameters.clusterGroupN, requestParameters.clusterIdN, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsPartialUpdate(requestParameters: ExtrasApiExtrasConfigContextsPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsRead(requestParameters: ExtrasApiExtrasConfigContextsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasConfigContextsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasConfigContextsUpdate(requestParameters: ExtrasApiExtrasConfigContextsUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasConfigContextsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
     * @param {ExtrasApiExtrasContentTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasContentTypesList(requestParameters: ExtrasApiExtrasContentTypesListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasContentTypesList(requestParameters.id, requestParameters.appLabel, requestParameters.model, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Read-only list of ContentTypes. Limit results to ContentTypes pertinent to NetBox objects.
     * @param {ExtrasApiExtrasContentTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasContentTypesRead(requestParameters: ExtrasApiExtrasContentTypesReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasContentTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsBulkDelete(options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsBulkPartialUpdate(requestParameters: ExtrasApiExtrasCustomFieldsBulkPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsBulkUpdate(requestParameters: ExtrasApiExtrasCustomFieldsBulkUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsCreate(requestParameters: ExtrasApiExtrasCustomFieldsCreateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsDelete(requestParameters: ExtrasApiExtrasCustomFieldsDeleteRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsList(requestParameters: ExtrasApiExtrasCustomFieldsListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsList(requestParameters.id, requestParameters.contentTypes, requestParameters.name, requestParameters.required, requestParameters.filterLogic, requestParameters.weight, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsPartialUpdate(requestParameters: ExtrasApiExtrasCustomFieldsPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsRead(requestParameters: ExtrasApiExtrasCustomFieldsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasCustomFieldsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasCustomFieldsUpdate(requestParameters: ExtrasApiExtrasCustomFieldsUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasCustomFieldsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesBulkDelete(options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesBulkPartialUpdate(requestParameters: ExtrasApiExtrasExportTemplatesBulkPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesBulkUpdate(requestParameters: ExtrasApiExtrasExportTemplatesBulkUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesCreate(requestParameters: ExtrasApiExtrasExportTemplatesCreateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesDelete(requestParameters: ExtrasApiExtrasExportTemplatesDeleteRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesList(requestParameters: ExtrasApiExtrasExportTemplatesListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesList(requestParameters.id, requestParameters.contentType, requestParameters.name, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.contentTypeN, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesPartialUpdate(requestParameters: ExtrasApiExtrasExportTemplatesPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesRead(requestParameters: ExtrasApiExtrasExportTemplatesReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasExportTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasExportTemplatesUpdate(requestParameters: ExtrasApiExtrasExportTemplatesUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasExportTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsBulkDelete(options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsBulkPartialUpdate(requestParameters: ExtrasApiExtrasImageAttachmentsBulkPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsBulkUpdate(requestParameters: ExtrasApiExtrasImageAttachmentsBulkUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsCreate(requestParameters: ExtrasApiExtrasImageAttachmentsCreateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsDelete(requestParameters: ExtrasApiExtrasImageAttachmentsDeleteRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsList(requestParameters: ExtrasApiExtrasImageAttachmentsListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsList(requestParameters.id, requestParameters.contentTypeId, requestParameters.objectId, requestParameters.name, requestParameters.contentType, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.contentTypeIdN, requestParameters.objectIdN, requestParameters.objectIdLte, requestParameters.objectIdLt, requestParameters.objectIdGte, requestParameters.objectIdGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.contentTypeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsPartialUpdate(requestParameters: ExtrasApiExtrasImageAttachmentsPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsRead(requestParameters: ExtrasApiExtrasImageAttachmentsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasImageAttachmentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasImageAttachmentsUpdate(requestParameters: ExtrasApiExtrasImageAttachmentsUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasImageAttachmentsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of job results
     * @param {ExtrasApiExtrasJobResultsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasJobResultsList(requestParameters: ExtrasApiExtrasJobResultsListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasJobResultsList(requestParameters.id, requestParameters.created, requestParameters.completed, requestParameters.status, requestParameters.user, requestParameters.objType, requestParameters.name, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.statusN, requestParameters.userN, requestParameters.objTypeN, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of job results
     * @param {ExtrasApiExtrasJobResultsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasJobResultsRead(requestParameters: ExtrasApiExtrasJobResultsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasJobResultsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of recent changes.
     * @param {ExtrasApiExtrasObjectChangesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasObjectChangesList(requestParameters: ExtrasApiExtrasObjectChangesListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasObjectChangesList(requestParameters.id, requestParameters.user, requestParameters.userName, requestParameters.requestId, requestParameters.action, requestParameters.changedObjectTypeId, requestParameters.changedObjectId, requestParameters.objectRepr, requestParameters.q, requestParameters.time, requestParameters.changedObjectType, requestParameters.userId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.userN, requestParameters.userNameN, requestParameters.userNameIc, requestParameters.userNameNic, requestParameters.userNameIew, requestParameters.userNameNiew, requestParameters.userNameIsw, requestParameters.userNameNisw, requestParameters.userNameIe, requestParameters.userNameNie, requestParameters.actionN, requestParameters.changedObjectTypeIdN, requestParameters.changedObjectIdN, requestParameters.changedObjectIdLte, requestParameters.changedObjectIdLt, requestParameters.changedObjectIdGte, requestParameters.changedObjectIdGt, requestParameters.objectReprN, requestParameters.objectReprIc, requestParameters.objectReprNic, requestParameters.objectReprIew, requestParameters.objectReprNiew, requestParameters.objectReprIsw, requestParameters.objectReprNisw, requestParameters.objectReprIe, requestParameters.objectReprNie, requestParameters.changedObjectTypeN, requestParameters.userIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a list of recent changes.
     * @param {ExtrasApiExtrasObjectChangesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasObjectChangesRead(requestParameters: ExtrasApiExtrasObjectChangesReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasObjectChangesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Compile all reports and their related results (if any). Result data is deferred in the list view.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasReportsList(options?: any) {
        return ExtrasApiFp(this.configuration).extrasReportsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a single Report identified as \"<module>.<report>\".
     * @param {ExtrasApiExtrasReportsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasReportsRead(requestParameters: ExtrasApiExtrasReportsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasReportsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Run a Report identified as \"<module>.<script>\" and return the pending JobResult as the result
     * @param {ExtrasApiExtrasReportsRunRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasReportsRun(requestParameters: ExtrasApiExtrasReportsRunRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasReportsRun(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasScriptsList(options?: any) {
        return ExtrasApiFp(this.configuration).extrasScriptsList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasScriptsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasScriptsRead(requestParameters: ExtrasApiExtrasScriptsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasScriptsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsBulkDelete(options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsBulkPartialUpdate(requestParameters: ExtrasApiExtrasTagsBulkPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsBulkUpdate(requestParameters: ExtrasApiExtrasTagsBulkUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsCreate(requestParameters: ExtrasApiExtrasTagsCreateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsDelete(requestParameters: ExtrasApiExtrasTagsDeleteRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsList(requestParameters: ExtrasApiExtrasTagsListRequest = {}, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.color, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.colorN, requestParameters.colorIc, requestParameters.colorNic, requestParameters.colorIew, requestParameters.colorNiew, requestParameters.colorIsw, requestParameters.colorNisw, requestParameters.colorIe, requestParameters.colorNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsPartialUpdate(requestParameters: ExtrasApiExtrasTagsPartialUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsRead(requestParameters: ExtrasApiExtrasTagsReadRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ExtrasApiExtrasTagsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtrasApi
     */
    public extrasTagsUpdate(requestParameters: ExtrasApiExtrasTagsUpdateRequest, options?: any) {
        return ExtrasApiFp(this.configuration).extrasTagsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IpamApi - axios parameter creator
 * @export
 */
export const IpamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkPartialUpdate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkUpdate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesCreate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesCreate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesDelete', 'id', id)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesList: async (id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dateAdded !== undefined) {
                localVarQueryParameter['date_added'] = dateAdded;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (rirId !== undefined) {
                localVarQueryParameter['rir_id'] = rirId;
            }

            if (rir !== undefined) {
                localVarQueryParameter['rir'] = rir;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (dateAddedN !== undefined) {
                localVarQueryParameter['date_added__n'] = dateAddedN;
            }

            if (dateAddedLte !== undefined) {
                localVarQueryParameter['date_added__lte'] = dateAddedLte;
            }

            if (dateAddedLt !== undefined) {
                localVarQueryParameter['date_added__lt'] = dateAddedLt;
            }

            if (dateAddedGte !== undefined) {
                localVarQueryParameter['date_added__gte'] = dateAddedGte;
            }

            if (dateAddedGt !== undefined) {
                localVarQueryParameter['date_added__gt'] = dateAddedGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (rirIdN !== undefined) {
                localVarQueryParameter['rir_id__n'] = rirIdN;
            }

            if (rirN !== undefined) {
                localVarQueryParameter['rir__n'] = rirN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesPartialUpdate: async (id: number, data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesRead', 'id', id)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesUpdate: async (id: number, data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkPartialUpdate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkUpdate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesCreate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesCreate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesDelete', 'id', id)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesList: async (id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dnsName !== undefined) {
                localVarQueryParameter['dns_name'] = dnsName;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (maskLength !== undefined) {
                localVarQueryParameter['mask_length'] = maskLength;
            }

            if (vrfId !== undefined) {
                localVarQueryParameter['vrf_id'] = vrfId;
            }

            if (vrf !== undefined) {
                localVarQueryParameter['vrf'] = vrf;
            }

            if (presentInVrfId !== undefined) {
                localVarQueryParameter['present_in_vrf_id'] = presentInVrfId;
            }

            if (presentInVrf !== undefined) {
                localVarQueryParameter['present_in_vrf'] = presentInVrf;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (_interface !== undefined) {
                localVarQueryParameter['interface'] = _interface;
            }

            if (interfaceId !== undefined) {
                localVarQueryParameter['interface_id'] = interfaceId;
            }

            if (vminterface !== undefined) {
                localVarQueryParameter['vminterface'] = vminterface;
            }

            if (vminterfaceId !== undefined) {
                localVarQueryParameter['vminterface_id'] = vminterfaceId;
            }

            if (assignedToInterface !== undefined) {
                localVarQueryParameter['assigned_to_interface'] = assignedToInterface;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (dnsNameN !== undefined) {
                localVarQueryParameter['dns_name__n'] = dnsNameN;
            }

            if (dnsNameIc !== undefined) {
                localVarQueryParameter['dns_name__ic'] = dnsNameIc;
            }

            if (dnsNameNic !== undefined) {
                localVarQueryParameter['dns_name__nic'] = dnsNameNic;
            }

            if (dnsNameIew !== undefined) {
                localVarQueryParameter['dns_name__iew'] = dnsNameIew;
            }

            if (dnsNameNiew !== undefined) {
                localVarQueryParameter['dns_name__niew'] = dnsNameNiew;
            }

            if (dnsNameIsw !== undefined) {
                localVarQueryParameter['dns_name__isw'] = dnsNameIsw;
            }

            if (dnsNameNisw !== undefined) {
                localVarQueryParameter['dns_name__nisw'] = dnsNameNisw;
            }

            if (dnsNameIe !== undefined) {
                localVarQueryParameter['dns_name__ie'] = dnsNameIe;
            }

            if (dnsNameNie !== undefined) {
                localVarQueryParameter['dns_name__nie'] = dnsNameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (vrfIdN !== undefined) {
                localVarQueryParameter['vrf_id__n'] = vrfIdN;
            }

            if (vrfN !== undefined) {
                localVarQueryParameter['vrf__n'] = vrfN;
            }

            if (interfaceN !== undefined) {
                localVarQueryParameter['interface__n'] = interfaceN;
            }

            if (interfaceIdN !== undefined) {
                localVarQueryParameter['interface_id__n'] = interfaceIdN;
            }

            if (vminterfaceN !== undefined) {
                localVarQueryParameter['vminterface__n'] = vminterfaceN;
            }

            if (vminterfaceIdN !== undefined) {
                localVarQueryParameter['vminterface_id__n'] = vminterfaceIdN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesPartialUpdate: async (id: number, data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesRead', 'id', id)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesUpdate: async (id: number, data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsCreate: async (id: number, data: WritableAvailableIP, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsCreate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/available-ips/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/available-ips/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesCreate: async (id: number, data: PrefixLength, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesCreate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/available-prefixes/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/available-prefixes/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkPartialUpdate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkUpdate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesCreate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesDelete', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesList: async (id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (isPool !== undefined) {
                localVarQueryParameter['is_pool'] = isPool;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (within !== undefined) {
                localVarQueryParameter['within'] = within;
            }

            if (withinInclude !== undefined) {
                localVarQueryParameter['within_include'] = withinInclude;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (maskLength !== undefined) {
                localVarQueryParameter['mask_length'] = maskLength;
            }

            if (maskLengthGte !== undefined) {
                localVarQueryParameter['mask_length__gte'] = maskLengthGte;
            }

            if (maskLengthLte !== undefined) {
                localVarQueryParameter['mask_length__lte'] = maskLengthLte;
            }

            if (vrfId !== undefined) {
                localVarQueryParameter['vrf_id'] = vrfId;
            }

            if (vrf !== undefined) {
                localVarQueryParameter['vrf'] = vrf;
            }

            if (presentInVrfId !== undefined) {
                localVarQueryParameter['present_in_vrf_id'] = presentInVrfId;
            }

            if (presentInVrf !== undefined) {
                localVarQueryParameter['present_in_vrf'] = presentInVrf;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (vlanId !== undefined) {
                localVarQueryParameter['vlan_id'] = vlanId;
            }

            if (vlanVid !== undefined) {
                localVarQueryParameter['vlan_vid'] = vlanVid;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (vrfIdN !== undefined) {
                localVarQueryParameter['vrf_id__n'] = vrfIdN;
            }

            if (vrfN !== undefined) {
                localVarQueryParameter['vrf__n'] = vrfN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (vlanIdN !== undefined) {
                localVarQueryParameter['vlan_id__n'] = vlanIdN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesPartialUpdate: async (id: number, data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesUpdate: async (id: number, data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkPartialUpdate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkUpdate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsCreate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsCreate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsDelete', 'id', id)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsList: async (id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsPartialUpdate: async (id: number, data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsRead', 'id', id)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsUpdate: async (id: number, data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkPartialUpdate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkUpdate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesCreate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesCreate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesDelete', 'id', id)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesList: async (id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesPartialUpdate: async (id: number, data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesRead', 'id', id)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesUpdate: async (id: number, data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesUpdate', 'data', data)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkPartialUpdate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkUpdate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsCreate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsCreate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsDelete', 'id', id)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsList: async (id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (importingVrfId !== undefined) {
                localVarQueryParameter['importing_vrf_id'] = importingVrfId;
            }

            if (importingVrf !== undefined) {
                localVarQueryParameter['importing_vrf'] = importingVrf;
            }

            if (exportingVrfId !== undefined) {
                localVarQueryParameter['exporting_vrf_id'] = exportingVrfId;
            }

            if (exportingVrf !== undefined) {
                localVarQueryParameter['exporting_vrf'] = exportingVrf;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (importingVrfIdN !== undefined) {
                localVarQueryParameter['importing_vrf_id__n'] = importingVrfIdN;
            }

            if (importingVrfN !== undefined) {
                localVarQueryParameter['importing_vrf__n'] = importingVrfN;
            }

            if (exportingVrfIdN !== undefined) {
                localVarQueryParameter['exporting_vrf_id__n'] = exportingVrfIdN;
            }

            if (exportingVrfN !== undefined) {
                localVarQueryParameter['exporting_vrf__n'] = exportingVrfN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsPartialUpdate: async (id: number, data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsRead', 'id', id)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsUpdate: async (id: number, data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkPartialUpdate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkUpdate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesCreate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesCreate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesDelete', 'id', id)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesList: async (id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (port !== undefined) {
                localVarQueryParameter['port'] = port;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (protocolN !== undefined) {
                localVarQueryParameter['protocol__n'] = protocolN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (virtualMachineIdN !== undefined) {
                localVarQueryParameter['virtual_machine_id__n'] = virtualMachineIdN;
            }

            if (virtualMachineN !== undefined) {
                localVarQueryParameter['virtual_machine__n'] = virtualMachineN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesPartialUpdate: async (id: number, data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesRead', 'id', id)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesUpdate: async (id: number, data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesUpdate', 'data', data)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkPartialUpdate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkUpdate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsCreate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsCreate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsDelete', 'id', id)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsPartialUpdate: async (id: number, data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsRead', 'id', id)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsUpdate: async (id: number, data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkPartialUpdate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkUpdate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansCreate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansCreate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansDelete', 'id', id)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansList: async (id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (vid !== undefined) {
                localVarQueryParameter['vid'] = vid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (vidN !== undefined) {
                localVarQueryParameter['vid__n'] = vidN;
            }

            if (vidLte !== undefined) {
                localVarQueryParameter['vid__lte'] = vidLte;
            }

            if (vidLt !== undefined) {
                localVarQueryParameter['vid__lt'] = vidLt;
            }

            if (vidGte !== undefined) {
                localVarQueryParameter['vid__gte'] = vidGte;
            }

            if (vidGt !== undefined) {
                localVarQueryParameter['vid__gt'] = vidGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansPartialUpdate: async (id: number, data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansRead', 'id', id)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansUpdate: async (id: number, data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkPartialUpdate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkUpdate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsCreate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsCreate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsDelete', 'id', id)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsList: async (id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (rd !== undefined) {
                localVarQueryParameter['rd'] = rd;
            }

            if (enforceUnique !== undefined) {
                localVarQueryParameter['enforce_unique'] = enforceUnique;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (importTargetId !== undefined) {
                localVarQueryParameter['import_target_id'] = importTargetId;
            }

            if (importTarget !== undefined) {
                localVarQueryParameter['import_target'] = importTarget;
            }

            if (exportTargetId !== undefined) {
                localVarQueryParameter['export_target_id'] = exportTargetId;
            }

            if (exportTarget !== undefined) {
                localVarQueryParameter['export_target'] = exportTarget;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (rdN !== undefined) {
                localVarQueryParameter['rd__n'] = rdN;
            }

            if (rdIc !== undefined) {
                localVarQueryParameter['rd__ic'] = rdIc;
            }

            if (rdNic !== undefined) {
                localVarQueryParameter['rd__nic'] = rdNic;
            }

            if (rdIew !== undefined) {
                localVarQueryParameter['rd__iew'] = rdIew;
            }

            if (rdNiew !== undefined) {
                localVarQueryParameter['rd__niew'] = rdNiew;
            }

            if (rdIsw !== undefined) {
                localVarQueryParameter['rd__isw'] = rdIsw;
            }

            if (rdNisw !== undefined) {
                localVarQueryParameter['rd__nisw'] = rdNisw;
            }

            if (rdIe !== undefined) {
                localVarQueryParameter['rd__ie'] = rdIe;
            }

            if (rdNie !== undefined) {
                localVarQueryParameter['rd__nie'] = rdNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (importTargetIdN !== undefined) {
                localVarQueryParameter['import_target_id__n'] = importTargetIdN;
            }

            if (importTargetN !== undefined) {
                localVarQueryParameter['import_target__n'] = importTargetN;
            }

            if (exportTargetIdN !== undefined) {
                localVarQueryParameter['export_target_id__n'] = exportTargetIdN;
            }

            if (exportTargetN !== undefined) {
                localVarQueryParameter['export_target__n'] = exportTargetN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsPartialUpdate: async (id: number, data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsRead', 'id', id)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsUpdate: async (id: number, data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IpamApi - functional programming interface
 * @export
 */
export const IpamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IpamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkPartialUpdate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkUpdate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesCreate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesList(id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesList(id, dateAdded, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, rirId, rir, tag, idN, idLte, idLt, idGte, idGt, dateAddedN, dateAddedLte, dateAddedLt, dateAddedGte, dateAddedGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rirIdN, rirN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesPartialUpdate(id: number, data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesUpdate(id: number, data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkPartialUpdate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkUpdate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesCreate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesList(id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesList(id, dnsName, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, parent, address, maskLength, vrfId, vrf, presentInVrfId, presentInVrf, device, deviceId, virtualMachine, virtualMachineId, _interface, interfaceId, vminterface, vminterfaceId, assignedToInterface, status, role, tag, idN, idLte, idLt, idGte, idGt, dnsNameN, dnsNameIc, dnsNameNic, dnsNameIew, dnsNameNiew, dnsNameIsw, dnsNameNisw, dnsNameIe, dnsNameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, interfaceN, interfaceIdN, vminterfaceN, vminterfaceIdN, statusN, roleN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesPartialUpdate(id: number, data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesUpdate(id: number, data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailableIpsCreate(id: number, data: WritableAvailableIP, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableIP>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailableIpsCreate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailableIpsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableIP>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailableIpsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailablePrefixesCreate(id: number, data: PrefixLength, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailablePrefixesCreate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailablePrefixesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePrefix>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailablePrefixesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkPartialUpdate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkUpdate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesCreate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesList(id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesList(id, isPool, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, within, withinInclude, contains, maskLength, maskLengthGte, maskLengthLte, vrfId, vrf, presentInVrfId, presentInVrf, regionId, region, siteId, site, vlanId, vlanVid, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, regionIdN, regionN, siteIdN, siteN, vlanIdN, roleIdN, roleN, statusN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesPartialUpdate(id: number, data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesUpdate(id: number, data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkPartialUpdate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkUpdate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsCreate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsList(id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsList(id, name, slug, isPrivate, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsPartialUpdate(id: number, data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsUpdate(id: number, data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkPartialUpdate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkUpdate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesCreate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesPartialUpdate(id: number, data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesUpdate(id: number, data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkPartialUpdate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkUpdate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsCreate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importingVrfId, importingVrf, exportingVrfId, exportingVrf, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importingVrfIdN, importingVrfN, exportingVrfIdN, exportingVrfN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsPartialUpdate(id: number, data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsUpdate(id: number, data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkPartialUpdate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkUpdate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesCreate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesList(id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesList(id, name, protocol, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, deviceId, device, virtualMachineId, virtualMachine, port, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, protocolN, deviceIdN, deviceN, virtualMachineIdN, virtualMachineN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesPartialUpdate(id: number, data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesUpdate(id: number, data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkPartialUpdate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkUpdate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsCreate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsList(id, name, slug, description, q, regionId, region, siteId, site, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsPartialUpdate(id: number, data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsUpdate(id: number, data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkPartialUpdate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkUpdate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansCreate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansList(id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansList(id, vid, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, vidN, vidLte, vidLt, vidGte, vidGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, roleIdN, roleN, statusN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansPartialUpdate(id: number, data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansUpdate(id: number, data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkPartialUpdate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkUpdate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsCreate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsList(id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsList(id, name, rd, enforceUnique, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importTargetId, importTarget, exportTargetId, exportTarget, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, rdN, rdIc, rdNic, rdIew, rdNiew, rdIsw, rdNisw, rdIe, rdNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importTargetIdN, importTargetN, exportTargetIdN, exportTargetN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsPartialUpdate(id: number, data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsUpdate(id: number, data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IpamApi - factory interface
 * @export
 */
export const IpamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IpamApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamAggregatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkPartialUpdate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkUpdate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesCreate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamAggregatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesList(id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20045> {
            return localVarFp.ipamAggregatesList(id, dateAdded, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, rirId, rir, tag, idN, idLte, idLt, idGte, idGt, dateAddedN, dateAddedLte, dateAddedLt, dateAddedGte, dateAddedGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rirIdN, rirN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesPartialUpdate(id: number, data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesRead(id: number, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesUpdate(id: number, data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamIpAddressesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkPartialUpdate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkUpdate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesCreate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamIpAddressesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesList(id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20046> {
            return localVarFp.ipamIpAddressesList(id, dnsName, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, parent, address, maskLength, vrfId, vrf, presentInVrfId, presentInVrf, device, deviceId, virtualMachine, virtualMachineId, _interface, interfaceId, vminterface, vminterfaceId, assignedToInterface, status, role, tag, idN, idLte, idLt, idGte, idGt, dnsNameN, dnsNameIc, dnsNameNic, dnsNameIew, dnsNameNiew, dnsNameIsw, dnsNameNisw, dnsNameIe, dnsNameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, interfaceN, interfaceIdN, vminterfaceN, vminterfaceIdN, statusN, roleN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesPartialUpdate(id: number, data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesRead(id: number, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesUpdate(id: number, data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsCreate(id: number, data: WritableAvailableIP, options?: any): AxiosPromise<Array<AvailableIP>> {
            return localVarFp.ipamPrefixesAvailableIpsCreate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsRead(id: number, options?: any): AxiosPromise<Array<AvailableIP>> {
            return localVarFp.ipamPrefixesAvailableIpsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesCreate(id: number, data: PrefixLength, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesAvailablePrefixesCreate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesRead(id: number, options?: any): AxiosPromise<Array<AvailablePrefix>> {
            return localVarFp.ipamPrefixesAvailablePrefixesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamPrefixesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkPartialUpdate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkUpdate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesCreate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamPrefixesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesList(id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.ipamPrefixesList(id, isPool, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, within, withinInclude, contains, maskLength, maskLengthGte, maskLengthLte, vrfId, vrf, presentInVrfId, presentInVrf, regionId, region, siteId, site, vlanId, vlanVid, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, regionIdN, regionN, siteIdN, siteN, vlanIdN, roleIdN, roleN, statusN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesPartialUpdate(id: number, data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesRead(id: number, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesUpdate(id: number, data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRirsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkPartialUpdate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkUpdate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsCreate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRirsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsList(id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.ipamRirsList(id, name, slug, isPrivate, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsPartialUpdate(id: number, data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsRead(id: number, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsUpdate(id: number, data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkPartialUpdate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkUpdate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesCreate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20049> {
            return localVarFp.ipamRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesPartialUpdate(id: number, data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesRead(id: number, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesUpdate(id: number, data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRouteTargetsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkPartialUpdate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkUpdate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsCreate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRouteTargetsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20050> {
            return localVarFp.ipamRouteTargetsList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importingVrfId, importingVrf, exportingVrfId, exportingVrf, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importingVrfIdN, importingVrfN, exportingVrfIdN, exportingVrfN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsPartialUpdate(id: number, data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsRead(id: number, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsUpdate(id: number, data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamServicesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkPartialUpdate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkUpdate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesCreate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamServicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesList(id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20051> {
            return localVarFp.ipamServicesList(id, name, protocol, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, deviceId, device, virtualMachineId, virtualMachine, port, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, protocolN, deviceIdN, deviceN, virtualMachineIdN, virtualMachineN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesPartialUpdate(id: number, data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesRead(id: number, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesUpdate(id: number, data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlanGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkPartialUpdate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkUpdate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsCreate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlanGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20052> {
            return localVarFp.ipamVlanGroupsList(id, name, slug, description, q, regionId, region, siteId, site, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsPartialUpdate(id: number, data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsRead(id: number, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsUpdate(id: number, data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlansBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkPartialUpdate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkUpdate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansCreate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlansDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansList(id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20053> {
            return localVarFp.ipamVlansList(id, vid, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, vidN, vidLte, vidLt, vidGte, vidGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, roleIdN, roleN, statusN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansPartialUpdate(id: number, data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansRead(id: number, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansUpdate(id: number, data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVrfsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkPartialUpdate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkUpdate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsCreate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVrfsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsList(id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20054> {
            return localVarFp.ipamVrfsList(id, name, rd, enforceUnique, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importTargetId, importTarget, exportTargetId, exportTarget, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, rdN, rdIc, rdNic, rdIew, rdNiew, rdIsw, rdNisw, rdIe, rdNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importTargetIdN, importTargetN, exportTargetIdN, exportTargetN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsPartialUpdate(id: number, data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsRead(id: number, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsUpdate(id: number, data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ipamAggregatesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesBulkPartialUpdateRequest
 */
export interface IpamApiIpamAggregatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesBulkPartialUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesBulkUpdateRequest
 */
export interface IpamApiIpamAggregatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesBulkUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesCreateRequest
 */
export interface IpamApiIpamAggregatesCreateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesCreate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesDeleteRequest
 */
export interface IpamApiIpamAggregatesDeleteRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamAggregatesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesListRequest
 */
export interface IpamApiIpamAggregatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAdded?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly prefix?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rir?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamAggregatesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesPartialUpdateRequest
 */
export interface IpamApiIpamAggregatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesPartialUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesReadRequest
 */
export interface IpamApiIpamAggregatesReadRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamAggregatesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesUpdateRequest
 */
export interface IpamApiIpamAggregatesUpdateRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamIpAddressesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesBulkPartialUpdateRequest
 */
export interface IpamApiIpamIpAddressesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesBulkPartialUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesBulkUpdateRequest
 */
export interface IpamApiIpamIpAddressesBulkUpdateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesBulkUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesCreateRequest
 */
export interface IpamApiIpamIpAddressesCreateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesCreate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesDeleteRequest
 */
export interface IpamApiIpamIpAddressesDeleteRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamIpAddressesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesListRequest
 */
export interface IpamApiIpamIpAddressesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsName?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly address?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly maskLength?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly presentInVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly presentInVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly _interface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly assignedToInterface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamIpAddressesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesPartialUpdateRequest
 */
export interface IpamApiIpamIpAddressesPartialUpdateRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesPartialUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesReadRequest
 */
export interface IpamApiIpamIpAddressesReadRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamIpAddressesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesUpdateRequest
 */
export interface IpamApiIpamIpAddressesUpdateRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamPrefixesAvailableIpsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailableIpsCreateRequest
 */
export interface IpamApiIpamPrefixesAvailableIpsCreateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailableIpsCreate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAvailableIP}
     * @memberof IpamApiIpamPrefixesAvailableIpsCreate
     */
    readonly data: WritableAvailableIP
}

/**
 * Request parameters for ipamPrefixesAvailableIpsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailableIpsReadRequest
 */
export interface IpamApiIpamPrefixesAvailableIpsReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailableIpsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesAvailablePrefixesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailablePrefixesCreateRequest
 */
export interface IpamApiIpamPrefixesAvailablePrefixesCreateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesCreate
     */
    readonly id: number

    /**
     * 
     * @type {PrefixLength}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesCreate
     */
    readonly data: PrefixLength
}

/**
 * Request parameters for ipamPrefixesAvailablePrefixesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailablePrefixesReadRequest
 */
export interface IpamApiIpamPrefixesAvailablePrefixesReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesBulkPartialUpdateRequest
 */
export interface IpamApiIpamPrefixesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesBulkPartialUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesBulkUpdateRequest
 */
export interface IpamApiIpamPrefixesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesBulkUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesCreateRequest
 */
export interface IpamApiIpamPrefixesCreateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesCreate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesDeleteRequest
 */
export interface IpamApiIpamPrefixesDeleteRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesListRequest
 */
export interface IpamApiIpamPrefixesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly isPool?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly prefix?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly within?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly withinInclude?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly contains?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLength?: number

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLengthGte?: number

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLengthLte?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly presentInVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly presentInVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanId?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanVid?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamPrefixesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesPartialUpdateRequest
 */
export interface IpamApiIpamPrefixesPartialUpdateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesPartialUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesReadRequest
 */
export interface IpamApiIpamPrefixesReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesUpdateRequest
 */
export interface IpamApiIpamPrefixesUpdateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamRirsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsBulkPartialUpdateRequest
 */
export interface IpamApiIpamRirsBulkPartialUpdateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsBulkPartialUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsBulkUpdateRequest
 */
export interface IpamApiIpamRirsBulkUpdateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsBulkUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsCreateRequest
 */
export interface IpamApiIpamRirsCreateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsCreate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsDeleteRequest
 */
export interface IpamApiIpamRirsDeleteRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRirsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsListRequest
 */
export interface IpamApiIpamRirsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly isPrivate?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRirsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRirsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRirsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsPartialUpdateRequest
 */
export interface IpamApiIpamRirsPartialUpdateRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsPartialUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsReadRequest
 */
export interface IpamApiIpamRirsReadRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRirsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsUpdateRequest
 */
export interface IpamApiIpamRirsUpdateRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRolesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesBulkPartialUpdateRequest
 */
export interface IpamApiIpamRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesBulkPartialUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesBulkUpdateRequest
 */
export interface IpamApiIpamRolesBulkUpdateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesBulkUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesCreateRequest
 */
export interface IpamApiIpamRolesCreateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesCreate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesDeleteRequest
 */
export interface IpamApiIpamRolesDeleteRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRolesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesListRequest
 */
export interface IpamApiIpamRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRolesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesPartialUpdateRequest
 */
export interface IpamApiIpamRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesPartialUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesReadRequest
 */
export interface IpamApiIpamRolesReadRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRolesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesUpdateRequest
 */
export interface IpamApiIpamRolesUpdateRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRouteTargetsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsBulkPartialUpdateRequest
 */
export interface IpamApiIpamRouteTargetsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsBulkPartialUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsBulkUpdateRequest
 */
export interface IpamApiIpamRouteTargetsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsBulkUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsCreateRequest
 */
export interface IpamApiIpamRouteTargetsCreateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsCreate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsDeleteRequest
 */
export interface IpamApiIpamRouteTargetsDeleteRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRouteTargetsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsListRequest
 */
export interface IpamApiIpamRouteTargetsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRouteTargetsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsPartialUpdateRequest
 */
export interface IpamApiIpamRouteTargetsPartialUpdateRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsPartialUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsReadRequest
 */
export interface IpamApiIpamRouteTargetsReadRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRouteTargetsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsUpdateRequest
 */
export interface IpamApiIpamRouteTargetsUpdateRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamServicesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesBulkPartialUpdateRequest
 */
export interface IpamApiIpamServicesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesBulkPartialUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesBulkUpdateRequest
 */
export interface IpamApiIpamServicesBulkUpdateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesBulkUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesCreateRequest
 */
export interface IpamApiIpamServicesCreateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesCreate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesDeleteRequest
 */
export interface IpamApiIpamServicesDeleteRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamServicesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesListRequest
 */
export interface IpamApiIpamServicesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly protocol?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly port?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly protocolN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamServicesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesPartialUpdateRequest
 */
export interface IpamApiIpamServicesPartialUpdateRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesPartialUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesReadRequest
 */
export interface IpamApiIpamServicesReadRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamServicesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesUpdateRequest
 */
export interface IpamApiIpamServicesUpdateRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamVlanGroupsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsBulkPartialUpdateRequest
 */
export interface IpamApiIpamVlanGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsBulkPartialUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsBulkUpdateRequest
 */
export interface IpamApiIpamVlanGroupsBulkUpdateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsBulkUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsCreateRequest
 */
export interface IpamApiIpamVlanGroupsCreateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsCreate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsDeleteRequest
 */
export interface IpamApiIpamVlanGroupsDeleteRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlanGroupsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsListRequest
 */
export interface IpamApiIpamVlanGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVlanGroupsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsPartialUpdateRequest
 */
export interface IpamApiIpamVlanGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsPartialUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsReadRequest
 */
export interface IpamApiIpamVlanGroupsReadRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlanGroupsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsUpdateRequest
 */
export interface IpamApiIpamVlanGroupsUpdateRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlansBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansBulkPartialUpdateRequest
 */
export interface IpamApiIpamVlansBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansBulkPartialUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansBulkUpdateRequest
 */
export interface IpamApiIpamVlansBulkUpdateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansBulkUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansCreateRequest
 */
export interface IpamApiIpamVlansCreateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansCreate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansDeleteRequest
 */
export interface IpamApiIpamVlansDeleteRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlansList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansListRequest
 */
export interface IpamApiIpamVlansListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vid?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVlansList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVlansList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVlansPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansPartialUpdateRequest
 */
export interface IpamApiIpamVlansPartialUpdateRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansPartialUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansReadRequest
 */
export interface IpamApiIpamVlansReadRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlansUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansUpdateRequest
 */
export interface IpamApiIpamVlansUpdateRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVrfsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsBulkPartialUpdateRequest
 */
export interface IpamApiIpamVrfsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsBulkPartialUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsBulkUpdateRequest
 */
export interface IpamApiIpamVrfsBulkUpdateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsBulkUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsCreateRequest
 */
export interface IpamApiIpamVrfsCreateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsCreate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsDeleteRequest
 */
export interface IpamApiIpamVrfsDeleteRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVrfsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsListRequest
 */
export interface IpamApiIpamVrfsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rd?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly enforceUnique?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTarget?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTarget?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVrfsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVrfsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVrfsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsPartialUpdateRequest
 */
export interface IpamApiIpamVrfsPartialUpdateRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsPartialUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsReadRequest
 */
export interface IpamApiIpamVrfsReadRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVrfsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsUpdateRequest
 */
export interface IpamApiIpamVrfsUpdateRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsUpdate
     */
    readonly data: WritableVRF
}

/**
 * IpamApi - object-oriented interface
 * @export
 * @class IpamApi
 * @extends {BaseAPI}
 */
export class IpamApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkPartialUpdate(requestParameters: IpamApiIpamAggregatesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkUpdate(requestParameters: IpamApiIpamAggregatesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesCreate(requestParameters: IpamApiIpamAggregatesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesDelete(requestParameters: IpamApiIpamAggregatesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesList(requestParameters: IpamApiIpamAggregatesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesList(requestParameters.id, requestParameters.dateAdded, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.prefix, requestParameters.rirId, requestParameters.rir, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.dateAddedN, requestParameters.dateAddedLte, requestParameters.dateAddedLt, requestParameters.dateAddedGte, requestParameters.dateAddedGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.rirIdN, requestParameters.rirN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesPartialUpdate(requestParameters: IpamApiIpamAggregatesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesRead(requestParameters: IpamApiIpamAggregatesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesUpdate(requestParameters: IpamApiIpamAggregatesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkPartialUpdate(requestParameters: IpamApiIpamIpAddressesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkUpdate(requestParameters: IpamApiIpamIpAddressesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesCreate(requestParameters: IpamApiIpamIpAddressesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesDelete(requestParameters: IpamApiIpamIpAddressesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesList(requestParameters: IpamApiIpamIpAddressesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesList(requestParameters.id, requestParameters.dnsName, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.parent, requestParameters.address, requestParameters.maskLength, requestParameters.vrfId, requestParameters.vrf, requestParameters.presentInVrfId, requestParameters.presentInVrf, requestParameters.device, requestParameters.deviceId, requestParameters.virtualMachine, requestParameters.virtualMachineId, requestParameters._interface, requestParameters.interfaceId, requestParameters.vminterface, requestParameters.vminterfaceId, requestParameters.assignedToInterface, requestParameters.status, requestParameters.role, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.dnsNameN, requestParameters.dnsNameIc, requestParameters.dnsNameNic, requestParameters.dnsNameIew, requestParameters.dnsNameNiew, requestParameters.dnsNameIsw, requestParameters.dnsNameNisw, requestParameters.dnsNameIe, requestParameters.dnsNameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.vrfIdN, requestParameters.vrfN, requestParameters.interfaceN, requestParameters.interfaceIdN, requestParameters.vminterfaceN, requestParameters.vminterfaceIdN, requestParameters.statusN, requestParameters.roleN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesPartialUpdate(requestParameters: IpamApiIpamIpAddressesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesRead(requestParameters: IpamApiIpamIpAddressesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesUpdate(requestParameters: IpamApiIpamIpAddressesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @param {IpamApiIpamPrefixesAvailableIpsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailableIpsCreate(requestParameters: IpamApiIpamPrefixesAvailableIpsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailableIpsCreate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @param {IpamApiIpamPrefixesAvailableIpsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailableIpsRead(requestParameters: IpamApiIpamPrefixesAvailableIpsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailableIpsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @summary A convenience method for returning available child prefixes within a parent.
     * @param {IpamApiIpamPrefixesAvailablePrefixesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailablePrefixesCreate(requestParameters: IpamApiIpamPrefixesAvailablePrefixesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailablePrefixesCreate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @summary A convenience method for returning available child prefixes within a parent.
     * @param {IpamApiIpamPrefixesAvailablePrefixesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailablePrefixesRead(requestParameters: IpamApiIpamPrefixesAvailablePrefixesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailablePrefixesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkPartialUpdate(requestParameters: IpamApiIpamPrefixesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkUpdate(requestParameters: IpamApiIpamPrefixesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesCreate(requestParameters: IpamApiIpamPrefixesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesDelete(requestParameters: IpamApiIpamPrefixesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesList(requestParameters: IpamApiIpamPrefixesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesList(requestParameters.id, requestParameters.isPool, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.prefix, requestParameters.within, requestParameters.withinInclude, requestParameters.contains, requestParameters.maskLength, requestParameters.maskLengthGte, requestParameters.maskLengthLte, requestParameters.vrfId, requestParameters.vrf, requestParameters.presentInVrfId, requestParameters.presentInVrf, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.vlanId, requestParameters.vlanVid, requestParameters.roleId, requestParameters.role, requestParameters.status, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.vrfIdN, requestParameters.vrfN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.vlanIdN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.statusN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesPartialUpdate(requestParameters: IpamApiIpamPrefixesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesRead(requestParameters: IpamApiIpamPrefixesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesUpdate(requestParameters: IpamApiIpamPrefixesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkPartialUpdate(requestParameters: IpamApiIpamRirsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkUpdate(requestParameters: IpamApiIpamRirsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsCreate(requestParameters: IpamApiIpamRirsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsDelete(requestParameters: IpamApiIpamRirsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsList(requestParameters: IpamApiIpamRirsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.isPrivate, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsPartialUpdate(requestParameters: IpamApiIpamRirsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsRead(requestParameters: IpamApiIpamRirsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsUpdate(requestParameters: IpamApiIpamRirsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkPartialUpdate(requestParameters: IpamApiIpamRolesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkUpdate(requestParameters: IpamApiIpamRolesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesCreate(requestParameters: IpamApiIpamRolesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesDelete(requestParameters: IpamApiIpamRolesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesList(requestParameters: IpamApiIpamRolesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesPartialUpdate(requestParameters: IpamApiIpamRolesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesRead(requestParameters: IpamApiIpamRolesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesUpdate(requestParameters: IpamApiIpamRolesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkPartialUpdate(requestParameters: IpamApiIpamRouteTargetsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkUpdate(requestParameters: IpamApiIpamRouteTargetsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsCreate(requestParameters: IpamApiIpamRouteTargetsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsDelete(requestParameters: IpamApiIpamRouteTargetsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsList(requestParameters: IpamApiIpamRouteTargetsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsList(requestParameters.id, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.importingVrfId, requestParameters.importingVrf, requestParameters.exportingVrfId, requestParameters.exportingVrf, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.importingVrfIdN, requestParameters.importingVrfN, requestParameters.exportingVrfIdN, requestParameters.exportingVrfN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsPartialUpdate(requestParameters: IpamApiIpamRouteTargetsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsRead(requestParameters: IpamApiIpamRouteTargetsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsUpdate(requestParameters: IpamApiIpamRouteTargetsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkPartialUpdate(requestParameters: IpamApiIpamServicesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkUpdate(requestParameters: IpamApiIpamServicesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesCreate(requestParameters: IpamApiIpamServicesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesDelete(requestParameters: IpamApiIpamServicesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesList(requestParameters: IpamApiIpamServicesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesList(requestParameters.id, requestParameters.name, requestParameters.protocol, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.deviceId, requestParameters.device, requestParameters.virtualMachineId, requestParameters.virtualMachine, requestParameters.port, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.protocolN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.virtualMachineIdN, requestParameters.virtualMachineN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesPartialUpdate(requestParameters: IpamApiIpamServicesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesRead(requestParameters: IpamApiIpamServicesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesUpdate(requestParameters: IpamApiIpamServicesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkPartialUpdate(requestParameters: IpamApiIpamVlanGroupsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkUpdate(requestParameters: IpamApiIpamVlanGroupsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsCreate(requestParameters: IpamApiIpamVlanGroupsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsDelete(requestParameters: IpamApiIpamVlanGroupsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsList(requestParameters: IpamApiIpamVlanGroupsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsPartialUpdate(requestParameters: IpamApiIpamVlanGroupsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsRead(requestParameters: IpamApiIpamVlanGroupsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsUpdate(requestParameters: IpamApiIpamVlanGroupsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkPartialUpdate(requestParameters: IpamApiIpamVlansBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkUpdate(requestParameters: IpamApiIpamVlansBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansCreate(requestParameters: IpamApiIpamVlansCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansDelete(requestParameters: IpamApiIpamVlansDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansList(requestParameters: IpamApiIpamVlansListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansList(requestParameters.id, requestParameters.vid, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.roleId, requestParameters.role, requestParameters.status, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.vidN, requestParameters.vidLte, requestParameters.vidLt, requestParameters.vidGte, requestParameters.vidGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.statusN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansPartialUpdate(requestParameters: IpamApiIpamVlansPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansRead(requestParameters: IpamApiIpamVlansReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansUpdate(requestParameters: IpamApiIpamVlansUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkPartialUpdate(requestParameters: IpamApiIpamVrfsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkUpdate(requestParameters: IpamApiIpamVrfsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsCreate(requestParameters: IpamApiIpamVrfsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsDelete(requestParameters: IpamApiIpamVrfsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsList(requestParameters: IpamApiIpamVrfsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsList(requestParameters.id, requestParameters.name, requestParameters.rd, requestParameters.enforceUnique, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.importTargetId, requestParameters.importTarget, requestParameters.exportTargetId, requestParameters.exportTarget, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.rdN, requestParameters.rdIc, requestParameters.rdNic, requestParameters.rdIew, requestParameters.rdNiew, requestParameters.rdIsw, requestParameters.rdNisw, requestParameters.rdIe, requestParameters.rdNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.importTargetIdN, requestParameters.importTargetN, requestParameters.exportTargetIdN, requestParameters.exportTargetN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsPartialUpdate(requestParameters: IpamApiIpamVrfsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsRead(requestParameters: IpamApiIpamVrfsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsUpdate(requestParameters: IpamApiIpamVrfsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SecretsApi - axios parameter creator
 * @export
 */
export const SecretsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * {         \"public_key\": \"<public key>\",         \"private_key\": \"<private key>\"     }
         * @summary This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsGenerateRsaKeyPairList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/generate-rsa-key-pair/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user\'s private RSA key is POSTed with the name `private_key`. An example:      curl -v -X POST -H \"Authorization: Token <token>\" -H \"Accept: application/json; indent=4\" \\     --data-urlencode \"private_key@<filename>\" https://netbox/api/secrets/get-session-key/  This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:      {         \"session_key\": \"+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf=\"     }  This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session key will be returned instead of a new one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsGetSessionKeyCreate: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/get-session-key/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/secret-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkPartialUpdate: async (data: SecretRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/secrets/secret-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkUpdate: async (data: SecretRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretRolesBulkUpdate', 'data', data)
            const localVarPath = `/secrets/secret-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesCreate: async (data: SecretRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretRolesCreate', 'data', data)
            const localVarPath = `/secrets/secret-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretRolesDelete', 'id', id)
            const localVarPath = `/secrets/secret-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesList: async (id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/secret-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesPartialUpdate: async (id: number, data: SecretRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretRolesPartialUpdate', 'data', data)
            const localVarPath = `/secrets/secret-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretRolesRead', 'id', id)
            const localVarPath = `/secrets/secret-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesUpdate: async (id: number, data: SecretRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretRolesUpdate', 'data', data)
            const localVarPath = `/secrets/secret-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/secrets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkPartialUpdate: async (data: WritableSecret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretsBulkPartialUpdate', 'data', data)
            const localVarPath = `/secrets/secrets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkUpdate: async (data: WritableSecret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretsBulkUpdate', 'data', data)
            const localVarPath = `/secrets/secrets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsCreate: async (data: WritableSecret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretsCreate', 'data', data)
            const localVarPath = `/secrets/secrets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretsDelete', 'id', id)
            const localVarPath = `/secrets/secrets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [deviceN] 
         * @param {string} [deviceIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsList: async (id?: string, name?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, roleId?: string, role?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, roleIdN?: string, roleN?: string, deviceN?: string, deviceIdN?: string, virtualMachineN?: string, virtualMachineIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/secrets/secrets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (virtualMachineN !== undefined) {
                localVarQueryParameter['virtual_machine__n'] = virtualMachineN;
            }

            if (virtualMachineIdN !== undefined) {
                localVarQueryParameter['virtual_machine_id__n'] = virtualMachineIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsPartialUpdate: async (id: number, data: WritableSecret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretsPartialUpdate', 'data', data)
            const localVarPath = `/secrets/secrets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretsRead', 'id', id)
            const localVarPath = `/secrets/secrets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsUpdate: async (id: number, data: WritableSecret, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('secretsSecretsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('secretsSecretsUpdate', 'data', data)
            const localVarPath = `/secrets/secrets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecretsApi - functional programming interface
 * @export
 */
export const SecretsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecretsApiAxiosParamCreator(configuration)
    return {
        /**
         * {         \"public_key\": \"<public key>\",         \"private_key\": \"<private key>\"     }
         * @summary This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsGenerateRsaKeyPairList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsGenerateRsaKeyPairList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user\'s private RSA key is POSTed with the name `private_key`. An example:      curl -v -X POST -H \"Authorization: Token <token>\" -H \"Accept: application/json; indent=4\" \\     --data-urlencode \"private_key@<filename>\" https://netbox/api/secrets/get-session-key/  This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:      {         \"session_key\": \"+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf=\"     }  This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session key will be returned instead of a new one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsGetSessionKeyCreate(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsGetSessionKeyCreate(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesBulkPartialUpdate(data: SecretRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesBulkUpdate(data: SecretRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesCreate(data: SecretRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20055>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesPartialUpdate(id: number, data: SecretRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretRolesUpdate(id: number, data: SecretRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecretRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsBulkPartialUpdate(data: WritableSecret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsBulkUpdate(data: WritableSecret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsCreate(data: WritableSecret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [deviceN] 
         * @param {string} [deviceIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsList(id?: string, name?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, roleId?: string, role?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, roleIdN?: string, roleN?: string, deviceN?: string, deviceIdN?: string, virtualMachineN?: string, virtualMachineIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20056>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsList(id, name, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, roleId, role, device, deviceId, virtualMachine, virtualMachineId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, roleIdN, roleN, deviceN, deviceIdN, virtualMachineN, virtualMachineIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsPartialUpdate(id: number, data: WritableSecret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async secretsSecretsUpdate(id: number, data: WritableSecret, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Secret>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.secretsSecretsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SecretsApi - factory interface
 * @export
 */
export const SecretsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecretsApiFp(configuration)
    return {
        /**
         * {         \"public_key\": \"<public key>\",         \"private_key\": \"<private key>\"     }
         * @summary This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsGenerateRsaKeyPairList(options?: any): AxiosPromise<void> {
            return localVarFp.secretsGenerateRsaKeyPairList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user\'s private RSA key is POSTed with the name `private_key`. An example:      curl -v -X POST -H \"Authorization: Token <token>\" -H \"Accept: application/json; indent=4\" \\     --data-urlencode \"private_key@<filename>\" https://netbox/api/secrets/get-session-key/  This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:      {         \"session_key\": \"+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf=\"     }  This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session key will be returned instead of a new one.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsGetSessionKeyCreate(options?: any): AxiosPromise<void> {
            return localVarFp.secretsGetSessionKeyCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.secretsSecretRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkPartialUpdate(data: SecretRole, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesBulkUpdate(data: SecretRole, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesCreate(data: SecretRole, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.secretsSecretRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20055> {
            return localVarFp.secretsSecretRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesPartialUpdate(id: number, data: SecretRole, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesRead(id: number, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret role.
         * @param {SecretRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretRolesUpdate(id: number, data: SecretRole, options?: any): AxiosPromise<SecretRole> {
            return localVarFp.secretsSecretRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.secretsSecretsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkPartialUpdate(data: WritableSecret, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsBulkUpdate(data: WritableSecret, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsCreate(data: WritableSecret, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.secretsSecretsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [deviceN] 
         * @param {string} [deviceIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsList(id?: string, name?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, roleId?: string, role?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, roleIdN?: string, roleN?: string, deviceN?: string, deviceIdN?: string, virtualMachineN?: string, virtualMachineIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20056> {
            return localVarFp.secretsSecretsList(id, name, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, roleId, role, device, deviceId, virtualMachine, virtualMachineId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, roleIdN, roleN, deviceN, deviceIdN, virtualMachineN, virtualMachineIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsPartialUpdate(id: number, data: WritableSecret, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsRead(id: number, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this secret.
         * @param {WritableSecret} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        secretsSecretsUpdate(id: number, data: WritableSecret, options?: any): AxiosPromise<Secret> {
            return localVarFp.secretsSecretsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for secretsSecretRolesBulkPartialUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesBulkPartialUpdateRequest
 */
export interface SecretsApiSecretsSecretRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {SecretRole}
     * @memberof SecretsApiSecretsSecretRolesBulkPartialUpdate
     */
    readonly data: SecretRole
}

/**
 * Request parameters for secretsSecretRolesBulkUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesBulkUpdateRequest
 */
export interface SecretsApiSecretsSecretRolesBulkUpdateRequest {
    /**
     * 
     * @type {SecretRole}
     * @memberof SecretsApiSecretsSecretRolesBulkUpdate
     */
    readonly data: SecretRole
}

/**
 * Request parameters for secretsSecretRolesCreate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesCreateRequest
 */
export interface SecretsApiSecretsSecretRolesCreateRequest {
    /**
     * 
     * @type {SecretRole}
     * @memberof SecretsApiSecretsSecretRolesCreate
     */
    readonly data: SecretRole
}

/**
 * Request parameters for secretsSecretRolesDelete operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesDeleteRequest
 */
export interface SecretsApiSecretsSecretRolesDeleteRequest {
    /**
     * A unique integer value identifying this secret role.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for secretsSecretRolesList operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesListRequest
 */
export interface SecretsApiSecretsSecretRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly slugNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for secretsSecretRolesPartialUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesPartialUpdateRequest
 */
export interface SecretsApiSecretsSecretRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this secret role.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {SecretRole}
     * @memberof SecretsApiSecretsSecretRolesPartialUpdate
     */
    readonly data: SecretRole
}

/**
 * Request parameters for secretsSecretRolesRead operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesReadRequest
 */
export interface SecretsApiSecretsSecretRolesReadRequest {
    /**
     * A unique integer value identifying this secret role.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for secretsSecretRolesUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretRolesUpdateRequest
 */
export interface SecretsApiSecretsSecretRolesUpdateRequest {
    /**
     * A unique integer value identifying this secret role.
     * @type {number}
     * @memberof SecretsApiSecretsSecretRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {SecretRole}
     * @memberof SecretsApiSecretsSecretRolesUpdate
     */
    readonly data: SecretRole
}

/**
 * Request parameters for secretsSecretsBulkPartialUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsBulkPartialUpdateRequest
 */
export interface SecretsApiSecretsSecretsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableSecret}
     * @memberof SecretsApiSecretsSecretsBulkPartialUpdate
     */
    readonly data: WritableSecret
}

/**
 * Request parameters for secretsSecretsBulkUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsBulkUpdateRequest
 */
export interface SecretsApiSecretsSecretsBulkUpdateRequest {
    /**
     * 
     * @type {WritableSecret}
     * @memberof SecretsApiSecretsSecretsBulkUpdate
     */
    readonly data: WritableSecret
}

/**
 * Request parameters for secretsSecretsCreate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsCreateRequest
 */
export interface SecretsApiSecretsSecretsCreateRequest {
    /**
     * 
     * @type {WritableSecret}
     * @memberof SecretsApiSecretsSecretsCreate
     */
    readonly data: WritableSecret
}

/**
 * Request parameters for secretsSecretsDelete operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsDeleteRequest
 */
export interface SecretsApiSecretsSecretsDeleteRequest {
    /**
     * A unique integer value identifying this secret.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsDelete
     */
    readonly id: number
}

/**
 * Request parameters for secretsSecretsList operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsListRequest
 */
export interface SecretsApiSecretsSecretsListRequest {
    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly virtualMachineN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly virtualMachineIdN?: string

    /**
     * 
     * @type {string}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsList
     */
    readonly offset?: number
}

/**
 * Request parameters for secretsSecretsPartialUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsPartialUpdateRequest
 */
export interface SecretsApiSecretsSecretsPartialUpdateRequest {
    /**
     * A unique integer value identifying this secret.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSecret}
     * @memberof SecretsApiSecretsSecretsPartialUpdate
     */
    readonly data: WritableSecret
}

/**
 * Request parameters for secretsSecretsRead operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsReadRequest
 */
export interface SecretsApiSecretsSecretsReadRequest {
    /**
     * A unique integer value identifying this secret.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsRead
     */
    readonly id: number
}

/**
 * Request parameters for secretsSecretsUpdate operation in SecretsApi.
 * @export
 * @interface SecretsApiSecretsSecretsUpdateRequest
 */
export interface SecretsApiSecretsSecretsUpdateRequest {
    /**
     * A unique integer value identifying this secret.
     * @type {number}
     * @memberof SecretsApiSecretsSecretsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSecret}
     * @memberof SecretsApiSecretsSecretsUpdate
     */
    readonly data: WritableSecret
}

/**
 * SecretsApi - object-oriented interface
 * @export
 * @class SecretsApi
 * @extends {BaseAPI}
 */
export class SecretsApi extends BaseAPI {
    /**
     * {         \"public_key\": \"<public key>\",         \"private_key\": \"<private key>\"     }
     * @summary This endpoint can be used to generate a new RSA key pair. The keys are returned in PEM format.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsGenerateRsaKeyPairList(options?: any) {
        return SecretsApiFp(this.configuration).secretsGenerateRsaKeyPairList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a temporary session key to use for encrypting and decrypting secrets via the API. The user\'s private RSA key is POSTed with the name `private_key`. An example:      curl -v -X POST -H \"Authorization: Token <token>\" -H \"Accept: application/json; indent=4\" \\     --data-urlencode \"private_key@<filename>\" https://netbox/api/secrets/get-session-key/  This request will yield a base64-encoded session key to be included in an `X-Session-Key` header in future requests:      {         \"session_key\": \"+8t4SI6XikgVmB5+/urhozx9O5qCQANyOk1MNe6taRf=\"     }  This endpoint accepts one optional parameter: `preserve_key`. If True and a session key exists, the existing session key will be returned instead of a new one.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsGetSessionKeyCreate(options?: any) {
        return SecretsApiFp(this.configuration).secretsGetSessionKeyCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesBulkDelete(options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesBulkPartialUpdate(requestParameters: SecretsApiSecretsSecretRolesBulkPartialUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesBulkUpdate(requestParameters: SecretsApiSecretsSecretRolesBulkUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesCreate(requestParameters: SecretsApiSecretsSecretRolesCreateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesDelete(requestParameters: SecretsApiSecretsSecretRolesDeleteRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesList(requestParameters: SecretsApiSecretsSecretRolesListRequest = {}, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesPartialUpdate(requestParameters: SecretsApiSecretsSecretRolesPartialUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesRead(requestParameters: SecretsApiSecretsSecretRolesReadRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretRolesUpdate(requestParameters: SecretsApiSecretsSecretRolesUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsBulkDelete(options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsBulkPartialUpdate(requestParameters: SecretsApiSecretsSecretsBulkPartialUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsBulkUpdate(requestParameters: SecretsApiSecretsSecretsBulkUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsCreate(requestParameters: SecretsApiSecretsSecretsCreateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsDelete(requestParameters: SecretsApiSecretsSecretsDeleteRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsList(requestParameters: SecretsApiSecretsSecretsListRequest = {}, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsList(requestParameters.id, requestParameters.name, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.roleId, requestParameters.role, requestParameters.device, requestParameters.deviceId, requestParameters.virtualMachine, requestParameters.virtualMachineId, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.roleIdN, requestParameters.roleN, requestParameters.deviceN, requestParameters.deviceIdN, requestParameters.virtualMachineN, requestParameters.virtualMachineIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsPartialUpdate(requestParameters: SecretsApiSecretsSecretsPartialUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsRead(requestParameters: SecretsApiSecretsSecretsReadRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecretsApiSecretsSecretsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretsApi
     */
    public secretsSecretsUpdate(requestParameters: SecretsApiSecretsSecretsUpdateRequest, options?: any) {
        return SecretsApiFp(this.configuration).secretsSecretsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A lightweight read-only endpoint for conveying NetBox\'s current operational status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/status/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * A lightweight read-only endpoint for conveying NetBox\'s current operational status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statusList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statusList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * A lightweight read-only endpoint for conveying NetBox\'s current operational status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statusList(options?: any): AxiosPromise<void> {
            return localVarFp.statusList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * A lightweight read-only endpoint for conveying NetBox\'s current operational status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public statusList(options?: any) {
        return StatusApiFp(this.configuration).statusList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TenancyApi - axios parameter creator
 * @export
 */
export const TenancyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenancy/tenant-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkPartialUpdate: async (data: WritableTenantGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/tenancy/tenant-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkUpdate: async (data: WritableTenantGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantGroupsBulkUpdate', 'data', data)
            const localVarPath = `/tenancy/tenant-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsCreate: async (data: WritableTenantGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantGroupsCreate', 'data', data)
            const localVarPath = `/tenancy/tenant-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantGroupsDelete', 'id', id)
            const localVarPath = `/tenancy/tenant-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenancy/tenant-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (parentN !== undefined) {
                localVarQueryParameter['parent__n'] = parentN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsPartialUpdate: async (id: number, data: WritableTenantGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantGroupsPartialUpdate', 'data', data)
            const localVarPath = `/tenancy/tenant-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantGroupsRead', 'id', id)
            const localVarPath = `/tenancy/tenant-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsUpdate: async (id: number, data: WritableTenantGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantGroupsUpdate', 'data', data)
            const localVarPath = `/tenancy/tenant-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenancy/tenants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkPartialUpdate: async (data: WritableTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantsBulkPartialUpdate', 'data', data)
            const localVarPath = `/tenancy/tenants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkUpdate: async (data: WritableTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantsBulkUpdate', 'data', data)
            const localVarPath = `/tenancy/tenants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsCreate: async (data: WritableTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantsCreate', 'data', data)
            const localVarPath = `/tenancy/tenants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantsDelete', 'id', id)
            const localVarPath = `/tenancy/tenants/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsList: async (id?: string, name?: string, slug?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, groupId?: string, group?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, groupIdN?: string, groupN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/tenancy/tenants/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsPartialUpdate: async (id: number, data: WritableTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantsPartialUpdate', 'data', data)
            const localVarPath = `/tenancy/tenants/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantsRead', 'id', id)
            const localVarPath = `/tenancy/tenants/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsUpdate: async (id: number, data: WritableTenant, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('tenancyTenantsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('tenancyTenantsUpdate', 'data', data)
            const localVarPath = `/tenancy/tenants/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TenancyApi - functional programming interface
 * @export
 */
export const TenancyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TenancyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsBulkPartialUpdate(data: WritableTenantGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsBulkUpdate(data: WritableTenantGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsCreate(data: WritableTenantGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20057>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsPartialUpdate(id: number, data: WritableTenantGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantGroupsUpdate(id: number, data: WritableTenantGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TenantGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsBulkPartialUpdate(data: WritableTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsBulkUpdate(data: WritableTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsCreate(data: WritableTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsList(id?: string, name?: string, slug?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, groupId?: string, group?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, groupIdN?: string, groupN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20058>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsList(id, name, slug, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, groupId, group, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, groupIdN, groupN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsPartialUpdate(id: number, data: WritableTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async tenancyTenantsUpdate(id: number, data: WritableTenant, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tenant>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.tenancyTenantsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TenancyApi - factory interface
 * @export
 */
export const TenancyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TenancyApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.tenancyTenantGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkPartialUpdate(data: WritableTenantGroup, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsBulkUpdate(data: WritableTenantGroup, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsCreate(data: WritableTenantGroup, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tenancyTenantGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20057> {
            return localVarFp.tenancyTenantGroupsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsPartialUpdate(id: number, data: WritableTenantGroup, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsRead(id: number, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant group.
         * @param {WritableTenantGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantGroupsUpdate(id: number, data: WritableTenantGroup, options?: any): AxiosPromise<TenantGroup> {
            return localVarFp.tenancyTenantGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.tenancyTenantsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkPartialUpdate(data: WritableTenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsBulkUpdate(data: WritableTenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsCreate(data: WritableTenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.tenancyTenantsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsList(id?: string, name?: string, slug?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, groupId?: string, group?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, groupIdN?: string, groupN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20058> {
            return localVarFp.tenancyTenantsList(id, name, slug, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, groupId, group, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, groupIdN, groupN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsPartialUpdate(id: number, data: WritableTenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsRead(id: number, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this tenant.
         * @param {WritableTenant} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        tenancyTenantsUpdate(id: number, data: WritableTenant, options?: any): AxiosPromise<Tenant> {
            return localVarFp.tenancyTenantsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for tenancyTenantGroupsBulkPartialUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsBulkPartialUpdateRequest
 */
export interface TenancyApiTenancyTenantGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableTenantGroup}
     * @memberof TenancyApiTenancyTenantGroupsBulkPartialUpdate
     */
    readonly data: WritableTenantGroup
}

/**
 * Request parameters for tenancyTenantGroupsBulkUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsBulkUpdateRequest
 */
export interface TenancyApiTenancyTenantGroupsBulkUpdateRequest {
    /**
     * 
     * @type {WritableTenantGroup}
     * @memberof TenancyApiTenancyTenantGroupsBulkUpdate
     */
    readonly data: WritableTenantGroup
}

/**
 * Request parameters for tenancyTenantGroupsCreate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsCreateRequest
 */
export interface TenancyApiTenancyTenantGroupsCreateRequest {
    /**
     * 
     * @type {WritableTenantGroup}
     * @memberof TenancyApiTenancyTenantGroupsCreate
     */
    readonly data: WritableTenantGroup
}

/**
 * Request parameters for tenancyTenantGroupsDelete operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsDeleteRequest
 */
export interface TenancyApiTenancyTenantGroupsDeleteRequest {
    /**
     * A unique integer value identifying this tenant group.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for tenancyTenantGroupsList operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsListRequest
 */
export interface TenancyApiTenancyTenantGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly parentN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for tenancyTenantGroupsPartialUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsPartialUpdateRequest
 */
export interface TenancyApiTenancyTenantGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this tenant group.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableTenantGroup}
     * @memberof TenancyApiTenancyTenantGroupsPartialUpdate
     */
    readonly data: WritableTenantGroup
}

/**
 * Request parameters for tenancyTenantGroupsRead operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsReadRequest
 */
export interface TenancyApiTenancyTenantGroupsReadRequest {
    /**
     * A unique integer value identifying this tenant group.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for tenancyTenantGroupsUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantGroupsUpdateRequest
 */
export interface TenancyApiTenancyTenantGroupsUpdateRequest {
    /**
     * A unique integer value identifying this tenant group.
     * @type {number}
     * @memberof TenancyApiTenancyTenantGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableTenantGroup}
     * @memberof TenancyApiTenancyTenantGroupsUpdate
     */
    readonly data: WritableTenantGroup
}

/**
 * Request parameters for tenancyTenantsBulkPartialUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsBulkPartialUpdateRequest
 */
export interface TenancyApiTenancyTenantsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableTenant}
     * @memberof TenancyApiTenancyTenantsBulkPartialUpdate
     */
    readonly data: WritableTenant
}

/**
 * Request parameters for tenancyTenantsBulkUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsBulkUpdateRequest
 */
export interface TenancyApiTenancyTenantsBulkUpdateRequest {
    /**
     * 
     * @type {WritableTenant}
     * @memberof TenancyApiTenancyTenantsBulkUpdate
     */
    readonly data: WritableTenant
}

/**
 * Request parameters for tenancyTenantsCreate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsCreateRequest
 */
export interface TenancyApiTenancyTenantsCreateRequest {
    /**
     * 
     * @type {WritableTenant}
     * @memberof TenancyApiTenancyTenantsCreate
     */
    readonly data: WritableTenant
}

/**
 * Request parameters for tenancyTenantsDelete operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsDeleteRequest
 */
export interface TenancyApiTenancyTenantsDeleteRequest {
    /**
     * A unique integer value identifying this tenant.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsDelete
     */
    readonly id: number
}

/**
 * Request parameters for tenancyTenantsList operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsListRequest
 */
export interface TenancyApiTenancyTenantsListRequest {
    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsList
     */
    readonly offset?: number
}

/**
 * Request parameters for tenancyTenantsPartialUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsPartialUpdateRequest
 */
export interface TenancyApiTenancyTenantsPartialUpdateRequest {
    /**
     * A unique integer value identifying this tenant.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableTenant}
     * @memberof TenancyApiTenancyTenantsPartialUpdate
     */
    readonly data: WritableTenant
}

/**
 * Request parameters for tenancyTenantsRead operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsReadRequest
 */
export interface TenancyApiTenancyTenantsReadRequest {
    /**
     * A unique integer value identifying this tenant.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsRead
     */
    readonly id: number
}

/**
 * Request parameters for tenancyTenantsUpdate operation in TenancyApi.
 * @export
 * @interface TenancyApiTenancyTenantsUpdateRequest
 */
export interface TenancyApiTenancyTenantsUpdateRequest {
    /**
     * A unique integer value identifying this tenant.
     * @type {number}
     * @memberof TenancyApiTenancyTenantsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableTenant}
     * @memberof TenancyApiTenancyTenantsUpdate
     */
    readonly data: WritableTenant
}

/**
 * TenancyApi - object-oriented interface
 * @export
 * @class TenancyApi
 * @extends {BaseAPI}
 */
export class TenancyApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsBulkDelete(options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsBulkPartialUpdate(requestParameters: TenancyApiTenancyTenantGroupsBulkPartialUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsBulkUpdate(requestParameters: TenancyApiTenancyTenantGroupsBulkUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsCreate(requestParameters: TenancyApiTenancyTenantGroupsCreateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsDelete(requestParameters: TenancyApiTenancyTenantGroupsDeleteRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsList(requestParameters: TenancyApiTenancyTenantGroupsListRequest = {}, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.parentId, requestParameters.parent, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.parentIdN, requestParameters.parentN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsPartialUpdate(requestParameters: TenancyApiTenancyTenantGroupsPartialUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsRead(requestParameters: TenancyApiTenancyTenantGroupsReadRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantGroupsUpdate(requestParameters: TenancyApiTenancyTenantGroupsUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsBulkDelete(options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsBulkPartialUpdate(requestParameters: TenancyApiTenancyTenantsBulkPartialUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsBulkUpdate(requestParameters: TenancyApiTenancyTenantsBulkUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsCreate(requestParameters: TenancyApiTenancyTenantsCreateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsDelete(requestParameters: TenancyApiTenancyTenantsDeleteRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsList(requestParameters: TenancyApiTenancyTenantsListRequest = {}, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.groupId, requestParameters.group, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.groupIdN, requestParameters.groupN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsPartialUpdate(requestParameters: TenancyApiTenancyTenantsPartialUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsRead(requestParameters: TenancyApiTenancyTenantsReadRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {TenancyApiTenancyTenantsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenancyApi
     */
    public tenancyTenantsUpdate(requestParameters: TenancyApiTenancyTenantsUpdateRequest, options?: any) {
        return TenancyApiFp(this.configuration).tenancyTenantsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConfigList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkPartialUpdate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkUpdate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsBulkUpdate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsCreate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsCreate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsDelete', 'id', id)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsList: async (id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsPartialUpdate: async (id: number, data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsPartialUpdate', 'data', data)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsRead', 'id', id)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsUpdate: async (id: number, data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsUpdate', 'data', data)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkPartialUpdate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkUpdate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsBulkUpdate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsCreate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsCreate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsDelete', 'id', id)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsList: async (id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (objectTypes !== undefined) {
                localVarQueryParameter['object_types'] = objectTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (objectTypesN !== undefined) {
                localVarQueryParameter['object_types__n'] = objectTypesN;
            }

            if (userIdN !== undefined) {
                localVarQueryParameter['user_id__n'] = userIdN;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPartialUpdate: async (id: number, data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsPartialUpdate', 'data', data)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsRead', 'id', id)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsUpdate: async (id: number, data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsUpdate', 'data', data)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkPartialUpdate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkUpdate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersBulkUpdate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersCreate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersCreate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersDelete', 'id', id)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersList: async (id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (isStaff !== undefined) {
                localVarQueryParameter['is_staff'] = isStaff;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (usernameN !== undefined) {
                localVarQueryParameter['username__n'] = usernameN;
            }

            if (usernameIc !== undefined) {
                localVarQueryParameter['username__ic'] = usernameIc;
            }

            if (usernameNic !== undefined) {
                localVarQueryParameter['username__nic'] = usernameNic;
            }

            if (usernameIew !== undefined) {
                localVarQueryParameter['username__iew'] = usernameIew;
            }

            if (usernameNiew !== undefined) {
                localVarQueryParameter['username__niew'] = usernameNiew;
            }

            if (usernameIsw !== undefined) {
                localVarQueryParameter['username__isw'] = usernameIsw;
            }

            if (usernameNisw !== undefined) {
                localVarQueryParameter['username__nisw'] = usernameNisw;
            }

            if (usernameIe !== undefined) {
                localVarQueryParameter['username__ie'] = usernameIe;
            }

            if (usernameNie !== undefined) {
                localVarQueryParameter['username__nie'] = usernameNie;
            }

            if (firstNameN !== undefined) {
                localVarQueryParameter['first_name__n'] = firstNameN;
            }

            if (firstNameIc !== undefined) {
                localVarQueryParameter['first_name__ic'] = firstNameIc;
            }

            if (firstNameNic !== undefined) {
                localVarQueryParameter['first_name__nic'] = firstNameNic;
            }

            if (firstNameIew !== undefined) {
                localVarQueryParameter['first_name__iew'] = firstNameIew;
            }

            if (firstNameNiew !== undefined) {
                localVarQueryParameter['first_name__niew'] = firstNameNiew;
            }

            if (firstNameIsw !== undefined) {
                localVarQueryParameter['first_name__isw'] = firstNameIsw;
            }

            if (firstNameNisw !== undefined) {
                localVarQueryParameter['first_name__nisw'] = firstNameNisw;
            }

            if (firstNameIe !== undefined) {
                localVarQueryParameter['first_name__ie'] = firstNameIe;
            }

            if (firstNameNie !== undefined) {
                localVarQueryParameter['first_name__nie'] = firstNameNie;
            }

            if (lastNameN !== undefined) {
                localVarQueryParameter['last_name__n'] = lastNameN;
            }

            if (lastNameIc !== undefined) {
                localVarQueryParameter['last_name__ic'] = lastNameIc;
            }

            if (lastNameNic !== undefined) {
                localVarQueryParameter['last_name__nic'] = lastNameNic;
            }

            if (lastNameIew !== undefined) {
                localVarQueryParameter['last_name__iew'] = lastNameIew;
            }

            if (lastNameNiew !== undefined) {
                localVarQueryParameter['last_name__niew'] = lastNameNiew;
            }

            if (lastNameIsw !== undefined) {
                localVarQueryParameter['last_name__isw'] = lastNameIsw;
            }

            if (lastNameNisw !== undefined) {
                localVarQueryParameter['last_name__nisw'] = lastNameNisw;
            }

            if (lastNameIe !== undefined) {
                localVarQueryParameter['last_name__ie'] = lastNameIe;
            }

            if (lastNameNie !== undefined) {
                localVarQueryParameter['last_name__nie'] = lastNameNie;
            }

            if (emailN !== undefined) {
                localVarQueryParameter['email__n'] = emailN;
            }

            if (emailIc !== undefined) {
                localVarQueryParameter['email__ic'] = emailIc;
            }

            if (emailNic !== undefined) {
                localVarQueryParameter['email__nic'] = emailNic;
            }

            if (emailIew !== undefined) {
                localVarQueryParameter['email__iew'] = emailIew;
            }

            if (emailNiew !== undefined) {
                localVarQueryParameter['email__niew'] = emailNiew;
            }

            if (emailIsw !== undefined) {
                localVarQueryParameter['email__isw'] = emailIsw;
            }

            if (emailNisw !== undefined) {
                localVarQueryParameter['email__nisw'] = emailNisw;
            }

            if (emailIe !== undefined) {
                localVarQueryParameter['email__ie'] = emailIe;
            }

            if (emailNie !== undefined) {
                localVarQueryParameter['email__nie'] = emailNie;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersPartialUpdate: async (id: number, data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersPartialUpdate', 'data', data)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersRead', 'id', id)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersUpdate: async (id: number, data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersUpdate', 'data', data)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersConfigList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersConfigList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkPartialUpdate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkUpdate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsCreate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsList(id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsList(id, name, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsPartialUpdate(id: number, data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsUpdate(id: number, data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkPartialUpdate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkUpdate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsCreate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsList(id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsList(id, name, enabled, objectTypes, userId, user, groupId, group, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, objectTypesN, userIdN, userN, groupIdN, groupN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsPartialUpdate(id: number, data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsUpdate(id: number, data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkPartialUpdate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkUpdate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersCreate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersList(id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersList(id, username, firstName, lastName, email, isStaff, isActive, q, groupId, group, idN, idLte, idLt, idGte, idGt, usernameN, usernameIc, usernameNic, usernameIew, usernameNiew, usernameIsw, usernameNisw, usernameIe, usernameNie, firstNameN, firstNameIc, firstNameNic, firstNameIew, firstNameNiew, firstNameIsw, firstNameNisw, firstNameIe, firstNameNie, lastNameN, lastNameIc, lastNameNic, lastNameIew, lastNameNiew, lastNameIsw, lastNameNisw, lastNameIe, lastNameNie, emailN, emailIc, emailNic, emailIew, emailNiew, emailIsw, emailNisw, emailIe, emailNie, groupIdN, groupN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersPartialUpdate(id: number, data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersUpdate(id: number, data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConfigList(options?: any): AxiosPromise<void> {
            return localVarFp.usersConfigList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkPartialUpdate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkUpdate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsCreate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsList(id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20059> {
            return localVarFp.usersGroupsList(id, name, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsPartialUpdate(id: number, data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsRead(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsUpdate(id: number, data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersPermissionsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkPartialUpdate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkUpdate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsCreate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersPermissionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsList(id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20060> {
            return localVarFp.usersPermissionsList(id, name, enabled, objectTypes, userId, user, groupId, group, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, objectTypesN, userIdN, userN, groupIdN, groupN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPartialUpdate(id: number, data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRead(id: number, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsUpdate(id: number, data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersUsersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkPartialUpdate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkUpdate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersCreate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersUsersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersList(id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20061> {
            return localVarFp.usersUsersList(id, username, firstName, lastName, email, isStaff, isActive, q, groupId, group, idN, idLte, idLt, idGte, idGt, usernameN, usernameIc, usernameNic, usernameIew, usernameNiew, usernameIsw, usernameNisw, usernameIe, usernameNie, firstNameN, firstNameIc, firstNameNic, firstNameIew, firstNameNiew, firstNameIsw, firstNameNisw, firstNameIe, firstNameNie, lastNameN, lastNameIc, lastNameNic, lastNameIew, lastNameNiew, lastNameIsw, lastNameNisw, lastNameIe, lastNameNie, emailN, emailIc, emailNic, emailIew, emailNiew, emailIsw, emailNisw, emailIe, emailNie, groupIdN, groupN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersPartialUpdate(id: number, data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersRead(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersUpdate(id: number, data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersGroupsBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsBulkPartialUpdateRequest
 */
export interface UsersApiUsersGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsBulkPartialUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsBulkUpdateRequest
 */
export interface UsersApiUsersGroupsBulkUpdateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsBulkUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsCreateRequest
 */
export interface UsersApiUsersGroupsCreateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsCreate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsDeleteRequest
 */
export interface UsersApiUsersGroupsDeleteRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersGroupsList operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsListRequest
 */
export interface UsersApiUsersGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersGroupsPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsPartialUpdateRequest
 */
export interface UsersApiUsersGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsPartialUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsReadRequest
 */
export interface UsersApiUsersGroupsReadRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for usersGroupsUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsUpdateRequest
 */
export interface UsersApiUsersGroupsUpdateRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersPermissionsBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsBulkPartialUpdateRequest
 */
export interface UsersApiUsersPermissionsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsBulkPartialUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsBulkUpdateRequest
 */
export interface UsersApiUsersPermissionsBulkUpdateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsBulkUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsCreateRequest
 */
export interface UsersApiUsersPermissionsCreateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsCreate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsDeleteRequest
 */
export interface UsersApiUsersPermissionsDeleteRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersPermissionsList operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsListRequest
 */
export interface UsersApiUsersPermissionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly objectTypes?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly objectTypesN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersPermissionsPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsPartialUpdateRequest
 */
export interface UsersApiUsersPermissionsPartialUpdateRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsPartialUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsReadRequest
 */
export interface UsersApiUsersPermissionsReadRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsRead
     */
    readonly id: number
}

/**
 * Request parameters for usersPermissionsUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsUpdateRequest
 */
export interface UsersApiUsersPermissionsUpdateRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersUsersBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersBulkPartialUpdateRequest
 */
export interface UsersApiUsersUsersBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersBulkPartialUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersBulkUpdateRequest
 */
export interface UsersApiUsersUsersBulkUpdateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersBulkUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersCreateRequest
 */
export interface UsersApiUsersUsersCreateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersCreate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersDeleteRequest
 */
export interface UsersApiUsersUsersDeleteRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersUsersList operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersListRequest
 */
export interface UsersApiUsersUsersListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly username?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly email?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly isStaff?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly isActive?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersUsersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersUsersList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersUsersPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersPartialUpdateRequest
 */
export interface UsersApiUsersUsersPartialUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersPartialUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersReadRequest
 */
export interface UsersApiUsersUsersReadRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersRead
     */
    readonly id: number
}

/**
 * Request parameters for usersUsersUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersUpdateRequest
 */
export interface UsersApiUsersUsersUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersUpdate
     */
    readonly data: WritableUser
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Return the UserConfig for the currently authenticated User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersConfigList(options?: any) {
        return UsersApiFp(this.configuration).usersConfigList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkPartialUpdate(requestParameters: UsersApiUsersGroupsBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkUpdate(requestParameters: UsersApiUsersGroupsBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsCreate(requestParameters: UsersApiUsersGroupsCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsDelete(requestParameters: UsersApiUsersGroupsDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsList(requestParameters: UsersApiUsersGroupsListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsPartialUpdate(requestParameters: UsersApiUsersGroupsPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsRead(requestParameters: UsersApiUsersGroupsReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsUpdate(requestParameters: UsersApiUsersGroupsUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkPartialUpdate(requestParameters: UsersApiUsersPermissionsBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkUpdate(requestParameters: UsersApiUsersPermissionsBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsCreate(requestParameters: UsersApiUsersPermissionsCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsDelete(requestParameters: UsersApiUsersPermissionsDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsList(requestParameters: UsersApiUsersPermissionsListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsList(requestParameters.id, requestParameters.name, requestParameters.enabled, requestParameters.objectTypes, requestParameters.userId, requestParameters.user, requestParameters.groupId, requestParameters.group, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.objectTypesN, requestParameters.userIdN, requestParameters.userN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsPartialUpdate(requestParameters: UsersApiUsersPermissionsPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsRead(requestParameters: UsersApiUsersPermissionsReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsUpdate(requestParameters: UsersApiUsersPermissionsUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkPartialUpdate(requestParameters: UsersApiUsersUsersBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkUpdate(requestParameters: UsersApiUsersUsersBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersCreate(requestParameters: UsersApiUsersUsersCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersDelete(requestParameters: UsersApiUsersUsersDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersList(requestParameters: UsersApiUsersUsersListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersUsersList(requestParameters.id, requestParameters.username, requestParameters.firstName, requestParameters.lastName, requestParameters.email, requestParameters.isStaff, requestParameters.isActive, requestParameters.q, requestParameters.groupId, requestParameters.group, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.usernameN, requestParameters.usernameIc, requestParameters.usernameNic, requestParameters.usernameIew, requestParameters.usernameNiew, requestParameters.usernameIsw, requestParameters.usernameNisw, requestParameters.usernameIe, requestParameters.usernameNie, requestParameters.firstNameN, requestParameters.firstNameIc, requestParameters.firstNameNic, requestParameters.firstNameIew, requestParameters.firstNameNiew, requestParameters.firstNameIsw, requestParameters.firstNameNisw, requestParameters.firstNameIe, requestParameters.firstNameNie, requestParameters.lastNameN, requestParameters.lastNameIc, requestParameters.lastNameNic, requestParameters.lastNameIew, requestParameters.lastNameNiew, requestParameters.lastNameIsw, requestParameters.lastNameNisw, requestParameters.lastNameIe, requestParameters.lastNameNie, requestParameters.emailN, requestParameters.emailIc, requestParameters.emailNic, requestParameters.emailIew, requestParameters.emailNiew, requestParameters.emailIsw, requestParameters.emailNisw, requestParameters.emailIe, requestParameters.emailNie, requestParameters.groupIdN, requestParameters.groupN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersPartialUpdate(requestParameters: UsersApiUsersUsersPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersRead(requestParameters: UsersApiUsersUsersReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersUpdate(requestParameters: UsersApiUsersUsersUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VirtualizationApi - axios parameter creator
 * @export
 */
export const VirtualizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkPartialUpdate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkUpdate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsCreate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsCreate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsDelete', 'id', id)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsPartialUpdate: async (id: number, data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsRead', 'id', id)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsUpdate: async (id: number, data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkPartialUpdate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkUpdate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesCreate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesCreate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesDelete', 'id', id)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesPartialUpdate: async (id: number, data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesRead', 'id', id)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesUpdate: async (id: number, data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkPartialUpdate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkUpdate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersCreate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersCreate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersDelete', 'id', id)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersList: async (id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (typeIdN !== undefined) {
                localVarQueryParameter['type_id__n'] = typeIdN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersPartialUpdate: async (id: number, data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersRead', 'id', id)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersUpdate: async (id: number, data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkPartialUpdate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkUpdate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesCreate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesCreate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesDelete', 'id', id)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesList: async (id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (mtu !== undefined) {
                localVarQueryParameter['mtu'] = mtu;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (mtuN !== undefined) {
                localVarQueryParameter['mtu__n'] = mtuN;
            }

            if (mtuLte !== undefined) {
                localVarQueryParameter['mtu__lte'] = mtuLte;
            }

            if (mtuLt !== undefined) {
                localVarQueryParameter['mtu__lt'] = mtuLt;
            }

            if (mtuGte !== undefined) {
                localVarQueryParameter['mtu__gte'] = mtuGte;
            }

            if (mtuGt !== undefined) {
                localVarQueryParameter['mtu__gt'] = mtuGt;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (clusterN !== undefined) {
                localVarQueryParameter['cluster__n'] = clusterN;
            }

            if (virtualMachineIdN !== undefined) {
                localVarQueryParameter['virtual_machine_id__n'] = virtualMachineIdN;
            }

            if (virtualMachineN !== undefined) {
                localVarQueryParameter['virtual_machine__n'] = virtualMachineN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesPartialUpdate: async (id: number, data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesRead', 'id', id)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesUpdate: async (id: number, data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkPartialUpdate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkUpdate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesCreate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesCreate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesDelete', 'id', id)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesList: async (id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (vcpus !== undefined) {
                localVarQueryParameter['vcpus'] = vcpus;
            }

            if (memory !== undefined) {
                localVarQueryParameter['memory'] = memory;
            }

            if (disk !== undefined) {
                localVarQueryParameter['disk'] = disk;
            }

            if (localContextData !== undefined) {
                localVarQueryParameter['local_context_data'] = localContextData;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (clusterGroupId !== undefined) {
                localVarQueryParameter['cluster_group_id'] = clusterGroupId;
            }

            if (clusterGroup !== undefined) {
                localVarQueryParameter['cluster_group'] = clusterGroup;
            }

            if (clusterTypeId !== undefined) {
                localVarQueryParameter['cluster_type_id'] = clusterTypeId;
            }

            if (clusterType !== undefined) {
                localVarQueryParameter['cluster_type'] = clusterType;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (platformId !== undefined) {
                localVarQueryParameter['platform_id'] = platformId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (hasPrimaryIp !== undefined) {
                localVarQueryParameter['has_primary_ip'] = hasPrimaryIp;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (clusterN !== undefined) {
                localVarQueryParameter['cluster__n'] = clusterN;
            }

            if (vcpusN !== undefined) {
                localVarQueryParameter['vcpus__n'] = vcpusN;
            }

            if (vcpusLte !== undefined) {
                localVarQueryParameter['vcpus__lte'] = vcpusLte;
            }

            if (vcpusLt !== undefined) {
                localVarQueryParameter['vcpus__lt'] = vcpusLt;
            }

            if (vcpusGte !== undefined) {
                localVarQueryParameter['vcpus__gte'] = vcpusGte;
            }

            if (vcpusGt !== undefined) {
                localVarQueryParameter['vcpus__gt'] = vcpusGt;
            }

            if (memoryN !== undefined) {
                localVarQueryParameter['memory__n'] = memoryN;
            }

            if (memoryLte !== undefined) {
                localVarQueryParameter['memory__lte'] = memoryLte;
            }

            if (memoryLt !== undefined) {
                localVarQueryParameter['memory__lt'] = memoryLt;
            }

            if (memoryGte !== undefined) {
                localVarQueryParameter['memory__gte'] = memoryGte;
            }

            if (memoryGt !== undefined) {
                localVarQueryParameter['memory__gt'] = memoryGt;
            }

            if (diskN !== undefined) {
                localVarQueryParameter['disk__n'] = diskN;
            }

            if (diskLte !== undefined) {
                localVarQueryParameter['disk__lte'] = diskLte;
            }

            if (diskLt !== undefined) {
                localVarQueryParameter['disk__lt'] = diskLt;
            }

            if (diskGte !== undefined) {
                localVarQueryParameter['disk__gte'] = diskGte;
            }

            if (diskGt !== undefined) {
                localVarQueryParameter['disk__gt'] = diskGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (clusterGroupIdN !== undefined) {
                localVarQueryParameter['cluster_group_id__n'] = clusterGroupIdN;
            }

            if (clusterGroupN !== undefined) {
                localVarQueryParameter['cluster_group__n'] = clusterGroupN;
            }

            if (clusterTypeIdN !== undefined) {
                localVarQueryParameter['cluster_type_id__n'] = clusterTypeIdN;
            }

            if (clusterTypeN !== undefined) {
                localVarQueryParameter['cluster_type__n'] = clusterTypeN;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (platformIdN !== undefined) {
                localVarQueryParameter['platform_id__n'] = platformIdN;
            }

            if (platformN !== undefined) {
                localVarQueryParameter['platform__n'] = platformN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesPartialUpdate: async (id: number, data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesRead', 'id', id)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesUpdate: async (id: number, data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualizationApi - functional programming interface
 * @export
 */
export const VirtualizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkPartialUpdate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkUpdate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsCreate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsPartialUpdate(id: number, data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsUpdate(id: number, data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkPartialUpdate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkUpdate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesCreate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesPartialUpdate(id: number, data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesUpdate(id: number, data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkPartialUpdate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkUpdate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersCreate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20064>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, typeId, type, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, typeIdN, typeN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersPartialUpdate(id: number, data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersUpdate(id: number, data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkPartialUpdate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkUpdate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesCreate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesList(id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesList(id, name, enabled, mtu, q, clusterId, cluster, virtualMachineId, virtualMachine, macAddress, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, clusterIdN, clusterN, virtualMachineIdN, virtualMachineN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesPartialUpdate(id: number, data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesUpdate(id: number, data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkPartialUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesCreate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesList(id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesList(id, name, cluster, vcpus, memory, disk, localContextData, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, clusterGroupId, clusterGroup, clusterTypeId, clusterType, clusterId, regionId, region, siteId, site, roleId, role, platformId, platform, macAddress, hasPrimaryIp, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, clusterN, vcpusN, vcpusLte, vcpusLt, vcpusGte, vcpusGt, memoryN, memoryLte, memoryLt, memoryGte, memoryGt, diskN, diskLte, diskLt, diskGte, diskGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, clusterGroupIdN, clusterGroupN, clusterTypeIdN, clusterTypeN, clusterIdN, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesPartialUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VirtualizationApi - factory interface
 * @export
 */
export const VirtualizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualizationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkPartialUpdate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkUpdate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsCreate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20062> {
            return localVarFp.virtualizationClusterGroupsList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsPartialUpdate(id: number, data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsRead(id: number, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsUpdate(id: number, data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkPartialUpdate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkUpdate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesCreate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20063> {
            return localVarFp.virtualizationClusterTypesList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesPartialUpdate(id: number, data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesRead(id: number, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesUpdate(id: number, data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClustersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkPartialUpdate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkUpdate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersCreate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClustersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20064> {
            return localVarFp.virtualizationClustersList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, typeId, type, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, typeIdN, typeN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersPartialUpdate(id: number, data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersRead(id: number, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersUpdate(id: number, data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationInterfacesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkPartialUpdate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkUpdate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesCreate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationInterfacesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesList(id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20065> {
            return localVarFp.virtualizationInterfacesList(id, name, enabled, mtu, q, clusterId, cluster, virtualMachineId, virtualMachine, macAddress, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, clusterIdN, clusterN, virtualMachineIdN, virtualMachineN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesPartialUpdate(id: number, data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesRead(id: number, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesUpdate(id: number, data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationVirtualMachinesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkPartialUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesCreate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationVirtualMachinesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesList(id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20066> {
            return localVarFp.virtualizationVirtualMachinesList(id, name, cluster, vcpus, memory, disk, localContextData, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, clusterGroupId, clusterGroup, clusterTypeId, clusterType, clusterId, regionId, region, siteId, site, roleId, role, platformId, platform, macAddress, hasPrimaryIp, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, clusterN, vcpusN, vcpusLte, vcpusLt, vcpusGte, vcpusGt, memoryN, memoryLte, memoryLt, memoryGte, memoryGt, diskN, diskLte, diskLt, diskGte, diskGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, clusterGroupIdN, clusterGroupN, clusterTypeIdN, clusterTypeN, clusterIdN, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesPartialUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesRead(id: number, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for virtualizationClusterGroupsBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsBulkUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsCreateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsCreateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsCreate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsDeleteRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsDeleteRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterGroupsList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsListRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClusterGroupsPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsPartialUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsReadRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsReadRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterGroupsUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsUpdateRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterTypesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesBulkPartialUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesBulkUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesCreateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesCreateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesCreate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesDeleteRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesDeleteRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterTypesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesListRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClusterTypesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesPartialUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesReadRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesReadRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterTypesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesUpdateRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClustersBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersBulkPartialUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersBulkUpdateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersBulkUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersCreateRequest
 */
export interface VirtualizationApiVirtualizationClustersCreateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersCreate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersDeleteRequest
 */
export interface VirtualizationApiVirtualizationClustersDeleteRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClustersList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersListRequest
 */
export interface VirtualizationApiVirtualizationClustersListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClustersPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersPartialUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersReadRequest
 */
export interface VirtualizationApiVirtualizationClustersReadRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClustersUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersUpdateRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationInterfacesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesBulkPartialUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesBulkUpdateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesBulkUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesCreateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesCreateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesCreate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesDeleteRequest
 */
export interface VirtualizationApiVirtualizationInterfacesDeleteRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationInterfacesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesListRequest
 */
export interface VirtualizationApiVirtualizationInterfacesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtu?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly cluster?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationInterfacesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesPartialUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesReadRequest
 */
export interface VirtualizationApiVirtualizationInterfacesReadRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationInterfacesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationVirtualMachinesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesBulkUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesCreateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesCreateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesCreate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesDeleteRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesDeleteRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationVirtualMachinesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesListRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly cluster?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpus?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memory?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly disk?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly localContextData?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterType?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platform?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly hasPrimaryIp?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationVirtualMachinesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesPartialUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesReadRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesReadRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationVirtualMachinesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesUpdateRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * VirtualizationApi - object-oriented interface
 * @export
 * @class VirtualizationApi
 * @extends {BaseAPI}
 */
export class VirtualizationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsCreate(requestParameters: VirtualizationApiVirtualizationClusterGroupsCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsDelete(requestParameters: VirtualizationApiVirtualizationClusterGroupsDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsList(requestParameters: VirtualizationApiVirtualizationClusterGroupsListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsRead(requestParameters: VirtualizationApiVirtualizationClusterGroupsReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesCreate(requestParameters: VirtualizationApiVirtualizationClusterTypesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesDelete(requestParameters: VirtualizationApiVirtualizationClusterTypesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesList(requestParameters: VirtualizationApiVirtualizationClusterTypesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesRead(requestParameters: VirtualizationApiVirtualizationClusterTypesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkUpdate(requestParameters: VirtualizationApiVirtualizationClustersBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersCreate(requestParameters: VirtualizationApiVirtualizationClustersCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersDelete(requestParameters: VirtualizationApiVirtualizationClustersDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersList(requestParameters: VirtualizationApiVirtualizationClustersListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersList(requestParameters.id, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.typeId, requestParameters.type, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.typeIdN, requestParameters.typeN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersPartialUpdate(requestParameters: VirtualizationApiVirtualizationClustersPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersRead(requestParameters: VirtualizationApiVirtualizationClustersReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersUpdate(requestParameters: VirtualizationApiVirtualizationClustersUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesCreate(requestParameters: VirtualizationApiVirtualizationInterfacesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesDelete(requestParameters: VirtualizationApiVirtualizationInterfacesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesList(requestParameters: VirtualizationApiVirtualizationInterfacesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesList(requestParameters.id, requestParameters.name, requestParameters.enabled, requestParameters.mtu, requestParameters.q, requestParameters.clusterId, requestParameters.cluster, requestParameters.virtualMachineId, requestParameters.virtualMachine, requestParameters.macAddress, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.mtuN, requestParameters.mtuLte, requestParameters.mtuLt, requestParameters.mtuGte, requestParameters.mtuGt, requestParameters.clusterIdN, requestParameters.clusterN, requestParameters.virtualMachineIdN, requestParameters.virtualMachineN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesPartialUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesRead(requestParameters: VirtualizationApiVirtualizationInterfacesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesCreate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesDelete(requestParameters: VirtualizationApiVirtualizationVirtualMachinesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesList(requestParameters: VirtualizationApiVirtualizationVirtualMachinesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesList(requestParameters.id, requestParameters.name, requestParameters.cluster, requestParameters.vcpus, requestParameters.memory, requestParameters.disk, requestParameters.localContextData, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.status, requestParameters.clusterGroupId, requestParameters.clusterGroup, requestParameters.clusterTypeId, requestParameters.clusterType, requestParameters.clusterId, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.roleId, requestParameters.role, requestParameters.platformId, requestParameters.platform, requestParameters.macAddress, requestParameters.hasPrimaryIp, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.clusterN, requestParameters.vcpusN, requestParameters.vcpusLte, requestParameters.vcpusLt, requestParameters.vcpusGte, requestParameters.vcpusGt, requestParameters.memoryN, requestParameters.memoryLte, requestParameters.memoryLt, requestParameters.memoryGte, requestParameters.memoryGt, requestParameters.diskN, requestParameters.diskLte, requestParameters.diskLt, requestParameters.diskGte, requestParameters.diskGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.statusN, requestParameters.clusterGroupIdN, requestParameters.clusterGroupN, requestParameters.clusterTypeIdN, requestParameters.clusterTypeN, requestParameters.clusterIdN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.platformIdN, requestParameters.platformN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesPartialUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesRead(requestParameters: VirtualizationApiVirtualizationVirtualMachinesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}


