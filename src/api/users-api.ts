/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Group } from '../models';
// @ts-ignore
import { InlineResponse20059 } from '../models';
// @ts-ignore
import { InlineResponse20060 } from '../models';
// @ts-ignore
import { InlineResponse20061 } from '../models';
// @ts-ignore
import { ObjectPermission } from '../models';
// @ts-ignore
import { User } from '../models';
// @ts-ignore
import { WritableObjectPermission } from '../models';
// @ts-ignore
import { WritableUser } from '../models';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConfigList: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/config/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkPartialUpdate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkUpdate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsBulkUpdate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsCreate: async (data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsCreate', 'data', data)
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsDelete', 'id', id)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsList: async (id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsPartialUpdate: async (id: number, data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsPartialUpdate', 'data', data)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsRead', 'id', id)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsUpdate: async (id: number, data: Group, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersGroupsUpdate', 'data', data)
            const localVarPath = `/users/groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkPartialUpdate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkUpdate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsBulkUpdate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsCreate: async (data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsCreate', 'data', data)
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsDelete', 'id', id)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsList: async (id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/permissions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (objectTypes !== undefined) {
                localVarQueryParameter['object_types'] = objectTypes;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (objectTypesN !== undefined) {
                localVarQueryParameter['object_types__n'] = objectTypesN;
            }

            if (userIdN !== undefined) {
                localVarQueryParameter['user_id__n'] = userIdN;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPartialUpdate: async (id: number, data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsPartialUpdate', 'data', data)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsRead', 'id', id)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsUpdate: async (id: number, data: WritableObjectPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPermissionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersPermissionsUpdate', 'data', data)
            const localVarPath = `/users/permissions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkPartialUpdate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersBulkPartialUpdate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkUpdate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersBulkUpdate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersCreate: async (data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersCreate', 'data', data)
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersDelete', 'id', id)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersList: async (id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/users/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (firstName !== undefined) {
                localVarQueryParameter['first_name'] = firstName;
            }

            if (lastName !== undefined) {
                localVarQueryParameter['last_name'] = lastName;
            }

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            if (isStaff !== undefined) {
                localVarQueryParameter['is_staff'] = isStaff;
            }

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (usernameN !== undefined) {
                localVarQueryParameter['username__n'] = usernameN;
            }

            if (usernameIc !== undefined) {
                localVarQueryParameter['username__ic'] = usernameIc;
            }

            if (usernameNic !== undefined) {
                localVarQueryParameter['username__nic'] = usernameNic;
            }

            if (usernameIew !== undefined) {
                localVarQueryParameter['username__iew'] = usernameIew;
            }

            if (usernameNiew !== undefined) {
                localVarQueryParameter['username__niew'] = usernameNiew;
            }

            if (usernameIsw !== undefined) {
                localVarQueryParameter['username__isw'] = usernameIsw;
            }

            if (usernameNisw !== undefined) {
                localVarQueryParameter['username__nisw'] = usernameNisw;
            }

            if (usernameIe !== undefined) {
                localVarQueryParameter['username__ie'] = usernameIe;
            }

            if (usernameNie !== undefined) {
                localVarQueryParameter['username__nie'] = usernameNie;
            }

            if (firstNameN !== undefined) {
                localVarQueryParameter['first_name__n'] = firstNameN;
            }

            if (firstNameIc !== undefined) {
                localVarQueryParameter['first_name__ic'] = firstNameIc;
            }

            if (firstNameNic !== undefined) {
                localVarQueryParameter['first_name__nic'] = firstNameNic;
            }

            if (firstNameIew !== undefined) {
                localVarQueryParameter['first_name__iew'] = firstNameIew;
            }

            if (firstNameNiew !== undefined) {
                localVarQueryParameter['first_name__niew'] = firstNameNiew;
            }

            if (firstNameIsw !== undefined) {
                localVarQueryParameter['first_name__isw'] = firstNameIsw;
            }

            if (firstNameNisw !== undefined) {
                localVarQueryParameter['first_name__nisw'] = firstNameNisw;
            }

            if (firstNameIe !== undefined) {
                localVarQueryParameter['first_name__ie'] = firstNameIe;
            }

            if (firstNameNie !== undefined) {
                localVarQueryParameter['first_name__nie'] = firstNameNie;
            }

            if (lastNameN !== undefined) {
                localVarQueryParameter['last_name__n'] = lastNameN;
            }

            if (lastNameIc !== undefined) {
                localVarQueryParameter['last_name__ic'] = lastNameIc;
            }

            if (lastNameNic !== undefined) {
                localVarQueryParameter['last_name__nic'] = lastNameNic;
            }

            if (lastNameIew !== undefined) {
                localVarQueryParameter['last_name__iew'] = lastNameIew;
            }

            if (lastNameNiew !== undefined) {
                localVarQueryParameter['last_name__niew'] = lastNameNiew;
            }

            if (lastNameIsw !== undefined) {
                localVarQueryParameter['last_name__isw'] = lastNameIsw;
            }

            if (lastNameNisw !== undefined) {
                localVarQueryParameter['last_name__nisw'] = lastNameNisw;
            }

            if (lastNameIe !== undefined) {
                localVarQueryParameter['last_name__ie'] = lastNameIe;
            }

            if (lastNameNie !== undefined) {
                localVarQueryParameter['last_name__nie'] = lastNameNie;
            }

            if (emailN !== undefined) {
                localVarQueryParameter['email__n'] = emailN;
            }

            if (emailIc !== undefined) {
                localVarQueryParameter['email__ic'] = emailIc;
            }

            if (emailNic !== undefined) {
                localVarQueryParameter['email__nic'] = emailNic;
            }

            if (emailIew !== undefined) {
                localVarQueryParameter['email__iew'] = emailIew;
            }

            if (emailNiew !== undefined) {
                localVarQueryParameter['email__niew'] = emailNiew;
            }

            if (emailIsw !== undefined) {
                localVarQueryParameter['email__isw'] = emailIsw;
            }

            if (emailNisw !== undefined) {
                localVarQueryParameter['email__nisw'] = emailNisw;
            }

            if (emailIe !== undefined) {
                localVarQueryParameter['email__ie'] = emailIe;
            }

            if (emailNie !== undefined) {
                localVarQueryParameter['email__nie'] = emailNie;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersPartialUpdate: async (id: number, data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersPartialUpdate', 'data', data)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersRead', 'id', id)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersUpdate: async (id: number, data: WritableUser, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUsersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('usersUsersUpdate', 'data', data)
            const localVarPath = `/users/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersConfigList(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersConfigList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkPartialUpdate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsBulkUpdate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsCreate(data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsList(id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20059>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsList(id, name, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsPartialUpdate(id: number, data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGroupsUpdate(id: number, data: Group, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkPartialUpdate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsBulkUpdate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsCreate(data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsList(id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20060>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsList(id, name, enabled, objectTypes, userId, user, groupId, group, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, objectTypesN, userIdN, userN, groupIdN, groupN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsPartialUpdate(id: number, data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPermissionsUpdate(id: number, data: WritableObjectPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ObjectPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPermissionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkPartialUpdate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersBulkUpdate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersCreate(data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersList(id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20061>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersList(id, username, firstName, lastName, email, isStaff, isActive, q, groupId, group, idN, idLte, idLt, idGte, idGt, usernameN, usernameIc, usernameNic, usernameIew, usernameNiew, usernameIsw, usernameNisw, usernameIe, usernameNie, firstNameN, firstNameIc, firstNameNic, firstNameIew, firstNameNiew, firstNameIsw, firstNameNisw, firstNameIe, firstNameNie, lastNameN, lastNameIc, lastNameNic, lastNameIew, lastNameNiew, lastNameIsw, lastNameNisw, lastNameIe, lastNameNie, emailN, emailIc, emailNic, emailIew, emailNiew, emailIsw, emailNisw, emailIe, emailNie, groupIdN, groupN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersPartialUpdate(id: number, data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUsersUpdate(id: number, data: WritableUser, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUsersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Return the UserConfig for the currently authenticated User.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersConfigList(options?: any): AxiosPromise<void> {
            return localVarFp.usersConfigList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkPartialUpdate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsBulkUpdate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsCreate(data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsList(id?: string, name?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20059> {
            return localVarFp.usersGroupsList(id, name, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsPartialUpdate(id: number, data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsRead(id: number, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this group.
         * @param {Group} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGroupsUpdate(id: number, data: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.usersGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersPermissionsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkPartialUpdate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsBulkUpdate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsCreate(data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersPermissionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [objectTypes] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [objectTypesN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsList(id?: string, name?: string, enabled?: string, objectTypes?: string, userId?: string, user?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, objectTypesN?: string, userIdN?: string, userN?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20060> {
            return localVarFp.usersPermissionsList(id, name, enabled, objectTypes, userId, user, groupId, group, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, objectTypesN, userIdN, userN, groupIdN, groupN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsPartialUpdate(id: number, data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsRead(id: number, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this permission.
         * @param {WritableObjectPermission} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPermissionsUpdate(id: number, data: WritableObjectPermission, options?: any): AxiosPromise<ObjectPermission> {
            return localVarFp.usersPermissionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.usersUsersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkPartialUpdate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersBulkUpdate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersCreate(data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.usersUsersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [username] 
         * @param {string} [firstName] 
         * @param {string} [lastName] 
         * @param {string} [email] 
         * @param {string} [isStaff] 
         * @param {string} [isActive] 
         * @param {string} [q] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [usernameN] 
         * @param {string} [usernameIc] 
         * @param {string} [usernameNic] 
         * @param {string} [usernameIew] 
         * @param {string} [usernameNiew] 
         * @param {string} [usernameIsw] 
         * @param {string} [usernameNisw] 
         * @param {string} [usernameIe] 
         * @param {string} [usernameNie] 
         * @param {string} [firstNameN] 
         * @param {string} [firstNameIc] 
         * @param {string} [firstNameNic] 
         * @param {string} [firstNameIew] 
         * @param {string} [firstNameNiew] 
         * @param {string} [firstNameIsw] 
         * @param {string} [firstNameNisw] 
         * @param {string} [firstNameIe] 
         * @param {string} [firstNameNie] 
         * @param {string} [lastNameN] 
         * @param {string} [lastNameIc] 
         * @param {string} [lastNameNic] 
         * @param {string} [lastNameIew] 
         * @param {string} [lastNameNiew] 
         * @param {string} [lastNameIsw] 
         * @param {string} [lastNameNisw] 
         * @param {string} [lastNameIe] 
         * @param {string} [lastNameNie] 
         * @param {string} [emailN] 
         * @param {string} [emailIc] 
         * @param {string} [emailNic] 
         * @param {string} [emailIew] 
         * @param {string} [emailNiew] 
         * @param {string} [emailIsw] 
         * @param {string} [emailNisw] 
         * @param {string} [emailIe] 
         * @param {string} [emailNie] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersList(id?: string, username?: string, firstName?: string, lastName?: string, email?: string, isStaff?: string, isActive?: string, q?: string, groupId?: string, group?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, usernameN?: string, usernameIc?: string, usernameNic?: string, usernameIew?: string, usernameNiew?: string, usernameIsw?: string, usernameNisw?: string, usernameIe?: string, usernameNie?: string, firstNameN?: string, firstNameIc?: string, firstNameNic?: string, firstNameIew?: string, firstNameNiew?: string, firstNameIsw?: string, firstNameNisw?: string, firstNameIe?: string, firstNameNie?: string, lastNameN?: string, lastNameIc?: string, lastNameNic?: string, lastNameIew?: string, lastNameNiew?: string, lastNameIsw?: string, lastNameNisw?: string, lastNameIe?: string, lastNameNie?: string, emailN?: string, emailIc?: string, emailNic?: string, emailIew?: string, emailNiew?: string, emailIsw?: string, emailNisw?: string, emailIe?: string, emailNie?: string, groupIdN?: string, groupN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20061> {
            return localVarFp.usersUsersList(id, username, firstName, lastName, email, isStaff, isActive, q, groupId, group, idN, idLte, idLt, idGte, idGt, usernameN, usernameIc, usernameNic, usernameIew, usernameNiew, usernameIsw, usernameNisw, usernameIe, usernameNie, firstNameN, firstNameIc, firstNameNic, firstNameIew, firstNameNiew, firstNameIsw, firstNameNisw, firstNameIe, firstNameNie, lastNameN, lastNameIc, lastNameNic, lastNameIew, lastNameNiew, lastNameIsw, lastNameNisw, lastNameIe, lastNameNie, emailN, emailIc, emailNic, emailIew, emailNiew, emailIsw, emailNisw, emailIe, emailNie, groupIdN, groupN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersPartialUpdate(id: number, data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersRead(id: number, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this user.
         * @param {WritableUser} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUsersUpdate(id: number, data: WritableUser, options?: any): AxiosPromise<User> {
            return localVarFp.usersUsersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersGroupsBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsBulkPartialUpdateRequest
 */
export interface UsersApiUsersGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsBulkPartialUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsBulkUpdateRequest
 */
export interface UsersApiUsersGroupsBulkUpdateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsBulkUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsCreateRequest
 */
export interface UsersApiUsersGroupsCreateRequest {
    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsCreate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsDeleteRequest
 */
export interface UsersApiUsersGroupsDeleteRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersGroupsList operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsListRequest
 */
export interface UsersApiUsersGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersGroupsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersGroupsPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsPartialUpdateRequest
 */
export interface UsersApiUsersGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsPartialUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersGroupsRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsReadRequest
 */
export interface UsersApiUsersGroupsReadRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for usersGroupsUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersGroupsUpdateRequest
 */
export interface UsersApiUsersGroupsUpdateRequest {
    /**
     * A unique integer value identifying this group.
     * @type {number}
     * @memberof UsersApiUsersGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Group}
     * @memberof UsersApiUsersGroupsUpdate
     */
    readonly data: Group
}

/**
 * Request parameters for usersPermissionsBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsBulkPartialUpdateRequest
 */
export interface UsersApiUsersPermissionsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsBulkPartialUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsBulkUpdateRequest
 */
export interface UsersApiUsersPermissionsBulkUpdateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsBulkUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsCreateRequest
 */
export interface UsersApiUsersPermissionsCreateRequest {
    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsCreate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsDeleteRequest
 */
export interface UsersApiUsersPermissionsDeleteRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersPermissionsList operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsListRequest
 */
export interface UsersApiUsersPermissionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly objectTypes?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly objectTypesN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly groupN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersPermissionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersPermissionsPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsPartialUpdateRequest
 */
export interface UsersApiUsersPermissionsPartialUpdateRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsPartialUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersPermissionsRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsReadRequest
 */
export interface UsersApiUsersPermissionsReadRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsRead
     */
    readonly id: number
}

/**
 * Request parameters for usersPermissionsUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersPermissionsUpdateRequest
 */
export interface UsersApiUsersPermissionsUpdateRequest {
    /**
     * A unique integer value identifying this permission.
     * @type {number}
     * @memberof UsersApiUsersPermissionsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableObjectPermission}
     * @memberof UsersApiUsersPermissionsUpdate
     */
    readonly data: WritableObjectPermission
}

/**
 * Request parameters for usersUsersBulkPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersBulkPartialUpdateRequest
 */
export interface UsersApiUsersUsersBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersBulkPartialUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersBulkUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersBulkUpdateRequest
 */
export interface UsersApiUsersUsersBulkUpdateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersBulkUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersCreate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersCreateRequest
 */
export interface UsersApiUsersUsersCreateRequest {
    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersCreate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersDelete operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersDeleteRequest
 */
export interface UsersApiUsersUsersDeleteRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersDelete
     */
    readonly id: number
}

/**
 * Request parameters for usersUsersList operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersListRequest
 */
export interface UsersApiUsersUsersListRequest {
    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly username?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastName?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly email?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly isStaff?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly isActive?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly usernameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly firstNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly lastNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIc?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNic?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNiew?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIsw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNisw?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailIe?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly emailNie?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof UsersApiUsersUsersList
     */
    readonly groupN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof UsersApiUsersUsersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof UsersApiUsersUsersList
     */
    readonly offset?: number
}

/**
 * Request parameters for usersUsersPartialUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersPartialUpdateRequest
 */
export interface UsersApiUsersUsersPartialUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersPartialUpdate
     */
    readonly data: WritableUser
}

/**
 * Request parameters for usersUsersRead operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersReadRequest
 */
export interface UsersApiUsersUsersReadRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersRead
     */
    readonly id: number
}

/**
 * Request parameters for usersUsersUpdate operation in UsersApi.
 * @export
 * @interface UsersApiUsersUsersUpdateRequest
 */
export interface UsersApiUsersUsersUpdateRequest {
    /**
     * A unique integer value identifying this user.
     * @type {number}
     * @memberof UsersApiUsersUsersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableUser}
     * @memberof UsersApiUsersUsersUpdate
     */
    readonly data: WritableUser
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Return the UserConfig for the currently authenticated User.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersConfigList(options?: any) {
        return UsersApiFp(this.configuration).usersConfigList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkPartialUpdate(requestParameters: UsersApiUsersGroupsBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsBulkUpdate(requestParameters: UsersApiUsersGroupsBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsCreate(requestParameters: UsersApiUsersGroupsCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsDelete(requestParameters: UsersApiUsersGroupsDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsList(requestParameters: UsersApiUsersGroupsListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsPartialUpdate(requestParameters: UsersApiUsersGroupsPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsRead(requestParameters: UsersApiUsersGroupsReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGroupsUpdate(requestParameters: UsersApiUsersGroupsUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkPartialUpdate(requestParameters: UsersApiUsersPermissionsBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsBulkUpdate(requestParameters: UsersApiUsersPermissionsBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsCreate(requestParameters: UsersApiUsersPermissionsCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsDelete(requestParameters: UsersApiUsersPermissionsDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsList(requestParameters: UsersApiUsersPermissionsListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsList(requestParameters.id, requestParameters.name, requestParameters.enabled, requestParameters.objectTypes, requestParameters.userId, requestParameters.user, requestParameters.groupId, requestParameters.group, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.objectTypesN, requestParameters.userIdN, requestParameters.userN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsPartialUpdate(requestParameters: UsersApiUsersPermissionsPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsRead(requestParameters: UsersApiUsersPermissionsReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersPermissionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPermissionsUpdate(requestParameters: UsersApiUsersPermissionsUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersPermissionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkDelete(options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkPartialUpdate(requestParameters: UsersApiUsersUsersBulkPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersBulkUpdate(requestParameters: UsersApiUsersUsersBulkUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersCreate(requestParameters: UsersApiUsersUsersCreateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersDelete(requestParameters: UsersApiUsersUsersDeleteRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersList(requestParameters: UsersApiUsersUsersListRequest = {}, options?: any) {
        return UsersApiFp(this.configuration).usersUsersList(requestParameters.id, requestParameters.username, requestParameters.firstName, requestParameters.lastName, requestParameters.email, requestParameters.isStaff, requestParameters.isActive, requestParameters.q, requestParameters.groupId, requestParameters.group, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.usernameN, requestParameters.usernameIc, requestParameters.usernameNic, requestParameters.usernameIew, requestParameters.usernameNiew, requestParameters.usernameIsw, requestParameters.usernameNisw, requestParameters.usernameIe, requestParameters.usernameNie, requestParameters.firstNameN, requestParameters.firstNameIc, requestParameters.firstNameNic, requestParameters.firstNameIew, requestParameters.firstNameNiew, requestParameters.firstNameIsw, requestParameters.firstNameNisw, requestParameters.firstNameIe, requestParameters.firstNameNie, requestParameters.lastNameN, requestParameters.lastNameIc, requestParameters.lastNameNic, requestParameters.lastNameIew, requestParameters.lastNameNiew, requestParameters.lastNameIsw, requestParameters.lastNameNisw, requestParameters.lastNameIe, requestParameters.lastNameNie, requestParameters.emailN, requestParameters.emailIc, requestParameters.emailNic, requestParameters.emailIew, requestParameters.emailNiew, requestParameters.emailIsw, requestParameters.emailNisw, requestParameters.emailIe, requestParameters.emailNie, requestParameters.groupIdN, requestParameters.groupN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersPartialUpdate(requestParameters: UsersApiUsersUsersPartialUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersRead(requestParameters: UsersApiUsersUsersReadRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UsersApiUsersUsersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUsersUpdate(requestParameters: UsersApiUsersUsersUpdateRequest, options?: any) {
        return UsersApiFp(this.configuration).usersUsersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}
