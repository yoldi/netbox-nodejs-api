/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Circuit } from '../models';
// @ts-ignore
import { CircuitTermination } from '../models';
// @ts-ignore
import { CircuitType } from '../models';
// @ts-ignore
import { InlineResponse200 } from '../models';
// @ts-ignore
import { InlineResponse2001 } from '../models';
// @ts-ignore
import { InlineResponse2002 } from '../models';
// @ts-ignore
import { InlineResponse2003 } from '../models';
// @ts-ignore
import { Provider } from '../models';
// @ts-ignore
import { WritableCircuit } from '../models';
// @ts-ignore
import { WritableCircuitTermination } from '../models';
/**
 * CircuitsApi - axios parameter creator
 * @export
 */
export const CircuitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkPartialUpdate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkUpdate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsCreate: async (data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsCreate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsDelete', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsList: async (termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-terminations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (termSide !== undefined) {
                localVarQueryParameter['term_side'] = termSide;
            }

            if (portSpeed !== undefined) {
                localVarQueryParameter['port_speed'] = portSpeed;
            }

            if (upstreamSpeed !== undefined) {
                localVarQueryParameter['upstream_speed'] = upstreamSpeed;
            }

            if (xconnectId !== undefined) {
                localVarQueryParameter['xconnect_id'] = xconnectId;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (circuitId !== undefined) {
                localVarQueryParameter['circuit_id'] = circuitId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (termSideN !== undefined) {
                localVarQueryParameter['term_side__n'] = termSideN;
            }

            if (portSpeedN !== undefined) {
                localVarQueryParameter['port_speed__n'] = portSpeedN;
            }

            if (portSpeedLte !== undefined) {
                localVarQueryParameter['port_speed__lte'] = portSpeedLte;
            }

            if (portSpeedLt !== undefined) {
                localVarQueryParameter['port_speed__lt'] = portSpeedLt;
            }

            if (portSpeedGte !== undefined) {
                localVarQueryParameter['port_speed__gte'] = portSpeedGte;
            }

            if (portSpeedGt !== undefined) {
                localVarQueryParameter['port_speed__gt'] = portSpeedGt;
            }

            if (upstreamSpeedN !== undefined) {
                localVarQueryParameter['upstream_speed__n'] = upstreamSpeedN;
            }

            if (upstreamSpeedLte !== undefined) {
                localVarQueryParameter['upstream_speed__lte'] = upstreamSpeedLte;
            }

            if (upstreamSpeedLt !== undefined) {
                localVarQueryParameter['upstream_speed__lt'] = upstreamSpeedLt;
            }

            if (upstreamSpeedGte !== undefined) {
                localVarQueryParameter['upstream_speed__gte'] = upstreamSpeedGte;
            }

            if (upstreamSpeedGt !== undefined) {
                localVarQueryParameter['upstream_speed__gt'] = upstreamSpeedGt;
            }

            if (xconnectIdN !== undefined) {
                localVarQueryParameter['xconnect_id__n'] = xconnectIdN;
            }

            if (xconnectIdIc !== undefined) {
                localVarQueryParameter['xconnect_id__ic'] = xconnectIdIc;
            }

            if (xconnectIdNic !== undefined) {
                localVarQueryParameter['xconnect_id__nic'] = xconnectIdNic;
            }

            if (xconnectIdIew !== undefined) {
                localVarQueryParameter['xconnect_id__iew'] = xconnectIdIew;
            }

            if (xconnectIdNiew !== undefined) {
                localVarQueryParameter['xconnect_id__niew'] = xconnectIdNiew;
            }

            if (xconnectIdIsw !== undefined) {
                localVarQueryParameter['xconnect_id__isw'] = xconnectIdIsw;
            }

            if (xconnectIdNisw !== undefined) {
                localVarQueryParameter['xconnect_id__nisw'] = xconnectIdNisw;
            }

            if (xconnectIdIe !== undefined) {
                localVarQueryParameter['xconnect_id__ie'] = xconnectIdIe;
            }

            if (xconnectIdNie !== undefined) {
                localVarQueryParameter['xconnect_id__nie'] = xconnectIdNie;
            }

            if (circuitIdN !== undefined) {
                localVarQueryParameter['circuit_id__n'] = circuitIdN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsPartialUpdate: async (id: number, data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsRead', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsTrace', 'id', id)
            const localVarPath = `/circuits/circuit-terminations/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsUpdate: async (id: number, data: WritableCircuitTermination, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTerminationsUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-terminations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkPartialUpdate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkUpdate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesCreate: async (data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesCreate', 'data', data)
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesDelete', 'id', id)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesList: async (id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuit-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesPartialUpdate: async (id: number, data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesRead', 'id', id)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesUpdate: async (id: number, data: CircuitType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitTypesUpdate', 'data', data)
            const localVarPath = `/circuits/circuit-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkPartialUpdate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkUpdate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsBulkUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsCreate: async (data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsCreate', 'data', data)
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsDelete', 'id', id)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsList: async (id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/circuits/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (cid !== undefined) {
                localVarQueryParameter['cid'] = cid;
            }

            if (installDate !== undefined) {
                localVarQueryParameter['install_date'] = installDate;
            }

            if (commitRate !== undefined) {
                localVarQueryParameter['commit_rate'] = commitRate;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (providerId !== undefined) {
                localVarQueryParameter['provider_id'] = providerId;
            }

            if (provider !== undefined) {
                localVarQueryParameter['provider'] = provider;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (cidN !== undefined) {
                localVarQueryParameter['cid__n'] = cidN;
            }

            if (cidIc !== undefined) {
                localVarQueryParameter['cid__ic'] = cidIc;
            }

            if (cidNic !== undefined) {
                localVarQueryParameter['cid__nic'] = cidNic;
            }

            if (cidIew !== undefined) {
                localVarQueryParameter['cid__iew'] = cidIew;
            }

            if (cidNiew !== undefined) {
                localVarQueryParameter['cid__niew'] = cidNiew;
            }

            if (cidIsw !== undefined) {
                localVarQueryParameter['cid__isw'] = cidIsw;
            }

            if (cidNisw !== undefined) {
                localVarQueryParameter['cid__nisw'] = cidNisw;
            }

            if (cidIe !== undefined) {
                localVarQueryParameter['cid__ie'] = cidIe;
            }

            if (cidNie !== undefined) {
                localVarQueryParameter['cid__nie'] = cidNie;
            }

            if (installDateN !== undefined) {
                localVarQueryParameter['install_date__n'] = installDateN;
            }

            if (installDateLte !== undefined) {
                localVarQueryParameter['install_date__lte'] = installDateLte;
            }

            if (installDateLt !== undefined) {
                localVarQueryParameter['install_date__lt'] = installDateLt;
            }

            if (installDateGte !== undefined) {
                localVarQueryParameter['install_date__gte'] = installDateGte;
            }

            if (installDateGt !== undefined) {
                localVarQueryParameter['install_date__gt'] = installDateGt;
            }

            if (commitRateN !== undefined) {
                localVarQueryParameter['commit_rate__n'] = commitRateN;
            }

            if (commitRateLte !== undefined) {
                localVarQueryParameter['commit_rate__lte'] = commitRateLte;
            }

            if (commitRateLt !== undefined) {
                localVarQueryParameter['commit_rate__lt'] = commitRateLt;
            }

            if (commitRateGte !== undefined) {
                localVarQueryParameter['commit_rate__gte'] = commitRateGte;
            }

            if (commitRateGt !== undefined) {
                localVarQueryParameter['commit_rate__gt'] = commitRateGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (providerIdN !== undefined) {
                localVarQueryParameter['provider_id__n'] = providerIdN;
            }

            if (providerN !== undefined) {
                localVarQueryParameter['provider__n'] = providerN;
            }

            if (typeIdN !== undefined) {
                localVarQueryParameter['type_id__n'] = typeIdN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsPartialUpdate: async (id: number, data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsPartialUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsRead', 'id', id)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsUpdate: async (id: number, data: WritableCircuit, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsCircuitsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsCircuitsUpdate', 'data', data)
            const localVarPath = `/circuits/circuits/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkPartialUpdate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersBulkPartialUpdate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkUpdate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersBulkUpdate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersCreate: async (data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersCreate', 'data', data)
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersDelete', 'id', id)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersList: async (id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/circuits/providers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (account !== undefined) {
                localVarQueryParameter['account'] = account;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (asnN !== undefined) {
                localVarQueryParameter['asn__n'] = asnN;
            }

            if (asnLte !== undefined) {
                localVarQueryParameter['asn__lte'] = asnLte;
            }

            if (asnLt !== undefined) {
                localVarQueryParameter['asn__lt'] = asnLt;
            }

            if (asnGte !== undefined) {
                localVarQueryParameter['asn__gte'] = asnGte;
            }

            if (asnGt !== undefined) {
                localVarQueryParameter['asn__gt'] = asnGt;
            }

            if (accountN !== undefined) {
                localVarQueryParameter['account__n'] = accountN;
            }

            if (accountIc !== undefined) {
                localVarQueryParameter['account__ic'] = accountIc;
            }

            if (accountNic !== undefined) {
                localVarQueryParameter['account__nic'] = accountNic;
            }

            if (accountIew !== undefined) {
                localVarQueryParameter['account__iew'] = accountIew;
            }

            if (accountNiew !== undefined) {
                localVarQueryParameter['account__niew'] = accountNiew;
            }

            if (accountIsw !== undefined) {
                localVarQueryParameter['account__isw'] = accountIsw;
            }

            if (accountNisw !== undefined) {
                localVarQueryParameter['account__nisw'] = accountNisw;
            }

            if (accountIe !== undefined) {
                localVarQueryParameter['account__ie'] = accountIe;
            }

            if (accountNie !== undefined) {
                localVarQueryParameter['account__nie'] = accountNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersPartialUpdate: async (id: number, data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersPartialUpdate', 'data', data)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersRead', 'id', id)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersUpdate: async (id: number, data: Provider, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('circuitsProvidersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('circuitsProvidersUpdate', 'data', data)
            const localVarPath = `/circuits/providers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CircuitsApi - functional programming interface
 * @export
 */
export const CircuitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CircuitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkPartialUpdate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsBulkUpdate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsCreate(data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsList(termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsList(termSide, portSpeed, upstreamSpeed, xconnectId, cabled, connected, q, circuitId, siteId, site, termSideN, portSpeedN, portSpeedLte, portSpeedLt, portSpeedGte, portSpeedGt, upstreamSpeedN, upstreamSpeedLte, upstreamSpeedLt, upstreamSpeedGte, upstreamSpeedGt, xconnectIdN, xconnectIdIc, xconnectIdNic, xconnectIdIew, xconnectIdNiew, xconnectIdIsw, xconnectIdNisw, xconnectIdIe, xconnectIdNie, circuitIdN, siteIdN, siteN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsPartialUpdate(id: number, data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTerminationsUpdate(id: number, data: WritableCircuitTermination, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitTermination>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTerminationsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkPartialUpdate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesBulkUpdate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesCreate(data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesPartialUpdate(id: number, data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitTypesUpdate(id: number, data: CircuitType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CircuitType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkPartialUpdate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsBulkUpdate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsCreate(data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsList(id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsList(id, cid, installDate, commitRate, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, providerId, provider, typeId, type, status, siteId, site, regionId, region, tag, idN, idLte, idLt, idGte, idGt, cidN, cidIc, cidNic, cidIew, cidNiew, cidIsw, cidNisw, cidIe, cidNie, installDateN, installDateLte, installDateLt, installDateGte, installDateGt, commitRateN, commitRateLte, commitRateLt, commitRateGte, commitRateGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, providerIdN, providerN, typeIdN, typeN, statusN, siteIdN, siteN, regionIdN, regionN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsPartialUpdate(id: number, data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsCircuitsUpdate(id: number, data: WritableCircuit, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Circuit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsCircuitsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkPartialUpdate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersBulkUpdate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersCreate(data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersList(id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersList(id, name, slug, asn, account, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, asnN, asnLte, asnLt, asnGte, asnGt, accountN, accountIc, accountNic, accountIew, accountNiew, accountIsw, accountNisw, accountIe, accountNie, regionIdN, regionN, siteIdN, siteN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersPartialUpdate(id: number, data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async circuitsProvidersUpdate(id: number, data: Provider, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Provider>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.circuitsProvidersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CircuitsApi - factory interface
 * @export
 */
export const CircuitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CircuitsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTerminationsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkPartialUpdate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsBulkUpdate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsCreate(data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTerminationsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [termSide] 
         * @param {string} [portSpeed] 
         * @param {string} [upstreamSpeed] 
         * @param {string} [xconnectId] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [q] 
         * @param {string} [circuitId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [termSideN] 
         * @param {string} [portSpeedN] 
         * @param {string} [portSpeedLte] 
         * @param {string} [portSpeedLt] 
         * @param {string} [portSpeedGte] 
         * @param {string} [portSpeedGt] 
         * @param {string} [upstreamSpeedN] 
         * @param {string} [upstreamSpeedLte] 
         * @param {string} [upstreamSpeedLt] 
         * @param {string} [upstreamSpeedGte] 
         * @param {string} [upstreamSpeedGt] 
         * @param {string} [xconnectIdN] 
         * @param {string} [xconnectIdIc] 
         * @param {string} [xconnectIdNic] 
         * @param {string} [xconnectIdIew] 
         * @param {string} [xconnectIdNiew] 
         * @param {string} [xconnectIdIsw] 
         * @param {string} [xconnectIdNisw] 
         * @param {string} [xconnectIdIe] 
         * @param {string} [xconnectIdNie] 
         * @param {string} [circuitIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsList(termSide?: string, portSpeed?: string, upstreamSpeed?: string, xconnectId?: string, cabled?: string, connected?: string, q?: string, circuitId?: string, siteId?: string, site?: string, termSideN?: string, portSpeedN?: string, portSpeedLte?: string, portSpeedLt?: string, portSpeedGte?: string, portSpeedGt?: string, upstreamSpeedN?: string, upstreamSpeedLte?: string, upstreamSpeedLt?: string, upstreamSpeedGte?: string, upstreamSpeedGt?: string, xconnectIdN?: string, xconnectIdIc?: string, xconnectIdNic?: string, xconnectIdIew?: string, xconnectIdNiew?: string, xconnectIdIsw?: string, xconnectIdNisw?: string, xconnectIdIe?: string, xconnectIdNie?: string, circuitIdN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.circuitsCircuitTerminationsList(termSide, portSpeed, upstreamSpeed, xconnectId, cabled, connected, q, circuitId, siteId, site, termSideN, portSpeedN, portSpeedLte, portSpeedLt, portSpeedGte, portSpeedGt, upstreamSpeedN, upstreamSpeedLte, upstreamSpeedLt, upstreamSpeedGte, upstreamSpeedGt, xconnectIdN, xconnectIdIc, xconnectIdNic, xconnectIdIew, xconnectIdNiew, xconnectIdIsw, xconnectIdNisw, xconnectIdIe, xconnectIdNie, circuitIdN, siteIdN, siteN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsPartialUpdate(id: number, data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsRead(id: number, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsTrace(id: number, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit termination.
         * @param {WritableCircuitTermination} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTerminationsUpdate(id: number, data: WritableCircuitTermination, options?: any): AxiosPromise<CircuitTermination> {
            return localVarFp.circuitsCircuitTerminationsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkPartialUpdate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesBulkUpdate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesCreate(data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.circuitsCircuitTypesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesPartialUpdate(id: number, data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesRead(id: number, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit type.
         * @param {CircuitType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitTypesUpdate(id: number, data: CircuitType, options?: any): AxiosPromise<CircuitType> {
            return localVarFp.circuitsCircuitTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkPartialUpdate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsBulkUpdate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsCreate(data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsCircuitsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [cid] 
         * @param {string} [installDate] 
         * @param {string} [commitRate] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [providerId] 
         * @param {string} [provider] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [cidN] 
         * @param {string} [cidIc] 
         * @param {string} [cidNic] 
         * @param {string} [cidIew] 
         * @param {string} [cidNiew] 
         * @param {string} [cidIsw] 
         * @param {string} [cidNisw] 
         * @param {string} [cidIe] 
         * @param {string} [cidNie] 
         * @param {string} [installDateN] 
         * @param {string} [installDateLte] 
         * @param {string} [installDateLt] 
         * @param {string} [installDateGte] 
         * @param {string} [installDateGt] 
         * @param {string} [commitRateN] 
         * @param {string} [commitRateLte] 
         * @param {string} [commitRateLt] 
         * @param {string} [commitRateGte] 
         * @param {string} [commitRateGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [providerIdN] 
         * @param {string} [providerN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsList(id?: string, cid?: string, installDate?: string, commitRate?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, providerId?: string, provider?: string, typeId?: string, type?: string, status?: string, siteId?: string, site?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, cidN?: string, cidIc?: string, cidNic?: string, cidIew?: string, cidNiew?: string, cidIsw?: string, cidNisw?: string, cidIe?: string, cidNie?: string, installDateN?: string, installDateLte?: string, installDateLt?: string, installDateGte?: string, installDateGt?: string, commitRateN?: string, commitRateLte?: string, commitRateLt?: string, commitRateGte?: string, commitRateGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, providerIdN?: string, providerN?: string, typeIdN?: string, typeN?: string, statusN?: string, siteIdN?: string, siteN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.circuitsCircuitsList(id, cid, installDate, commitRate, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, providerId, provider, typeId, type, status, siteId, site, regionId, region, tag, idN, idLte, idLt, idGte, idGt, cidN, cidIc, cidNic, cidIew, cidNiew, cidIsw, cidNisw, cidIe, cidNie, installDateN, installDateLte, installDateLt, installDateGte, installDateGt, commitRateN, commitRateLte, commitRateLt, commitRateGte, commitRateGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, providerIdN, providerN, typeIdN, typeN, statusN, siteIdN, siteN, regionIdN, regionN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsPartialUpdate(id: number, data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsRead(id: number, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this circuit.
         * @param {WritableCircuit} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsCircuitsUpdate(id: number, data: WritableCircuit, options?: any): AxiosPromise<Circuit> {
            return localVarFp.circuitsCircuitsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.circuitsProvidersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkPartialUpdate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersBulkUpdate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersCreate(data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.circuitsProvidersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [asn] 
         * @param {string} [account] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [accountN] 
         * @param {string} [accountIc] 
         * @param {string} [accountNic] 
         * @param {string} [accountIew] 
         * @param {string} [accountNiew] 
         * @param {string} [accountIsw] 
         * @param {string} [accountNisw] 
         * @param {string} [accountIe] 
         * @param {string} [accountNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersList(id?: string, name?: string, slug?: string, asn?: string, account?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, accountN?: string, accountIc?: string, accountNic?: string, accountIew?: string, accountNiew?: string, accountIsw?: string, accountNisw?: string, accountIe?: string, accountNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.circuitsProvidersList(id, name, slug, asn, account, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, asnN, asnLte, asnLt, asnGte, asnGt, accountN, accountIc, accountNic, accountIew, accountNiew, accountIsw, accountNisw, accountIe, accountNie, regionIdN, regionN, siteIdN, siteN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersPartialUpdate(id: number, data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersRead(id: number, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this provider.
         * @param {Provider} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        circuitsProvidersUpdate(id: number, data: Provider, options?: any): AxiosPromise<Provider> {
            return localVarFp.circuitsProvidersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for circuitsCircuitTerminationsBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsBulkUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsCreateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsCreateRequest {
    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsCreate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsDeleteRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsListRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly termSide?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeed?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeed?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly circuitId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly termSideN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly portSpeedGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly upstreamSpeedGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly xconnectIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly circuitIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly siteN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitTerminationsPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsPartialUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTerminationsRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsReadRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsReadRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsTrace operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsTraceRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsTraceRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsTrace
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTerminationsUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTerminationsUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTerminationsUpdateRequest {
    /**
     * A unique integer value identifying this circuit termination.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTerminationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuitTermination}
     * @memberof CircuitsApiCircuitsCircuitTerminationsUpdate
     */
    readonly data: WritableCircuitTermination
}

/**
 * Request parameters for circuitsCircuitTypesBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesBulkPartialUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesBulkUpdateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesBulkUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesCreateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesCreateRequest {
    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesCreate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitTypesDeleteRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTypesList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesListRequest
 */
export interface CircuitsApiCircuitsCircuitTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly slugNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitTypesPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesPartialUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitTypesRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesReadRequest
 */
export interface CircuitsApiCircuitsCircuitTypesReadRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitTypesUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitTypesUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitTypesUpdateRequest {
    /**
     * A unique integer value identifying this circuit type.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {CircuitType}
     * @memberof CircuitsApiCircuitsCircuitTypesUpdate
     */
    readonly data: CircuitType
}

/**
 * Request parameters for circuitsCircuitsBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsBulkPartialUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsBulkUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsBulkUpdateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsBulkUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsCreateRequest
 */
export interface CircuitsApiCircuitsCircuitsCreateRequest {
    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsCreate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsDeleteRequest
 */
export interface CircuitsApiCircuitsCircuitsDeleteRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitsList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsListRequest
 */
export interface CircuitsApiCircuitsCircuitsListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cid?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDate?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRate?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly provider?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly cidNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly installDateGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly commitRateGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly providerN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsCircuitsPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsPartialUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsPartialUpdateRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsPartialUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsCircuitsRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsReadRequest
 */
export interface CircuitsApiCircuitsCircuitsReadRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsCircuitsUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsCircuitsUpdateRequest
 */
export interface CircuitsApiCircuitsCircuitsUpdateRequest {
    /**
     * A unique integer value identifying this circuit.
     * @type {number}
     * @memberof CircuitsApiCircuitsCircuitsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCircuit}
     * @memberof CircuitsApiCircuitsCircuitsUpdate
     */
    readonly data: WritableCircuit
}

/**
 * Request parameters for circuitsProvidersBulkPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersBulkPartialUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersBulkPartialUpdateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersBulkPartialUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersBulkUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersBulkUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersBulkUpdateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersBulkUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersCreate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersCreateRequest
 */
export interface CircuitsApiCircuitsProvidersCreateRequest {
    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersCreate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersDelete operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersDeleteRequest
 */
export interface CircuitsApiCircuitsProvidersDeleteRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersDelete
     */
    readonly id: number
}

/**
 * Request parameters for circuitsProvidersList operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersListRequest
 */
export interface CircuitsApiCircuitsProvidersListRequest {
    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asn?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly account?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnLte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnLt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnGte?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly asnGt?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIc?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNic?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNiew?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIsw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNisw?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountIe?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly accountNie?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersList
     */
    readonly offset?: number
}

/**
 * Request parameters for circuitsProvidersPartialUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersPartialUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersPartialUpdateRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersPartialUpdate
     */
    readonly data: Provider
}

/**
 * Request parameters for circuitsProvidersRead operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersReadRequest
 */
export interface CircuitsApiCircuitsProvidersReadRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersRead
     */
    readonly id: number
}

/**
 * Request parameters for circuitsProvidersUpdate operation in CircuitsApi.
 * @export
 * @interface CircuitsApiCircuitsProvidersUpdateRequest
 */
export interface CircuitsApiCircuitsProvidersUpdateRequest {
    /**
     * A unique integer value identifying this provider.
     * @type {number}
     * @memberof CircuitsApiCircuitsProvidersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Provider}
     * @memberof CircuitsApiCircuitsProvidersUpdate
     */
    readonly data: Provider
}

/**
 * CircuitsApi - object-oriented interface
 * @export
 * @class CircuitsApi
 * @extends {BaseAPI}
 */
export class CircuitsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsCreate(requestParameters: CircuitsApiCircuitsCircuitTerminationsCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsDelete(requestParameters: CircuitsApiCircuitsCircuitTerminationsDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsList(requestParameters: CircuitsApiCircuitsCircuitTerminationsListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsList(requestParameters.termSide, requestParameters.portSpeed, requestParameters.upstreamSpeed, requestParameters.xconnectId, requestParameters.cabled, requestParameters.connected, requestParameters.q, requestParameters.circuitId, requestParameters.siteId, requestParameters.site, requestParameters.termSideN, requestParameters.portSpeedN, requestParameters.portSpeedLte, requestParameters.portSpeedLt, requestParameters.portSpeedGte, requestParameters.portSpeedGt, requestParameters.upstreamSpeedN, requestParameters.upstreamSpeedLte, requestParameters.upstreamSpeedLt, requestParameters.upstreamSpeedGte, requestParameters.upstreamSpeedGt, requestParameters.xconnectIdN, requestParameters.xconnectIdIc, requestParameters.xconnectIdNic, requestParameters.xconnectIdIew, requestParameters.xconnectIdNiew, requestParameters.xconnectIdIsw, requestParameters.xconnectIdNisw, requestParameters.xconnectIdIe, requestParameters.xconnectIdNie, requestParameters.circuitIdN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsRead(requestParameters: CircuitsApiCircuitsCircuitTerminationsReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {CircuitsApiCircuitsCircuitTerminationsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsTrace(requestParameters: CircuitsApiCircuitsCircuitTerminationsTraceRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTerminationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTerminationsUpdate(requestParameters: CircuitsApiCircuitsCircuitTerminationsUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTerminationsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesCreate(requestParameters: CircuitsApiCircuitsCircuitTypesCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesDelete(requestParameters: CircuitsApiCircuitsCircuitTypesDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesList(requestParameters: CircuitsApiCircuitsCircuitTypesListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesRead(requestParameters: CircuitsApiCircuitsCircuitTypesReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitTypesUpdate(requestParameters: CircuitsApiCircuitsCircuitTypesUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitsBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsBulkUpdate(requestParameters: CircuitsApiCircuitsCircuitsBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsCreate(requestParameters: CircuitsApiCircuitsCircuitsCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsDelete(requestParameters: CircuitsApiCircuitsCircuitsDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsList(requestParameters: CircuitsApiCircuitsCircuitsListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsList(requestParameters.id, requestParameters.cid, requestParameters.installDate, requestParameters.commitRate, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.providerId, requestParameters.provider, requestParameters.typeId, requestParameters.type, requestParameters.status, requestParameters.siteId, requestParameters.site, requestParameters.regionId, requestParameters.region, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.cidN, requestParameters.cidIc, requestParameters.cidNic, requestParameters.cidIew, requestParameters.cidNiew, requestParameters.cidIsw, requestParameters.cidNisw, requestParameters.cidIe, requestParameters.cidNie, requestParameters.installDateN, requestParameters.installDateLte, requestParameters.installDateLt, requestParameters.installDateGte, requestParameters.installDateGt, requestParameters.commitRateN, requestParameters.commitRateLte, requestParameters.commitRateLt, requestParameters.commitRateGte, requestParameters.commitRateGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.providerIdN, requestParameters.providerN, requestParameters.typeIdN, requestParameters.typeN, requestParameters.statusN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsPartialUpdate(requestParameters: CircuitsApiCircuitsCircuitsPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsRead(requestParameters: CircuitsApiCircuitsCircuitsReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsCircuitsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsCircuitsUpdate(requestParameters: CircuitsApiCircuitsCircuitsUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsCircuitsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkDelete(options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkPartialUpdate(requestParameters: CircuitsApiCircuitsProvidersBulkPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersBulkUpdate(requestParameters: CircuitsApiCircuitsProvidersBulkUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersCreate(requestParameters: CircuitsApiCircuitsProvidersCreateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersDelete(requestParameters: CircuitsApiCircuitsProvidersDeleteRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersList(requestParameters: CircuitsApiCircuitsProvidersListRequest = {}, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.asn, requestParameters.account, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.asnN, requestParameters.asnLte, requestParameters.asnLt, requestParameters.asnGte, requestParameters.asnGt, requestParameters.accountN, requestParameters.accountIc, requestParameters.accountNic, requestParameters.accountIew, requestParameters.accountNiew, requestParameters.accountIsw, requestParameters.accountNisw, requestParameters.accountIe, requestParameters.accountNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersPartialUpdate(requestParameters: CircuitsApiCircuitsProvidersPartialUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersRead(requestParameters: CircuitsApiCircuitsProvidersReadRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CircuitsApiCircuitsProvidersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CircuitsApi
     */
    public circuitsProvidersUpdate(requestParameters: CircuitsApiCircuitsProvidersUpdateRequest, options?: any) {
        return CircuitsApiFp(this.configuration).circuitsProvidersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}
