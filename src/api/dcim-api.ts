/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Cable } from '../models';
// @ts-ignore
import { ConsolePort } from '../models';
// @ts-ignore
import { ConsolePortTemplate } from '../models';
// @ts-ignore
import { ConsoleServerPort } from '../models';
// @ts-ignore
import { ConsoleServerPortTemplate } from '../models';
// @ts-ignore
import { Device } from '../models';
// @ts-ignore
import { DeviceBay } from '../models';
// @ts-ignore
import { DeviceBayTemplate } from '../models';
// @ts-ignore
import { DeviceNAPALM } from '../models';
// @ts-ignore
import { DeviceRole } from '../models';
// @ts-ignore
import { DeviceType } from '../models';
// @ts-ignore
import { DeviceWithConfigContext } from '../models';
// @ts-ignore
import { FrontPort } from '../models';
// @ts-ignore
import { FrontPortTemplate } from '../models';
// @ts-ignore
import { InlineResponse20010 } from '../models';
// @ts-ignore
import { InlineResponse20011 } from '../models';
// @ts-ignore
import { InlineResponse20012 } from '../models';
// @ts-ignore
import { InlineResponse20013 } from '../models';
// @ts-ignore
import { InlineResponse20014 } from '../models';
// @ts-ignore
import { InlineResponse20015 } from '../models';
// @ts-ignore
import { InlineResponse20016 } from '../models';
// @ts-ignore
import { InlineResponse20017 } from '../models';
// @ts-ignore
import { InlineResponse20018 } from '../models';
// @ts-ignore
import { InlineResponse20019 } from '../models';
// @ts-ignore
import { InlineResponse20020 } from '../models';
// @ts-ignore
import { InlineResponse20021 } from '../models';
// @ts-ignore
import { InlineResponse20022 } from '../models';
// @ts-ignore
import { InlineResponse20023 } from '../models';
// @ts-ignore
import { InlineResponse20024 } from '../models';
// @ts-ignore
import { InlineResponse20025 } from '../models';
// @ts-ignore
import { InlineResponse20026 } from '../models';
// @ts-ignore
import { InlineResponse20027 } from '../models';
// @ts-ignore
import { InlineResponse20028 } from '../models';
// @ts-ignore
import { InlineResponse20029 } from '../models';
// @ts-ignore
import { InlineResponse20030 } from '../models';
// @ts-ignore
import { InlineResponse20031 } from '../models';
// @ts-ignore
import { InlineResponse20032 } from '../models';
// @ts-ignore
import { InlineResponse20033 } from '../models';
// @ts-ignore
import { InlineResponse20034 } from '../models';
// @ts-ignore
import { InlineResponse20035 } from '../models';
// @ts-ignore
import { InlineResponse20036 } from '../models';
// @ts-ignore
import { InlineResponse2004 } from '../models';
// @ts-ignore
import { InlineResponse2005 } from '../models';
// @ts-ignore
import { InlineResponse2006 } from '../models';
// @ts-ignore
import { InlineResponse2007 } from '../models';
// @ts-ignore
import { InlineResponse2008 } from '../models';
// @ts-ignore
import { InlineResponse2009 } from '../models';
// @ts-ignore
import { Interface } from '../models';
// @ts-ignore
import { InterfaceTemplate } from '../models';
// @ts-ignore
import { InventoryItem } from '../models';
// @ts-ignore
import { Manufacturer } from '../models';
// @ts-ignore
import { Platform } from '../models';
// @ts-ignore
import { PowerFeed } from '../models';
// @ts-ignore
import { PowerOutlet } from '../models';
// @ts-ignore
import { PowerOutletTemplate } from '../models';
// @ts-ignore
import { PowerPanel } from '../models';
// @ts-ignore
import { PowerPort } from '../models';
// @ts-ignore
import { PowerPortTemplate } from '../models';
// @ts-ignore
import { Rack } from '../models';
// @ts-ignore
import { RackGroup } from '../models';
// @ts-ignore
import { RackReservation } from '../models';
// @ts-ignore
import { RackRole } from '../models';
// @ts-ignore
import { RackUnit } from '../models';
// @ts-ignore
import { RearPort } from '../models';
// @ts-ignore
import { RearPortTemplate } from '../models';
// @ts-ignore
import { Region } from '../models';
// @ts-ignore
import { Site } from '../models';
// @ts-ignore
import { VirtualChassis } from '../models';
// @ts-ignore
import { WritableCable } from '../models';
// @ts-ignore
import { WritableConsolePort } from '../models';
// @ts-ignore
import { WritableConsolePortTemplate } from '../models';
// @ts-ignore
import { WritableConsoleServerPort } from '../models';
// @ts-ignore
import { WritableConsoleServerPortTemplate } from '../models';
// @ts-ignore
import { WritableDeviceBay } from '../models';
// @ts-ignore
import { WritableDeviceBayTemplate } from '../models';
// @ts-ignore
import { WritableDeviceType } from '../models';
// @ts-ignore
import { WritableDeviceWithConfigContext } from '../models';
// @ts-ignore
import { WritableFrontPort } from '../models';
// @ts-ignore
import { WritableFrontPortTemplate } from '../models';
// @ts-ignore
import { WritableInterface } from '../models';
// @ts-ignore
import { WritableInterfaceTemplate } from '../models';
// @ts-ignore
import { WritableInventoryItem } from '../models';
// @ts-ignore
import { WritablePlatform } from '../models';
// @ts-ignore
import { WritablePowerFeed } from '../models';
// @ts-ignore
import { WritablePowerOutlet } from '../models';
// @ts-ignore
import { WritablePowerOutletTemplate } from '../models';
// @ts-ignore
import { WritablePowerPanel } from '../models';
// @ts-ignore
import { WritablePowerPort } from '../models';
// @ts-ignore
import { WritablePowerPortTemplate } from '../models';
// @ts-ignore
import { WritableRack } from '../models';
// @ts-ignore
import { WritableRackGroup } from '../models';
// @ts-ignore
import { WritableRackReservation } from '../models';
// @ts-ignore
import { WritableRearPort } from '../models';
// @ts-ignore
import { WritableRearPortTemplate } from '../models';
// @ts-ignore
import { WritableRegion } from '../models';
// @ts-ignore
import { WritableSite } from '../models';
// @ts-ignore
import { WritableVirtualChassis } from '../models';
/**
 * DcimApi - axios parameter creator
 * @export
 */
export const DcimApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkPartialUpdate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkUpdate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesCreate: async (data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesCreate', 'data', data)
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesDelete', 'id', id)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesList: async (id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/cables/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (label !== undefined) {
                localVarQueryParameter['label'] = label;
            }

            if (length !== undefined) {
                localVarQueryParameter['length'] = length;
            }

            if (lengthUnit !== undefined) {
                localVarQueryParameter['length_unit'] = lengthUnit;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (rack !== undefined) {
                localVarQueryParameter['rack'] = rack;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (labelN !== undefined) {
                localVarQueryParameter['label__n'] = labelN;
            }

            if (labelIc !== undefined) {
                localVarQueryParameter['label__ic'] = labelIc;
            }

            if (labelNic !== undefined) {
                localVarQueryParameter['label__nic'] = labelNic;
            }

            if (labelIew !== undefined) {
                localVarQueryParameter['label__iew'] = labelIew;
            }

            if (labelNiew !== undefined) {
                localVarQueryParameter['label__niew'] = labelNiew;
            }

            if (labelIsw !== undefined) {
                localVarQueryParameter['label__isw'] = labelIsw;
            }

            if (labelNisw !== undefined) {
                localVarQueryParameter['label__nisw'] = labelNisw;
            }

            if (labelIe !== undefined) {
                localVarQueryParameter['label__ie'] = labelIe;
            }

            if (labelNie !== undefined) {
                localVarQueryParameter['label__nie'] = labelNie;
            }

            if (lengthN !== undefined) {
                localVarQueryParameter['length__n'] = lengthN;
            }

            if (lengthLte !== undefined) {
                localVarQueryParameter['length__lte'] = lengthLte;
            }

            if (lengthLt !== undefined) {
                localVarQueryParameter['length__lt'] = lengthLt;
            }

            if (lengthGte !== undefined) {
                localVarQueryParameter['length__gte'] = lengthGte;
            }

            if (lengthGt !== undefined) {
                localVarQueryParameter['length__gt'] = lengthGt;
            }

            if (lengthUnitN !== undefined) {
                localVarQueryParameter['length_unit__n'] = lengthUnitN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesPartialUpdate: async (id: number, data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesRead', 'id', id)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesUpdate: async (id: number, data: WritableCable, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimCablesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimCablesUpdate', 'data', data)
            const localVarPath = `/dcim/cables/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConnectedDeviceList: async (peerDevice: string, peerInterface: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'peerDevice' is not null or undefined
            assertParamExists('dcimConnectedDeviceList', 'peerDevice', peerDevice)
            // verify required parameter 'peerInterface' is not null or undefined
            assertParamExists('dcimConnectedDeviceList', 'peerInterface', peerInterface)
            const localVarPath = `/dcim/connected-device/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (peerDevice !== undefined) {
                localVarQueryParameter['peer_device'] = peerDevice;
            }

            if (peerInterface !== undefined) {
                localVarQueryParameter['peer_interface'] = peerInterface;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleConnectionsList: async (name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkPartialUpdate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkUpdate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesCreate: async (data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesPartialUpdate: async (id: number, data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesUpdate: async (id: number, data: WritableConsolePortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/console-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkPartialUpdate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkUpdate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsCreate: async (data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsCreate', 'data', data)
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsDelete', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsPartialUpdate: async (id: number, data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsRead', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsTrace', 'id', id)
            const localVarPath = `/dcim/console-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsUpdate: async (id: number, data: WritableConsolePort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsolePortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsolePortsUpdate', 'data', data)
            const localVarPath = `/dcim/console-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkPartialUpdate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkUpdate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesCreate: async (data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesPartialUpdate: async (id: number, data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesUpdate: async (id: number, data: WritableConsoleServerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkPartialUpdate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkUpdate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsCreate: async (data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsCreate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsDelete', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/console-server-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsPartialUpdate: async (id: number, data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsRead', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsTrace', 'id', id)
            const localVarPath = `/dcim/console-server-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsUpdate: async (id: number, data: WritableConsoleServerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimConsoleServerPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimConsoleServerPortsUpdate', 'data', data)
            const localVarPath = `/dcim/console-server-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkPartialUpdate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkUpdate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesCreate: async (data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesList: async (id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bay-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesPartialUpdate: async (id: number, data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesRead', 'id', id)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesUpdate: async (id: number, data: WritableDeviceBayTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBayTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/device-bay-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkPartialUpdate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkUpdate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysCreate: async (data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysCreate', 'data', data)
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysDelete', 'id', id)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysList: async (id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-bays/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysPartialUpdate: async (id: number, data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysRead', 'id', id)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysUpdate: async (id: number, data: WritableDeviceBay, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceBaysUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceBaysUpdate', 'data', data)
            const localVarPath = `/dcim/device-bays/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkPartialUpdate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkUpdate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesCreate: async (data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesCreate', 'data', data)
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesDelete', 'id', id)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesList: async (id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (vmRole !== undefined) {
                localVarQueryParameter['vm_role'] = vmRole;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (colorIc !== undefined) {
                localVarQueryParameter['color__ic'] = colorIc;
            }

            if (colorNic !== undefined) {
                localVarQueryParameter['color__nic'] = colorNic;
            }

            if (colorIew !== undefined) {
                localVarQueryParameter['color__iew'] = colorIew;
            }

            if (colorNiew !== undefined) {
                localVarQueryParameter['color__niew'] = colorNiew;
            }

            if (colorIsw !== undefined) {
                localVarQueryParameter['color__isw'] = colorIsw;
            }

            if (colorNisw !== undefined) {
                localVarQueryParameter['color__nisw'] = colorNisw;
            }

            if (colorIe !== undefined) {
                localVarQueryParameter['color__ie'] = colorIe;
            }

            if (colorNie !== undefined) {
                localVarQueryParameter['color__nie'] = colorNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesPartialUpdate: async (id: number, data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesRead', 'id', id)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesUpdate: async (id: number, data: DeviceRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceRolesUpdate', 'data', data)
            const localVarPath = `/dcim/device-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkPartialUpdate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkUpdate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesCreate: async (data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesCreate', 'data', data)
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesDelete', 'id', id)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesList: async (id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/device-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (partNumber !== undefined) {
                localVarQueryParameter['part_number'] = partNumber;
            }

            if (uHeight !== undefined) {
                localVarQueryParameter['u_height'] = uHeight;
            }

            if (isFullDepth !== undefined) {
                localVarQueryParameter['is_full_depth'] = isFullDepth;
            }

            if (subdeviceRole !== undefined) {
                localVarQueryParameter['subdevice_role'] = subdeviceRole;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (consolePorts !== undefined) {
                localVarQueryParameter['console_ports'] = consolePorts;
            }

            if (consoleServerPorts !== undefined) {
                localVarQueryParameter['console_server_ports'] = consoleServerPorts;
            }

            if (powerPorts !== undefined) {
                localVarQueryParameter['power_ports'] = powerPorts;
            }

            if (powerOutlets !== undefined) {
                localVarQueryParameter['power_outlets'] = powerOutlets;
            }

            if (interfaces !== undefined) {
                localVarQueryParameter['interfaces'] = interfaces;
            }

            if (passThroughPorts !== undefined) {
                localVarQueryParameter['pass_through_ports'] = passThroughPorts;
            }

            if (deviceBays !== undefined) {
                localVarQueryParameter['device_bays'] = deviceBays;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (modelN !== undefined) {
                localVarQueryParameter['model__n'] = modelN;
            }

            if (modelIc !== undefined) {
                localVarQueryParameter['model__ic'] = modelIc;
            }

            if (modelNic !== undefined) {
                localVarQueryParameter['model__nic'] = modelNic;
            }

            if (modelIew !== undefined) {
                localVarQueryParameter['model__iew'] = modelIew;
            }

            if (modelNiew !== undefined) {
                localVarQueryParameter['model__niew'] = modelNiew;
            }

            if (modelIsw !== undefined) {
                localVarQueryParameter['model__isw'] = modelIsw;
            }

            if (modelNisw !== undefined) {
                localVarQueryParameter['model__nisw'] = modelNisw;
            }

            if (modelIe !== undefined) {
                localVarQueryParameter['model__ie'] = modelIe;
            }

            if (modelNie !== undefined) {
                localVarQueryParameter['model__nie'] = modelNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (partNumberN !== undefined) {
                localVarQueryParameter['part_number__n'] = partNumberN;
            }

            if (partNumberIc !== undefined) {
                localVarQueryParameter['part_number__ic'] = partNumberIc;
            }

            if (partNumberNic !== undefined) {
                localVarQueryParameter['part_number__nic'] = partNumberNic;
            }

            if (partNumberIew !== undefined) {
                localVarQueryParameter['part_number__iew'] = partNumberIew;
            }

            if (partNumberNiew !== undefined) {
                localVarQueryParameter['part_number__niew'] = partNumberNiew;
            }

            if (partNumberIsw !== undefined) {
                localVarQueryParameter['part_number__isw'] = partNumberIsw;
            }

            if (partNumberNisw !== undefined) {
                localVarQueryParameter['part_number__nisw'] = partNumberNisw;
            }

            if (partNumberIe !== undefined) {
                localVarQueryParameter['part_number__ie'] = partNumberIe;
            }

            if (partNumberNie !== undefined) {
                localVarQueryParameter['part_number__nie'] = partNumberNie;
            }

            if (uHeightN !== undefined) {
                localVarQueryParameter['u_height__n'] = uHeightN;
            }

            if (uHeightLte !== undefined) {
                localVarQueryParameter['u_height__lte'] = uHeightLte;
            }

            if (uHeightLt !== undefined) {
                localVarQueryParameter['u_height__lt'] = uHeightLt;
            }

            if (uHeightGte !== undefined) {
                localVarQueryParameter['u_height__gte'] = uHeightGte;
            }

            if (uHeightGt !== undefined) {
                localVarQueryParameter['u_height__gt'] = uHeightGt;
            }

            if (subdeviceRoleN !== undefined) {
                localVarQueryParameter['subdevice_role__n'] = subdeviceRoleN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesPartialUpdate: async (id: number, data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesRead', 'id', id)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesUpdate: async (id: number, data: WritableDeviceType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDeviceTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDeviceTypesUpdate', 'data', data)
            const localVarPath = `/dcim/device-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkPartialUpdate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkUpdate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesCreate: async (data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesCreate', 'data', data)
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesDelete', 'id', id)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesList: async (id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/devices/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }

            if (vcPosition !== undefined) {
                localVarQueryParameter['vc_position'] = vcPosition;
            }

            if (vcPriority !== undefined) {
                localVarQueryParameter['vc_priority'] = vcPriority;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (localContextData !== undefined) {
                localVarQueryParameter['local_context_data'] = localContextData;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (deviceTypeId !== undefined) {
                localVarQueryParameter['device_type_id'] = deviceTypeId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (platformId !== undefined) {
                localVarQueryParameter['platform_id'] = platformId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (rackGroupId !== undefined) {
                localVarQueryParameter['rack_group_id'] = rackGroupId;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (model !== undefined) {
                localVarQueryParameter['model'] = model;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (isFullDepth !== undefined) {
                localVarQueryParameter['is_full_depth'] = isFullDepth;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (hasPrimaryIp !== undefined) {
                localVarQueryParameter['has_primary_ip'] = hasPrimaryIp;
            }

            if (virtualChassisId !== undefined) {
                localVarQueryParameter['virtual_chassis_id'] = virtualChassisId;
            }

            if (virtualChassisMember !== undefined) {
                localVarQueryParameter['virtual_chassis_member'] = virtualChassisMember;
            }

            if (consolePorts !== undefined) {
                localVarQueryParameter['console_ports'] = consolePorts;
            }

            if (consoleServerPorts !== undefined) {
                localVarQueryParameter['console_server_ports'] = consoleServerPorts;
            }

            if (powerPorts !== undefined) {
                localVarQueryParameter['power_ports'] = powerPorts;
            }

            if (powerOutlets !== undefined) {
                localVarQueryParameter['power_outlets'] = powerOutlets;
            }

            if (interfaces !== undefined) {
                localVarQueryParameter['interfaces'] = interfaces;
            }

            if (passThroughPorts !== undefined) {
                localVarQueryParameter['pass_through_ports'] = passThroughPorts;
            }

            if (deviceBays !== undefined) {
                localVarQueryParameter['device_bays'] = deviceBays;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (faceN !== undefined) {
                localVarQueryParameter['face__n'] = faceN;
            }

            if (positionN !== undefined) {
                localVarQueryParameter['position__n'] = positionN;
            }

            if (positionLte !== undefined) {
                localVarQueryParameter['position__lte'] = positionLte;
            }

            if (positionLt !== undefined) {
                localVarQueryParameter['position__lt'] = positionLt;
            }

            if (positionGte !== undefined) {
                localVarQueryParameter['position__gte'] = positionGte;
            }

            if (positionGt !== undefined) {
                localVarQueryParameter['position__gt'] = positionGt;
            }

            if (vcPositionN !== undefined) {
                localVarQueryParameter['vc_position__n'] = vcPositionN;
            }

            if (vcPositionLte !== undefined) {
                localVarQueryParameter['vc_position__lte'] = vcPositionLte;
            }

            if (vcPositionLt !== undefined) {
                localVarQueryParameter['vc_position__lt'] = vcPositionLt;
            }

            if (vcPositionGte !== undefined) {
                localVarQueryParameter['vc_position__gte'] = vcPositionGte;
            }

            if (vcPositionGt !== undefined) {
                localVarQueryParameter['vc_position__gt'] = vcPositionGt;
            }

            if (vcPriorityN !== undefined) {
                localVarQueryParameter['vc_priority__n'] = vcPriorityN;
            }

            if (vcPriorityLte !== undefined) {
                localVarQueryParameter['vc_priority__lte'] = vcPriorityLte;
            }

            if (vcPriorityLt !== undefined) {
                localVarQueryParameter['vc_priority__lt'] = vcPriorityLt;
            }

            if (vcPriorityGte !== undefined) {
                localVarQueryParameter['vc_priority__gte'] = vcPriorityGte;
            }

            if (vcPriorityGt !== undefined) {
                localVarQueryParameter['vc_priority__gt'] = vcPriorityGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (deviceTypeIdN !== undefined) {
                localVarQueryParameter['device_type_id__n'] = deviceTypeIdN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (platformIdN !== undefined) {
                localVarQueryParameter['platform_id__n'] = platformIdN;
            }

            if (platformN !== undefined) {
                localVarQueryParameter['platform__n'] = platformN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (rackGroupIdN !== undefined) {
                localVarQueryParameter['rack_group_id__n'] = rackGroupIdN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (modelN !== undefined) {
                localVarQueryParameter['model__n'] = modelN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (virtualChassisIdN !== undefined) {
                localVarQueryParameter['virtual_chassis_id__n'] = virtualChassisIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesNapalm: async (id: number, method: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesNapalm', 'id', id)
            // verify required parameter 'method' is not null or undefined
            assertParamExists('dcimDevicesNapalm', 'method', method)
            const localVarPath = `/dcim/devices/{id}/napalm/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (method !== undefined) {
                localVarQueryParameter['method'] = method;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesPartialUpdate: async (id: number, data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesRead', 'id', id)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesUpdate: async (id: number, data: WritableDeviceWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimDevicesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimDevicesUpdate', 'data', data)
            const localVarPath = `/dcim/devices/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkPartialUpdate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkUpdate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesCreate: async (data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesList: async (id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesPartialUpdate: async (id: number, data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesUpdate: async (id: number, data: WritableFrontPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/front-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkPartialUpdate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkUpdate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsCreate: async (data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsCreate', 'data', data)
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsDelete', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsList: async (id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/front-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPartialUpdate: async (id: number, data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPaths: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsPaths', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/paths/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsRead', 'id', id)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsUpdate: async (id: number, data: WritableFrontPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimFrontPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimFrontPortsUpdate', 'data', data)
            const localVarPath = `/dcim/front-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceConnectionsList: async (site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkPartialUpdate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkUpdate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesCreate: async (data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesList: async (id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interface-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (mgmtOnly !== undefined) {
                localVarQueryParameter['mgmt_only'] = mgmtOnly;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesPartialUpdate: async (id: number, data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesRead', 'id', id)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesUpdate: async (id: number, data: WritableInterfaceTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfaceTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/interface-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkPartialUpdate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkUpdate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesCreate: async (data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesCreate', 'data', data)
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesDelete', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesList: async (id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (mtu !== undefined) {
                localVarQueryParameter['mtu'] = mtu;
            }

            if (mgmtOnly !== undefined) {
                localVarQueryParameter['mgmt_only'] = mgmtOnly;
            }

            if (mode !== undefined) {
                localVarQueryParameter['mode'] = mode;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (lagId !== undefined) {
                localVarQueryParameter['lag_id'] = lagId;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (vlanId !== undefined) {
                localVarQueryParameter['vlan_id'] = vlanId;
            }

            if (vlan !== undefined) {
                localVarQueryParameter['vlan'] = vlan;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (mtuN !== undefined) {
                localVarQueryParameter['mtu__n'] = mtuN;
            }

            if (mtuLte !== undefined) {
                localVarQueryParameter['mtu__lte'] = mtuLte;
            }

            if (mtuLt !== undefined) {
                localVarQueryParameter['mtu__lt'] = mtuLt;
            }

            if (mtuGte !== undefined) {
                localVarQueryParameter['mtu__gte'] = mtuGte;
            }

            if (mtuGt !== undefined) {
                localVarQueryParameter['mtu__gt'] = mtuGt;
            }

            if (modeN !== undefined) {
                localVarQueryParameter['mode__n'] = modeN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (lagIdN !== undefined) {
                localVarQueryParameter['lag_id__n'] = lagIdN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesPartialUpdate: async (id: number, data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesRead', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesTrace', 'id', id)
            const localVarPath = `/dcim/interfaces/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesUpdate: async (id: number, data: WritableInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInterfacesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInterfacesUpdate', 'data', data)
            const localVarPath = `/dcim/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkPartialUpdate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkUpdate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsCreate: async (data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsCreate', 'data', data)
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsDelete', 'id', id)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsList: async (id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/inventory-items/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (partId !== undefined) {
                localVarQueryParameter['part_id'] = partId;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (discovered !== undefined) {
                localVarQueryParameter['discovered'] = discovered;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (partIdN !== undefined) {
                localVarQueryParameter['part_id__n'] = partIdN;
            }

            if (partIdIc !== undefined) {
                localVarQueryParameter['part_id__ic'] = partIdIc;
            }

            if (partIdNic !== undefined) {
                localVarQueryParameter['part_id__nic'] = partIdNic;
            }

            if (partIdIew !== undefined) {
                localVarQueryParameter['part_id__iew'] = partIdIew;
            }

            if (partIdNiew !== undefined) {
                localVarQueryParameter['part_id__niew'] = partIdNiew;
            }

            if (partIdIsw !== undefined) {
                localVarQueryParameter['part_id__isw'] = partIdIsw;
            }

            if (partIdNisw !== undefined) {
                localVarQueryParameter['part_id__nisw'] = partIdNisw;
            }

            if (partIdIe !== undefined) {
                localVarQueryParameter['part_id__ie'] = partIdIe;
            }

            if (partIdNie !== undefined) {
                localVarQueryParameter['part_id__nie'] = partIdNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsPartialUpdate: async (id: number, data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsRead', 'id', id)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsUpdate: async (id: number, data: WritableInventoryItem, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimInventoryItemsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimInventoryItemsUpdate', 'data', data)
            const localVarPath = `/dcim/inventory-items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkPartialUpdate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkUpdate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersBulkUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersCreate: async (data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersCreate', 'data', data)
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersDelete', 'id', id)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/manufacturers/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersPartialUpdate: async (id: number, data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersPartialUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersRead', 'id', id)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersUpdate: async (id: number, data: Manufacturer, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimManufacturersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimManufacturersUpdate', 'data', data)
            const localVarPath = `/dcim/manufacturers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkPartialUpdate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkUpdate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsCreate: async (data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsCreate', 'data', data)
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsDelete', 'id', id)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsList: async (id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/platforms/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (napalmDriver !== undefined) {
                localVarQueryParameter['napalm_driver'] = napalmDriver;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (manufacturerId !== undefined) {
                localVarQueryParameter['manufacturer_id'] = manufacturerId;
            }

            if (manufacturer !== undefined) {
                localVarQueryParameter['manufacturer'] = manufacturer;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (napalmDriverN !== undefined) {
                localVarQueryParameter['napalm_driver__n'] = napalmDriverN;
            }

            if (napalmDriverIc !== undefined) {
                localVarQueryParameter['napalm_driver__ic'] = napalmDriverIc;
            }

            if (napalmDriverNic !== undefined) {
                localVarQueryParameter['napalm_driver__nic'] = napalmDriverNic;
            }

            if (napalmDriverIew !== undefined) {
                localVarQueryParameter['napalm_driver__iew'] = napalmDriverIew;
            }

            if (napalmDriverNiew !== undefined) {
                localVarQueryParameter['napalm_driver__niew'] = napalmDriverNiew;
            }

            if (napalmDriverIsw !== undefined) {
                localVarQueryParameter['napalm_driver__isw'] = napalmDriverIsw;
            }

            if (napalmDriverNisw !== undefined) {
                localVarQueryParameter['napalm_driver__nisw'] = napalmDriverNisw;
            }

            if (napalmDriverIe !== undefined) {
                localVarQueryParameter['napalm_driver__ie'] = napalmDriverIe;
            }

            if (napalmDriverNie !== undefined) {
                localVarQueryParameter['napalm_driver__nie'] = napalmDriverNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (manufacturerIdN !== undefined) {
                localVarQueryParameter['manufacturer_id__n'] = manufacturerIdN;
            }

            if (manufacturerN !== undefined) {
                localVarQueryParameter['manufacturer__n'] = manufacturerN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsPartialUpdate: async (id: number, data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsRead', 'id', id)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsUpdate: async (id: number, data: WritablePlatform, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPlatformsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPlatformsUpdate', 'data', data)
            const localVarPath = `/dcim/platforms/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerConnectionsList: async (name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-connections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkPartialUpdate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkUpdate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsCreate: async (data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsCreate', 'data', data)
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsDelete', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsList: async (id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-feeds/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (supply !== undefined) {
                localVarQueryParameter['supply'] = supply;
            }

            if (phase !== undefined) {
                localVarQueryParameter['phase'] = phase;
            }

            if (voltage !== undefined) {
                localVarQueryParameter['voltage'] = voltage;
            }

            if (amperage !== undefined) {
                localVarQueryParameter['amperage'] = amperage;
            }

            if (maxUtilization !== undefined) {
                localVarQueryParameter['max_utilization'] = maxUtilization;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (powerPanelId !== undefined) {
                localVarQueryParameter['power_panel_id'] = powerPanelId;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (supplyN !== undefined) {
                localVarQueryParameter['supply__n'] = supplyN;
            }

            if (phaseN !== undefined) {
                localVarQueryParameter['phase__n'] = phaseN;
            }

            if (voltageN !== undefined) {
                localVarQueryParameter['voltage__n'] = voltageN;
            }

            if (voltageLte !== undefined) {
                localVarQueryParameter['voltage__lte'] = voltageLte;
            }

            if (voltageLt !== undefined) {
                localVarQueryParameter['voltage__lt'] = voltageLt;
            }

            if (voltageGte !== undefined) {
                localVarQueryParameter['voltage__gte'] = voltageGte;
            }

            if (voltageGt !== undefined) {
                localVarQueryParameter['voltage__gt'] = voltageGt;
            }

            if (amperageN !== undefined) {
                localVarQueryParameter['amperage__n'] = amperageN;
            }

            if (amperageLte !== undefined) {
                localVarQueryParameter['amperage__lte'] = amperageLte;
            }

            if (amperageLt !== undefined) {
                localVarQueryParameter['amperage__lt'] = amperageLt;
            }

            if (amperageGte !== undefined) {
                localVarQueryParameter['amperage__gte'] = amperageGte;
            }

            if (amperageGt !== undefined) {
                localVarQueryParameter['amperage__gt'] = amperageGt;
            }

            if (maxUtilizationN !== undefined) {
                localVarQueryParameter['max_utilization__n'] = maxUtilizationN;
            }

            if (maxUtilizationLte !== undefined) {
                localVarQueryParameter['max_utilization__lte'] = maxUtilizationLte;
            }

            if (maxUtilizationLt !== undefined) {
                localVarQueryParameter['max_utilization__lt'] = maxUtilizationLt;
            }

            if (maxUtilizationGte !== undefined) {
                localVarQueryParameter['max_utilization__gte'] = maxUtilizationGte;
            }

            if (maxUtilizationGt !== undefined) {
                localVarQueryParameter['max_utilization__gt'] = maxUtilizationGt;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (powerPanelIdN !== undefined) {
                localVarQueryParameter['power_panel_id__n'] = powerPanelIdN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsPartialUpdate: async (id: number, data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsRead', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsTrace', 'id', id)
            const localVarPath = `/dcim/power-feeds/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsUpdate: async (id: number, data: WritablePowerFeed, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerFeedsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerFeedsUpdate', 'data', data)
            const localVarPath = `/dcim/power-feeds/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkPartialUpdate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkUpdate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesCreate: async (data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesList: async (id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlet-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (feedLeg !== undefined) {
                localVarQueryParameter['feed_leg'] = feedLeg;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (feedLegN !== undefined) {
                localVarQueryParameter['feed_leg__n'] = feedLegN;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesPartialUpdate: async (id: number, data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesRead', 'id', id)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesUpdate: async (id: number, data: WritablePowerOutletTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlet-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkPartialUpdate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkUpdate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsCreate: async (data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsCreate', 'data', data)
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsDelete', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsList: async (id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-outlets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (feedLeg !== undefined) {
                localVarQueryParameter['feed_leg'] = feedLeg;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (feedLegN !== undefined) {
                localVarQueryParameter['feed_leg__n'] = feedLegN;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsPartialUpdate: async (id: number, data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsRead', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsTrace', 'id', id)
            const localVarPath = `/dcim/power-outlets/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsUpdate: async (id: number, data: WritablePowerOutlet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerOutletsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerOutletsUpdate', 'data', data)
            const localVarPath = `/dcim/power-outlets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkPartialUpdate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkUpdate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsCreate: async (data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsCreate', 'data', data)
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsDelete', 'id', id)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsList: async (id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-panels/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (rackGroupId !== undefined) {
                localVarQueryParameter['rack_group_id'] = rackGroupId;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (rackGroupIdN !== undefined) {
                localVarQueryParameter['rack_group_id__n'] = rackGroupIdN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsPartialUpdate: async (id: number, data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsRead', 'id', id)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsUpdate: async (id: number, data: WritablePowerPanel, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPanelsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPanelsUpdate', 'data', data)
            const localVarPath = `/dcim/power-panels/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkPartialUpdate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkUpdate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesCreate: async (data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesList: async (id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (maximumDraw !== undefined) {
                localVarQueryParameter['maximum_draw'] = maximumDraw;
            }

            if (allocatedDraw !== undefined) {
                localVarQueryParameter['allocated_draw'] = allocatedDraw;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (maximumDrawN !== undefined) {
                localVarQueryParameter['maximum_draw__n'] = maximumDrawN;
            }

            if (maximumDrawLte !== undefined) {
                localVarQueryParameter['maximum_draw__lte'] = maximumDrawLte;
            }

            if (maximumDrawLt !== undefined) {
                localVarQueryParameter['maximum_draw__lt'] = maximumDrawLt;
            }

            if (maximumDrawGte !== undefined) {
                localVarQueryParameter['maximum_draw__gte'] = maximumDrawGte;
            }

            if (maximumDrawGt !== undefined) {
                localVarQueryParameter['maximum_draw__gt'] = maximumDrawGt;
            }

            if (allocatedDrawN !== undefined) {
                localVarQueryParameter['allocated_draw__n'] = allocatedDrawN;
            }

            if (allocatedDrawLte !== undefined) {
                localVarQueryParameter['allocated_draw__lte'] = allocatedDrawLte;
            }

            if (allocatedDrawLt !== undefined) {
                localVarQueryParameter['allocated_draw__lt'] = allocatedDrawLt;
            }

            if (allocatedDrawGte !== undefined) {
                localVarQueryParameter['allocated_draw__gte'] = allocatedDrawGte;
            }

            if (allocatedDrawGt !== undefined) {
                localVarQueryParameter['allocated_draw__gt'] = allocatedDrawGt;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesPartialUpdate: async (id: number, data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesUpdate: async (id: number, data: WritablePowerPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/power-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkPartialUpdate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkUpdate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsCreate: async (data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsCreate', 'data', data)
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsDelete', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsList: async (id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/power-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (maximumDraw !== undefined) {
                localVarQueryParameter['maximum_draw'] = maximumDraw;
            }

            if (allocatedDraw !== undefined) {
                localVarQueryParameter['allocated_draw'] = allocatedDraw;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (connected !== undefined) {
                localVarQueryParameter['connected'] = connected;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (maximumDrawN !== undefined) {
                localVarQueryParameter['maximum_draw__n'] = maximumDrawN;
            }

            if (maximumDrawLte !== undefined) {
                localVarQueryParameter['maximum_draw__lte'] = maximumDrawLte;
            }

            if (maximumDrawLt !== undefined) {
                localVarQueryParameter['maximum_draw__lt'] = maximumDrawLt;
            }

            if (maximumDrawGte !== undefined) {
                localVarQueryParameter['maximum_draw__gte'] = maximumDrawGte;
            }

            if (maximumDrawGt !== undefined) {
                localVarQueryParameter['maximum_draw__gt'] = maximumDrawGt;
            }

            if (allocatedDrawN !== undefined) {
                localVarQueryParameter['allocated_draw__n'] = allocatedDrawN;
            }

            if (allocatedDrawLte !== undefined) {
                localVarQueryParameter['allocated_draw__lte'] = allocatedDrawLte;
            }

            if (allocatedDrawLt !== undefined) {
                localVarQueryParameter['allocated_draw__lt'] = allocatedDrawLt;
            }

            if (allocatedDrawGte !== undefined) {
                localVarQueryParameter['allocated_draw__gte'] = allocatedDrawGte;
            }

            if (allocatedDrawGt !== undefined) {
                localVarQueryParameter['allocated_draw__gt'] = allocatedDrawGt;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsPartialUpdate: async (id: number, data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsRead', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsTrace: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsTrace', 'id', id)
            const localVarPath = `/dcim/power-ports/{id}/trace/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsUpdate: async (id: number, data: WritablePowerPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimPowerPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimPowerPortsUpdate', 'data', data)
            const localVarPath = `/dcim/power-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkPartialUpdate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkUpdate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsCreate: async (data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsCreate', 'data', data)
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsDelete', 'id', id)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (parentN !== undefined) {
                localVarQueryParameter['parent__n'] = parentN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsPartialUpdate: async (id: number, data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsRead', 'id', id)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsUpdate: async (id: number, data: WritableRackGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackGroupsUpdate', 'data', data)
            const localVarPath = `/dcim/rack-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkPartialUpdate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkUpdate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsCreate: async (data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsCreate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsDelete', 'id', id)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsList: async (id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-reservations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (rackId !== undefined) {
                localVarQueryParameter['rack_id'] = rackId;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (user !== undefined) {
                localVarQueryParameter['user'] = user;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (createdN !== undefined) {
                localVarQueryParameter['created__n'] = createdN;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (createdLt !== undefined) {
                localVarQueryParameter['created__lt'] = createdLt;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdGt !== undefined) {
                localVarQueryParameter['created__gt'] = createdGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (rackIdN !== undefined) {
                localVarQueryParameter['rack_id__n'] = rackIdN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (userIdN !== undefined) {
                localVarQueryParameter['user_id__n'] = userIdN;
            }

            if (userN !== undefined) {
                localVarQueryParameter['user__n'] = userN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsPartialUpdate: async (id: number, data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsRead', 'id', id)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsUpdate: async (id: number, data: WritableRackReservation, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackReservationsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackReservationsUpdate', 'data', data)
            const localVarPath = `/dcim/rack-reservations/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkPartialUpdate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkUpdate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesCreate: async (data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesCreate', 'data', data)
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesDelete', 'id', id)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesList: async (id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rack-roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (color !== undefined) {
                localVarQueryParameter['color'] = color;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (colorN !== undefined) {
                localVarQueryParameter['color__n'] = colorN;
            }

            if (colorIc !== undefined) {
                localVarQueryParameter['color__ic'] = colorIc;
            }

            if (colorNic !== undefined) {
                localVarQueryParameter['color__nic'] = colorNic;
            }

            if (colorIew !== undefined) {
                localVarQueryParameter['color__iew'] = colorIew;
            }

            if (colorNiew !== undefined) {
                localVarQueryParameter['color__niew'] = colorNiew;
            }

            if (colorIsw !== undefined) {
                localVarQueryParameter['color__isw'] = colorIsw;
            }

            if (colorNisw !== undefined) {
                localVarQueryParameter['color__nisw'] = colorNisw;
            }

            if (colorIe !== undefined) {
                localVarQueryParameter['color__ie'] = colorIe;
            }

            if (colorNie !== undefined) {
                localVarQueryParameter['color__nie'] = colorNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesPartialUpdate: async (id: number, data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesRead', 'id', id)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesUpdate: async (id: number, data: RackRole, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRackRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRackRolesUpdate', 'data', data)
            const localVarPath = `/dcim/rack-roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkPartialUpdate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkUpdate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksBulkUpdate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksCreate: async (data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksCreate', 'data', data)
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksDelete', 'id', id)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksElevationRead: async (id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksElevationRead', 'id', id)
            const localVarPath = `/dcim/racks/{id}/elevation/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (face !== undefined) {
                localVarQueryParameter['face'] = face;
            }

            if (render !== undefined) {
                localVarQueryParameter['render'] = render;
            }

            if (unitWidth !== undefined) {
                localVarQueryParameter['unit_width'] = unitWidth;
            }

            if (unitHeight !== undefined) {
                localVarQueryParameter['unit_height'] = unitHeight;
            }

            if (legendWidth !== undefined) {
                localVarQueryParameter['legend_width'] = legendWidth;
            }

            if (exclude !== undefined) {
                localVarQueryParameter['exclude'] = exclude;
            }

            if (expandDevices !== undefined) {
                localVarQueryParameter['expand_devices'] = expandDevices;
            }

            if (includeImages !== undefined) {
                localVarQueryParameter['include_images'] = includeImages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksList: async (id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/racks/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (facilityId !== undefined) {
                localVarQueryParameter['facility_id'] = facilityId;
            }

            if (assetTag !== undefined) {
                localVarQueryParameter['asset_tag'] = assetTag;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (uHeight !== undefined) {
                localVarQueryParameter['u_height'] = uHeight;
            }

            if (descUnits !== undefined) {
                localVarQueryParameter['desc_units'] = descUnits;
            }

            if (outerWidth !== undefined) {
                localVarQueryParameter['outer_width'] = outerWidth;
            }

            if (outerDepth !== undefined) {
                localVarQueryParameter['outer_depth'] = outerDepth;
            }

            if (outerUnit !== undefined) {
                localVarQueryParameter['outer_unit'] = outerUnit;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (serial !== undefined) {
                localVarQueryParameter['serial'] = serial;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (facilityIdN !== undefined) {
                localVarQueryParameter['facility_id__n'] = facilityIdN;
            }

            if (facilityIdIc !== undefined) {
                localVarQueryParameter['facility_id__ic'] = facilityIdIc;
            }

            if (facilityIdNic !== undefined) {
                localVarQueryParameter['facility_id__nic'] = facilityIdNic;
            }

            if (facilityIdIew !== undefined) {
                localVarQueryParameter['facility_id__iew'] = facilityIdIew;
            }

            if (facilityIdNiew !== undefined) {
                localVarQueryParameter['facility_id__niew'] = facilityIdNiew;
            }

            if (facilityIdIsw !== undefined) {
                localVarQueryParameter['facility_id__isw'] = facilityIdIsw;
            }

            if (facilityIdNisw !== undefined) {
                localVarQueryParameter['facility_id__nisw'] = facilityIdNisw;
            }

            if (facilityIdIe !== undefined) {
                localVarQueryParameter['facility_id__ie'] = facilityIdIe;
            }

            if (facilityIdNie !== undefined) {
                localVarQueryParameter['facility_id__nie'] = facilityIdNie;
            }

            if (assetTagN !== undefined) {
                localVarQueryParameter['asset_tag__n'] = assetTagN;
            }

            if (assetTagIc !== undefined) {
                localVarQueryParameter['asset_tag__ic'] = assetTagIc;
            }

            if (assetTagNic !== undefined) {
                localVarQueryParameter['asset_tag__nic'] = assetTagNic;
            }

            if (assetTagIew !== undefined) {
                localVarQueryParameter['asset_tag__iew'] = assetTagIew;
            }

            if (assetTagNiew !== undefined) {
                localVarQueryParameter['asset_tag__niew'] = assetTagNiew;
            }

            if (assetTagIsw !== undefined) {
                localVarQueryParameter['asset_tag__isw'] = assetTagIsw;
            }

            if (assetTagNisw !== undefined) {
                localVarQueryParameter['asset_tag__nisw'] = assetTagNisw;
            }

            if (assetTagIe !== undefined) {
                localVarQueryParameter['asset_tag__ie'] = assetTagIe;
            }

            if (assetTagNie !== undefined) {
                localVarQueryParameter['asset_tag__nie'] = assetTagNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (widthN !== undefined) {
                localVarQueryParameter['width__n'] = widthN;
            }

            if (uHeightN !== undefined) {
                localVarQueryParameter['u_height__n'] = uHeightN;
            }

            if (uHeightLte !== undefined) {
                localVarQueryParameter['u_height__lte'] = uHeightLte;
            }

            if (uHeightLt !== undefined) {
                localVarQueryParameter['u_height__lt'] = uHeightLt;
            }

            if (uHeightGte !== undefined) {
                localVarQueryParameter['u_height__gte'] = uHeightGte;
            }

            if (uHeightGt !== undefined) {
                localVarQueryParameter['u_height__gt'] = uHeightGt;
            }

            if (outerWidthN !== undefined) {
                localVarQueryParameter['outer_width__n'] = outerWidthN;
            }

            if (outerWidthLte !== undefined) {
                localVarQueryParameter['outer_width__lte'] = outerWidthLte;
            }

            if (outerWidthLt !== undefined) {
                localVarQueryParameter['outer_width__lt'] = outerWidthLt;
            }

            if (outerWidthGte !== undefined) {
                localVarQueryParameter['outer_width__gte'] = outerWidthGte;
            }

            if (outerWidthGt !== undefined) {
                localVarQueryParameter['outer_width__gt'] = outerWidthGt;
            }

            if (outerDepthN !== undefined) {
                localVarQueryParameter['outer_depth__n'] = outerDepthN;
            }

            if (outerDepthLte !== undefined) {
                localVarQueryParameter['outer_depth__lte'] = outerDepthLte;
            }

            if (outerDepthLt !== undefined) {
                localVarQueryParameter['outer_depth__lt'] = outerDepthLt;
            }

            if (outerDepthGte !== undefined) {
                localVarQueryParameter['outer_depth__gte'] = outerDepthGte;
            }

            if (outerDepthGt !== undefined) {
                localVarQueryParameter['outer_depth__gt'] = outerDepthGt;
            }

            if (outerUnitN !== undefined) {
                localVarQueryParameter['outer_unit__n'] = outerUnitN;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksPartialUpdate: async (id: number, data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksPartialUpdate', 'data', data)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksRead', 'id', id)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksUpdate: async (id: number, data: WritableRack, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRacksUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRacksUpdate', 'data', data)
            const localVarPath = `/dcim/racks/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkPartialUpdate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkUpdate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesCreate: async (data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesCreate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesDelete', 'id', id)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesList: async (id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-port-templates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (positions !== undefined) {
                localVarQueryParameter['positions'] = positions;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (devicetypeId !== undefined) {
                localVarQueryParameter['devicetype_id'] = devicetypeId;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (positionsN !== undefined) {
                localVarQueryParameter['positions__n'] = positionsN;
            }

            if (positionsLte !== undefined) {
                localVarQueryParameter['positions__lte'] = positionsLte;
            }

            if (positionsLt !== undefined) {
                localVarQueryParameter['positions__lt'] = positionsLt;
            }

            if (positionsGte !== undefined) {
                localVarQueryParameter['positions__gte'] = positionsGte;
            }

            if (positionsGt !== undefined) {
                localVarQueryParameter['positions__gt'] = positionsGt;
            }

            if (devicetypeIdN !== undefined) {
                localVarQueryParameter['devicetype_id__n'] = devicetypeIdN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesPartialUpdate: async (id: number, data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesRead', 'id', id)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesUpdate: async (id: number, data: WritableRearPortTemplate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortTemplatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortTemplatesUpdate', 'data', data)
            const localVarPath = `/dcim/rear-port-templates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkPartialUpdate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkUpdate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsCreate: async (data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsCreate', 'data', data)
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsDelete', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsList: async (id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/rear-ports/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (positions !== undefined) {
                localVarQueryParameter['positions'] = positions;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (cabled !== undefined) {
                localVarQueryParameter['cabled'] = cabled;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (positionsN !== undefined) {
                localVarQueryParameter['positions__n'] = positionsN;
            }

            if (positionsLte !== undefined) {
                localVarQueryParameter['positions__lte'] = positionsLte;
            }

            if (positionsLt !== undefined) {
                localVarQueryParameter['positions__lt'] = positionsLt;
            }

            if (positionsGte !== undefined) {
                localVarQueryParameter['positions__gte'] = positionsGte;
            }

            if (positionsGt !== undefined) {
                localVarQueryParameter['positions__gt'] = positionsGt;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPartialUpdate: async (id: number, data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPaths: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsPaths', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/paths/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsRead', 'id', id)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsUpdate: async (id: number, data: WritableRearPort, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRearPortsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRearPortsUpdate', 'data', data)
            const localVarPath = `/dcim/rear-ports/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkPartialUpdate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkUpdate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsBulkUpdate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsCreate: async (data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsCreate', 'data', data)
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsDelete', 'id', id)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/regions/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (parentIdN !== undefined) {
                localVarQueryParameter['parent_id__n'] = parentIdN;
            }

            if (parentN !== undefined) {
                localVarQueryParameter['parent__n'] = parentN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsPartialUpdate: async (id: number, data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsPartialUpdate', 'data', data)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsRead', 'id', id)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsUpdate: async (id: number, data: WritableRegion, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimRegionsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimRegionsUpdate', 'data', data)
            const localVarPath = `/dcim/regions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkPartialUpdate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkUpdate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesBulkUpdate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesCreate: async (data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesCreate', 'data', data)
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesDelete', 'id', id)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesList: async (id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/sites/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (facility !== undefined) {
                localVarQueryParameter['facility'] = facility;
            }

            if (asn !== undefined) {
                localVarQueryParameter['asn'] = asn;
            }

            if (latitude !== undefined) {
                localVarQueryParameter['latitude'] = latitude;
            }

            if (longitude !== undefined) {
                localVarQueryParameter['longitude'] = longitude;
            }

            if (contactName !== undefined) {
                localVarQueryParameter['contact_name'] = contactName;
            }

            if (contactPhone !== undefined) {
                localVarQueryParameter['contact_phone'] = contactPhone;
            }

            if (contactEmail !== undefined) {
                localVarQueryParameter['contact_email'] = contactEmail;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (facilityN !== undefined) {
                localVarQueryParameter['facility__n'] = facilityN;
            }

            if (facilityIc !== undefined) {
                localVarQueryParameter['facility__ic'] = facilityIc;
            }

            if (facilityNic !== undefined) {
                localVarQueryParameter['facility__nic'] = facilityNic;
            }

            if (facilityIew !== undefined) {
                localVarQueryParameter['facility__iew'] = facilityIew;
            }

            if (facilityNiew !== undefined) {
                localVarQueryParameter['facility__niew'] = facilityNiew;
            }

            if (facilityIsw !== undefined) {
                localVarQueryParameter['facility__isw'] = facilityIsw;
            }

            if (facilityNisw !== undefined) {
                localVarQueryParameter['facility__nisw'] = facilityNisw;
            }

            if (facilityIe !== undefined) {
                localVarQueryParameter['facility__ie'] = facilityIe;
            }

            if (facilityNie !== undefined) {
                localVarQueryParameter['facility__nie'] = facilityNie;
            }

            if (asnN !== undefined) {
                localVarQueryParameter['asn__n'] = asnN;
            }

            if (asnLte !== undefined) {
                localVarQueryParameter['asn__lte'] = asnLte;
            }

            if (asnLt !== undefined) {
                localVarQueryParameter['asn__lt'] = asnLt;
            }

            if (asnGte !== undefined) {
                localVarQueryParameter['asn__gte'] = asnGte;
            }

            if (asnGt !== undefined) {
                localVarQueryParameter['asn__gt'] = asnGt;
            }

            if (latitudeN !== undefined) {
                localVarQueryParameter['latitude__n'] = latitudeN;
            }

            if (latitudeLte !== undefined) {
                localVarQueryParameter['latitude__lte'] = latitudeLte;
            }

            if (latitudeLt !== undefined) {
                localVarQueryParameter['latitude__lt'] = latitudeLt;
            }

            if (latitudeGte !== undefined) {
                localVarQueryParameter['latitude__gte'] = latitudeGte;
            }

            if (latitudeGt !== undefined) {
                localVarQueryParameter['latitude__gt'] = latitudeGt;
            }

            if (longitudeN !== undefined) {
                localVarQueryParameter['longitude__n'] = longitudeN;
            }

            if (longitudeLte !== undefined) {
                localVarQueryParameter['longitude__lte'] = longitudeLte;
            }

            if (longitudeLt !== undefined) {
                localVarQueryParameter['longitude__lt'] = longitudeLt;
            }

            if (longitudeGte !== undefined) {
                localVarQueryParameter['longitude__gte'] = longitudeGte;
            }

            if (longitudeGt !== undefined) {
                localVarQueryParameter['longitude__gt'] = longitudeGt;
            }

            if (contactNameN !== undefined) {
                localVarQueryParameter['contact_name__n'] = contactNameN;
            }

            if (contactNameIc !== undefined) {
                localVarQueryParameter['contact_name__ic'] = contactNameIc;
            }

            if (contactNameNic !== undefined) {
                localVarQueryParameter['contact_name__nic'] = contactNameNic;
            }

            if (contactNameIew !== undefined) {
                localVarQueryParameter['contact_name__iew'] = contactNameIew;
            }

            if (contactNameNiew !== undefined) {
                localVarQueryParameter['contact_name__niew'] = contactNameNiew;
            }

            if (contactNameIsw !== undefined) {
                localVarQueryParameter['contact_name__isw'] = contactNameIsw;
            }

            if (contactNameNisw !== undefined) {
                localVarQueryParameter['contact_name__nisw'] = contactNameNisw;
            }

            if (contactNameIe !== undefined) {
                localVarQueryParameter['contact_name__ie'] = contactNameIe;
            }

            if (contactNameNie !== undefined) {
                localVarQueryParameter['contact_name__nie'] = contactNameNie;
            }

            if (contactPhoneN !== undefined) {
                localVarQueryParameter['contact_phone__n'] = contactPhoneN;
            }

            if (contactPhoneIc !== undefined) {
                localVarQueryParameter['contact_phone__ic'] = contactPhoneIc;
            }

            if (contactPhoneNic !== undefined) {
                localVarQueryParameter['contact_phone__nic'] = contactPhoneNic;
            }

            if (contactPhoneIew !== undefined) {
                localVarQueryParameter['contact_phone__iew'] = contactPhoneIew;
            }

            if (contactPhoneNiew !== undefined) {
                localVarQueryParameter['contact_phone__niew'] = contactPhoneNiew;
            }

            if (contactPhoneIsw !== undefined) {
                localVarQueryParameter['contact_phone__isw'] = contactPhoneIsw;
            }

            if (contactPhoneNisw !== undefined) {
                localVarQueryParameter['contact_phone__nisw'] = contactPhoneNisw;
            }

            if (contactPhoneIe !== undefined) {
                localVarQueryParameter['contact_phone__ie'] = contactPhoneIe;
            }

            if (contactPhoneNie !== undefined) {
                localVarQueryParameter['contact_phone__nie'] = contactPhoneNie;
            }

            if (contactEmailN !== undefined) {
                localVarQueryParameter['contact_email__n'] = contactEmailN;
            }

            if (contactEmailIc !== undefined) {
                localVarQueryParameter['contact_email__ic'] = contactEmailIc;
            }

            if (contactEmailNic !== undefined) {
                localVarQueryParameter['contact_email__nic'] = contactEmailNic;
            }

            if (contactEmailIew !== undefined) {
                localVarQueryParameter['contact_email__iew'] = contactEmailIew;
            }

            if (contactEmailNiew !== undefined) {
                localVarQueryParameter['contact_email__niew'] = contactEmailNiew;
            }

            if (contactEmailIsw !== undefined) {
                localVarQueryParameter['contact_email__isw'] = contactEmailIsw;
            }

            if (contactEmailNisw !== undefined) {
                localVarQueryParameter['contact_email__nisw'] = contactEmailNisw;
            }

            if (contactEmailIe !== undefined) {
                localVarQueryParameter['contact_email__ie'] = contactEmailIe;
            }

            if (contactEmailNie !== undefined) {
                localVarQueryParameter['contact_email__nie'] = contactEmailNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesPartialUpdate: async (id: number, data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesPartialUpdate', 'data', data)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesRead', 'id', id)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesUpdate: async (id: number, data: WritableSite, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimSitesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimSitesUpdate', 'data', data)
            const localVarPath = `/dcim/sites/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkPartialUpdate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisBulkPartialUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkUpdate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisBulkUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisCreate: async (data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisCreate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisDelete', 'id', id)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisList: async (id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dcim/virtual-chassis/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (domain !== undefined) {
                localVarQueryParameter['domain'] = domain;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (domainN !== undefined) {
                localVarQueryParameter['domain__n'] = domainN;
            }

            if (domainIc !== undefined) {
                localVarQueryParameter['domain__ic'] = domainIc;
            }

            if (domainNic !== undefined) {
                localVarQueryParameter['domain__nic'] = domainNic;
            }

            if (domainIew !== undefined) {
                localVarQueryParameter['domain__iew'] = domainIew;
            }

            if (domainNiew !== undefined) {
                localVarQueryParameter['domain__niew'] = domainNiew;
            }

            if (domainIsw !== undefined) {
                localVarQueryParameter['domain__isw'] = domainIsw;
            }

            if (domainNisw !== undefined) {
                localVarQueryParameter['domain__nisw'] = domainNisw;
            }

            if (domainIe !== undefined) {
                localVarQueryParameter['domain__ie'] = domainIe;
            }

            if (domainNie !== undefined) {
                localVarQueryParameter['domain__nie'] = domainNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisPartialUpdate: async (id: number, data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisPartialUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisRead', 'id', id)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisUpdate: async (id: number, data: WritableVirtualChassis, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('dcimVirtualChassisUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('dcimVirtualChassisUpdate', 'data', data)
            const localVarPath = `/dcim/virtual-chassis/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DcimApi - functional programming interface
 * @export
 */
export const DcimApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DcimApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkPartialUpdate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesBulkUpdate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesCreate(data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesList(id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesList(id, label, length, lengthUnit, q, type, status, color, deviceId, device, rackId, rack, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, labelN, labelIc, labelNic, labelIew, labelNiew, labelIsw, labelNisw, labelIe, labelNie, lengthN, lengthLte, lengthLt, lengthGte, lengthGt, lengthUnitN, typeN, statusN, colorN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesPartialUpdate(id: number, data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimCablesUpdate(id: number, data: WritableCable, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cable>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimCablesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConnectedDeviceList(peerDevice: string, peerInterface: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Device>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConnectedDeviceList(peerDevice, peerInterface, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkPartialUpdate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesBulkUpdate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesCreate(data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesPartialUpdate(id: number, data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortTemplatesUpdate(id: number, data: WritableConsolePortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkPartialUpdate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsBulkUpdate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsCreate(data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsPartialUpdate(id: number, data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsolePortsUpdate(id: number, data: WritableConsolePort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsolePort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsolePortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkPartialUpdate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesBulkUpdate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesCreate(data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesPartialUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortTemplatesUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkPartialUpdate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsBulkUpdate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsCreate(data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsPartialUpdate(id: number, data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimConsoleServerPortsUpdate(id: number, data: WritableConsoleServerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConsoleServerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimConsoleServerPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkPartialUpdate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesBulkUpdate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesCreate(data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesList(id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesList(id, name, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesPartialUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBayTemplatesUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBayTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBayTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkPartialUpdate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysBulkUpdate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysCreate(data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysPartialUpdate(id: number, data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceBaysUpdate(id: number, data: WritableDeviceBay, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceBay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceBaysUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkPartialUpdate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesBulkUpdate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesCreate(data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesList(id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesList(id, name, slug, color, vmRole, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesPartialUpdate(id: number, data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceRolesUpdate(id: number, data: DeviceRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkPartialUpdate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesBulkUpdate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesCreate(data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesList(id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesList(id, model, slug, partNumber, uHeight, isFullDepth, subdeviceRole, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, modelN, modelIc, modelNic, modelIew, modelNiew, modelIsw, modelNisw, modelIe, modelNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, partNumberN, partNumberIc, partNumberNic, partNumberIew, partNumberNiew, partNumberIsw, partNumberNisw, partNumberIe, partNumberNie, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, subdeviceRoleN, manufacturerIdN, manufacturerN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesPartialUpdate(id: number, data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDeviceTypesUpdate(id: number, data: WritableDeviceType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDeviceTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkPartialUpdate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesBulkUpdate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesCreate(data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesList(id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesList(id, name, assetTag, face, position, vcPosition, vcPriority, tenantGroupId, tenantGroup, tenantId, tenant, localContextData, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, deviceTypeId, roleId, role, platformId, platform, regionId, region, siteId, site, rackGroupId, rackId, clusterId, model, status, isFullDepth, macAddress, serial, hasPrimaryIp, virtualChassisId, virtualChassisMember, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, faceN, positionN, positionLte, positionLt, positionGte, positionGt, vcPositionN, vcPositionLte, vcPositionLt, vcPositionGte, vcPositionGt, vcPriorityN, vcPriorityLte, vcPriorityLt, vcPriorityGte, vcPriorityGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, manufacturerIdN, manufacturerN, deviceTypeIdN, roleIdN, roleN, platformIdN, platformN, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, rackIdN, clusterIdN, modelN, statusN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, virtualChassisIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesNapalm(id: number, method: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceNAPALM>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesNapalm(id, method, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesPartialUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimDevicesUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeviceWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimDevicesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkPartialUpdate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesBulkUpdate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesCreate(data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesPartialUpdate(id: number, data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortTemplatesUpdate(id: number, data: WritableFrontPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkPartialUpdate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsBulkUpdate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsCreate(data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsList(id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsList(id, name, type, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsPartialUpdate(id: number, data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsPaths(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsPaths(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimFrontPortsUpdate(id: number, data: WritableFrontPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FrontPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimFrontPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceConnectionsList(site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceConnectionsList(site, deviceId, device, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkPartialUpdate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesBulkUpdate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesCreate(data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesList(id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20017>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesList(id, name, type, mgmtOnly, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesPartialUpdate(id: number, data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfaceTemplatesUpdate(id: number, data: WritableInterfaceTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InterfaceTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfaceTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkPartialUpdate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesBulkUpdate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesCreate(data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesList(id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20018>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesList(id, name, type, enabled, mtu, mgmtOnly, mode, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, kind, lagId, macAddress, vlanId, vlan, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, modeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, tagN, lagIdN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesPartialUpdate(id: number, data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInterfacesUpdate(id: number, data: WritableInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Interface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInterfacesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkPartialUpdate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsBulkUpdate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsCreate(data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsList(id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20019>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsList(id, name, partId, assetTag, discovered, q, regionId, region, siteId, site, deviceId, device, tag, parentId, manufacturerId, manufacturer, serial, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, partIdN, partIdIc, partIdNic, partIdIew, partIdNiew, partIdIsw, partIdNisw, partIdIe, partIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, parentIdN, manufacturerIdN, manufacturerN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsPartialUpdate(id: number, data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimInventoryItemsUpdate(id: number, data: WritableInventoryItem, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InventoryItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimInventoryItemsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkPartialUpdate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersBulkUpdate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersCreate(data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20020>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersPartialUpdate(id: number, data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimManufacturersUpdate(id: number, data: Manufacturer, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Manufacturer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimManufacturersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkPartialUpdate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsBulkUpdate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsCreate(data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsList(id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20021>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsList(id, name, slug, napalmDriver, description, q, manufacturerId, manufacturer, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, napalmDriverN, napalmDriverIc, napalmDriverNic, napalmDriverIew, napalmDriverNiew, napalmDriverIsw, napalmDriverNisw, napalmDriverIe, napalmDriverNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, manufacturerIdN, manufacturerN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsPartialUpdate(id: number, data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPlatformsUpdate(id: number, data: WritablePlatform, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Platform>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPlatformsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkPartialUpdate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsBulkUpdate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsCreate(data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsList(id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20023>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsList(id, name, status, type, supply, phase, voltage, amperage, maxUtilization, cabled, connected, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, powerPanelId, rackId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, statusN, typeN, supplyN, phaseN, voltageN, voltageLte, voltageLt, voltageGte, voltageGt, amperageN, amperageLte, amperageLt, amperageGte, amperageGt, maxUtilizationN, maxUtilizationLte, maxUtilizationLt, maxUtilizationGte, maxUtilizationGt, regionIdN, regionN, siteIdN, siteN, powerPanelIdN, rackIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsPartialUpdate(id: number, data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerFeedsUpdate(id: number, data: WritablePowerFeed, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerFeedsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkPartialUpdate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesBulkUpdate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesCreate(data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesList(id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20024>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesList(id, name, type, feedLeg, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, feedLegN, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesPartialUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletTemplatesUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutletTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkPartialUpdate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsBulkUpdate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsCreate(data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsList(id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20025>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsList(id, name, feedLeg, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, feedLegN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsPartialUpdate(id: number, data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerOutletsUpdate(id: number, data: WritablePowerOutlet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerOutlet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerOutletsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkPartialUpdate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsBulkUpdate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsCreate(data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsList(id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20026>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsList(id, name, q, regionId, region, siteId, site, rackGroupId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsPartialUpdate(id: number, data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPanelsUpdate(id: number, data: WritablePowerPanel, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPanel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPanelsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkPartialUpdate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesBulkUpdate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesCreate(data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesList(id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20027>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesList(id, name, type, maximumDraw, allocatedDraw, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesPartialUpdate(id: number, data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortTemplatesUpdate(id: number, data: WritablePowerPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkPartialUpdate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsBulkUpdate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsCreate(data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsList(id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20022>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsList(id, name, maximumDraw, allocatedDraw, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsPartialUpdate(id: number, data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsTrace(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsTrace(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimPowerPortsUpdate(id: number, data: WritablePowerPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PowerPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimPowerPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkPartialUpdate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsBulkUpdate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsCreate(data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20028>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsList(id, name, slug, description, q, regionId, region, siteId, site, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, parentIdN, parentN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsPartialUpdate(id: number, data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackGroupsUpdate(id: number, data: WritableRackGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkPartialUpdate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsBulkUpdate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsCreate(data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsList(id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20029>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsList(id, created, tenantGroupId, tenantGroup, tenantId, tenant, q, rackId, siteId, site, groupId, group, userId, user, tag, idN, idLte, idLt, idGte, idGt, createdN, createdLte, createdLt, createdGte, createdGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rackIdN, siteIdN, siteN, groupIdN, groupN, userIdN, userN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsPartialUpdate(id: number, data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackReservationsUpdate(id: number, data: WritableRackReservation, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackReservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackReservationsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkPartialUpdate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesBulkUpdate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesCreate(data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20030>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesPartialUpdate(id: number, data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRackRolesUpdate(id: number, data: RackRole, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RackRole>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRackRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkPartialUpdate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksBulkUpdate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksCreate(data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksElevationRead(id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RackUnit>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksElevationRead(id, q, face, render, unitWidth, unitHeight, legendWidth, exclude, expandDevices, includeImages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksList(id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20031>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksList(id, name, facilityId, assetTag, type, width, uHeight, descUnits, outerWidth, outerDepth, outerUnit, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, status, roleId, role, serial, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, facilityIdN, facilityIdIc, facilityIdNic, facilityIdIew, facilityIdNiew, facilityIdIsw, facilityIdNisw, facilityIdIe, facilityIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, typeN, widthN, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, outerWidthN, outerWidthLte, outerWidthLt, outerWidthGte, outerWidthGt, outerDepthN, outerDepthLte, outerDepthLt, outerDepthGte, outerDepthGt, outerUnitN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, statusN, roleIdN, roleN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksPartialUpdate(id: number, data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRacksUpdate(id: number, data: WritableRack, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Rack>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRacksUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkPartialUpdate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesBulkUpdate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesCreate(data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesList(id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20032>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesList(id, name, type, positions, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, devicetypeIdN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesPartialUpdate(id: number, data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortTemplatesUpdate(id: number, data: WritableRearPortTemplate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPortTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortTemplatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkPartialUpdate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsBulkUpdate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsCreate(data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsList(id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20033>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsList(id, name, type, positions, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsPartialUpdate(id: number, data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsPaths(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsPaths(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRearPortsUpdate(id: number, data: WritableRearPort, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RearPort>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRearPortsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkPartialUpdate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsBulkUpdate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsCreate(data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20034>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsPartialUpdate(id: number, data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimRegionsUpdate(id: number, data: WritableRegion, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimRegionsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkPartialUpdate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesBulkUpdate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesCreate(data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesList(id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20035>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesList(id, name, slug, facility, asn, latitude, longitude, contactName, contactPhone, contactEmail, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, regionId, region, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, facilityN, facilityIc, facilityNic, facilityIew, facilityNiew, facilityIsw, facilityNisw, facilityIe, facilityNie, asnN, asnLte, asnLt, asnGte, asnGt, latitudeN, latitudeLte, latitudeLt, latitudeGte, latitudeGt, longitudeN, longitudeLte, longitudeLt, longitudeGte, longitudeGt, contactNameN, contactNameIc, contactNameNic, contactNameIew, contactNameNiew, contactNameIsw, contactNameNisw, contactNameIe, contactNameNie, contactPhoneN, contactPhoneIc, contactPhoneNic, contactPhoneIew, contactPhoneNiew, contactPhoneIsw, contactPhoneNisw, contactPhoneIe, contactPhoneNie, contactEmailN, contactEmailIc, contactEmailNic, contactEmailIew, contactEmailNiew, contactEmailIsw, contactEmailNisw, contactEmailIe, contactEmailNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, regionIdN, regionN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesPartialUpdate(id: number, data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimSitesUpdate(id: number, data: WritableSite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Site>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimSitesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkPartialUpdate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisBulkUpdate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisCreate(data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisList(id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20036>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisList(id, domain, q, regionId, region, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, domainN, domainIc, domainNic, domainIew, domainNiew, domainIsw, domainNisw, domainIe, domainNie, regionIdN, regionN, siteIdN, siteN, tenantIdN, tenantN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisPartialUpdate(id: number, data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dcimVirtualChassisUpdate(id: number, data: WritableVirtualChassis, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualChassis>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dcimVirtualChassisUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DcimApi - factory interface
 * @export
 */
export const DcimApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DcimApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimCablesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkPartialUpdate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesBulkUpdate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesCreate(data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimCablesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [label] 
         * @param {string} [length] 
         * @param {string} [lengthUnit] 
         * @param {string} [q] 
         * @param {string} [type] 
         * @param {string} [status] 
         * @param {string} [color] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [rackId] 
         * @param {string} [rack] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [labelN] 
         * @param {string} [labelIc] 
         * @param {string} [labelNic] 
         * @param {string} [labelIew] 
         * @param {string} [labelNiew] 
         * @param {string} [labelIsw] 
         * @param {string} [labelNisw] 
         * @param {string} [labelIe] 
         * @param {string} [labelNie] 
         * @param {string} [lengthN] 
         * @param {string} [lengthLte] 
         * @param {string} [lengthLt] 
         * @param {string} [lengthGte] 
         * @param {string} [lengthGt] 
         * @param {string} [lengthUnitN] 
         * @param {string} [typeN] 
         * @param {string} [statusN] 
         * @param {string} [colorN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesList(id?: string, label?: string, length?: string, lengthUnit?: string, q?: string, type?: string, status?: string, color?: string, deviceId?: string, device?: string, rackId?: string, rack?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, labelN?: string, labelIc?: string, labelNic?: string, labelIew?: string, labelNiew?: string, labelIsw?: string, labelNisw?: string, labelIe?: string, labelNie?: string, lengthN?: string, lengthLte?: string, lengthLt?: string, lengthGte?: string, lengthGt?: string, lengthUnitN?: string, typeN?: string, statusN?: string, colorN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.dcimCablesList(id, label, length, lengthUnit, q, type, status, color, deviceId, device, rackId, rack, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, labelN, labelIc, labelNic, labelIew, labelNiew, labelIsw, labelNisw, labelIe, labelNie, lengthN, lengthLte, lengthLt, lengthGte, lengthGt, lengthUnitN, typeN, statusN, colorN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesPartialUpdate(id: number, data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesRead(id: number, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cable.
         * @param {WritableCable} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimCablesUpdate(id: number, data: WritableCable, options?: any): AxiosPromise<Cable> {
            return localVarFp.dcimCablesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
         * @param {string} peerDevice The name of the peer device
         * @param {string} peerInterface The name of the peer interface
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConnectedDeviceList(peerDevice: string, peerInterface: string, options?: any): AxiosPromise<Device> {
            return localVarFp.dcimConnectedDeviceList(peerDevice, peerInterface, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.dcimConsoleConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkPartialUpdate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesBulkUpdate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesCreate(data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2006> {
            return localVarFp.dcimConsolePortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesPartialUpdate(id: number, data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesRead(id: number, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port template.
         * @param {WritableConsolePortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortTemplatesUpdate(id: number, data: WritableConsolePortTemplate, options?: any): AxiosPromise<ConsolePortTemplate> {
            return localVarFp.dcimConsolePortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkPartialUpdate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsBulkUpdate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsCreate(data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsolePortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.dcimConsolePortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsPartialUpdate(id: number, data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsRead(id: number, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsTrace(id: number, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console port.
         * @param {WritableConsolePort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsolePortsUpdate(id: number, data: WritableConsolePort, options?: any): AxiosPromise<ConsolePort> {
            return localVarFp.dcimConsolePortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkPartialUpdate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesBulkUpdate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesCreate(data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2007> {
            return localVarFp.dcimConsoleServerPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesPartialUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesRead(id: number, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port template.
         * @param {WritableConsoleServerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortTemplatesUpdate(id: number, data: WritableConsoleServerPortTemplate, options?: any): AxiosPromise<ConsoleServerPortTemplate> {
            return localVarFp.dcimConsoleServerPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkPartialUpdate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsBulkUpdate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsCreate(data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimConsoleServerPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2008> {
            return localVarFp.dcimConsoleServerPortsList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsPartialUpdate(id: number, data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsRead(id: number, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this console server port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsTrace(id: number, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this console server port.
         * @param {WritableConsoleServerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimConsoleServerPortsUpdate(id: number, data: WritableConsoleServerPort, options?: any): AxiosPromise<ConsoleServerPort> {
            return localVarFp.dcimConsoleServerPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBayTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkPartialUpdate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesBulkUpdate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesCreate(data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBayTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesList(id?: string, name?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse2009> {
            return localVarFp.dcimDeviceBayTemplatesList(id, name, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesPartialUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesRead(id: number, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay template.
         * @param {WritableDeviceBayTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBayTemplatesUpdate(id: number, data: WritableDeviceBayTemplate, options?: any): AxiosPromise<DeviceBayTemplate> {
            return localVarFp.dcimDeviceBayTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBaysBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkPartialUpdate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysBulkUpdate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysCreate(data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceBaysDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysList(id?: string, name?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20010> {
            return localVarFp.dcimDeviceBaysList(id, name, description, q, regionId, region, siteId, site, deviceId, device, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysPartialUpdate(id: number, data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysRead(id: number, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device bay.
         * @param {WritableDeviceBay} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceBaysUpdate(id: number, data: WritableDeviceBay, options?: any): AxiosPromise<DeviceBay> {
            return localVarFp.dcimDeviceBaysUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkPartialUpdate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesBulkUpdate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesCreate(data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [vmRole] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesList(id?: string, name?: string, slug?: string, color?: string, vmRole?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20011> {
            return localVarFp.dcimDeviceRolesList(id, name, slug, color, vmRole, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesPartialUpdate(id: number, data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesRead(id: number, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device role.
         * @param {DeviceRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceRolesUpdate(id: number, data: DeviceRole, options?: any): AxiosPromise<DeviceRole> {
            return localVarFp.dcimDeviceRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkPartialUpdate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesBulkUpdate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesCreate(data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDeviceTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [model] 
         * @param {string} [slug] 
         * @param {string} [partNumber] 
         * @param {string} [uHeight] 
         * @param {string} [isFullDepth] 
         * @param {string} [subdeviceRole] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [modelN] 
         * @param {string} [modelIc] 
         * @param {string} [modelNic] 
         * @param {string} [modelIew] 
         * @param {string} [modelNiew] 
         * @param {string} [modelIsw] 
         * @param {string} [modelNisw] 
         * @param {string} [modelIe] 
         * @param {string} [modelNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [partNumberN] 
         * @param {string} [partNumberIc] 
         * @param {string} [partNumberNic] 
         * @param {string} [partNumberIew] 
         * @param {string} [partNumberNiew] 
         * @param {string} [partNumberIsw] 
         * @param {string} [partNumberNisw] 
         * @param {string} [partNumberIe] 
         * @param {string} [partNumberNie] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [subdeviceRoleN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesList(id?: string, model?: string, slug?: string, partNumber?: string, uHeight?: string, isFullDepth?: string, subdeviceRole?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, modelN?: string, modelIc?: string, modelNic?: string, modelIew?: string, modelNiew?: string, modelIsw?: string, modelNisw?: string, modelIe?: string, modelNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, partNumberN?: string, partNumberIc?: string, partNumberNic?: string, partNumberIew?: string, partNumberNiew?: string, partNumberIsw?: string, partNumberNisw?: string, partNumberIe?: string, partNumberNie?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, subdeviceRoleN?: string, manufacturerIdN?: string, manufacturerN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20012> {
            return localVarFp.dcimDeviceTypesList(id, model, slug, partNumber, uHeight, isFullDepth, subdeviceRole, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, modelN, modelIc, modelNic, modelIew, modelNiew, modelIsw, modelNisw, modelIe, modelNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, partNumberN, partNumberIc, partNumberNic, partNumberIew, partNumberNiew, partNumberIsw, partNumberNisw, partNumberIe, partNumberNie, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, subdeviceRoleN, manufacturerIdN, manufacturerN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesPartialUpdate(id: number, data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesRead(id: number, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device type.
         * @param {WritableDeviceType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDeviceTypesUpdate(id: number, data: WritableDeviceType, options?: any): AxiosPromise<DeviceType> {
            return localVarFp.dcimDeviceTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimDevicesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkPartialUpdate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesBulkUpdate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesCreate(data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimDevicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [assetTag] 
         * @param {string} [face] 
         * @param {string} [position] 
         * @param {string} [vcPosition] 
         * @param {string} [vcPriority] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [localContextData] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [deviceTypeId] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [rackId] 
         * @param {string} [clusterId] 
         * @param {string} [model] 
         * @param {string} [status] 
         * @param {string} [isFullDepth] 
         * @param {string} [macAddress] 
         * @param {string} [serial] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [virtualChassisId] 
         * @param {string} [virtualChassisMember] 
         * @param {string} [consolePorts] 
         * @param {string} [consoleServerPorts] 
         * @param {string} [powerPorts] 
         * @param {string} [powerOutlets] 
         * @param {string} [interfaces] 
         * @param {string} [passThroughPorts] 
         * @param {string} [deviceBays] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [faceN] 
         * @param {string} [positionN] 
         * @param {string} [positionLte] 
         * @param {string} [positionLt] 
         * @param {string} [positionGte] 
         * @param {string} [positionGt] 
         * @param {string} [vcPositionN] 
         * @param {string} [vcPositionLte] 
         * @param {string} [vcPositionLt] 
         * @param {string} [vcPositionGte] 
         * @param {string} [vcPositionGt] 
         * @param {string} [vcPriorityN] 
         * @param {string} [vcPriorityLte] 
         * @param {string} [vcPriorityLt] 
         * @param {string} [vcPriorityGte] 
         * @param {string} [vcPriorityGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {string} [deviceTypeIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [clusterIdN] 
         * @param {string} [modelN] 
         * @param {string} [statusN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [virtualChassisIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesList(id?: string, name?: string, assetTag?: string, face?: string, position?: string, vcPosition?: string, vcPriority?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, localContextData?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, manufacturerId?: string, manufacturer?: string, deviceTypeId?: string, roleId?: string, role?: string, platformId?: string, platform?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, rackId?: string, clusterId?: string, model?: string, status?: string, isFullDepth?: string, macAddress?: string, serial?: string, hasPrimaryIp?: string, virtualChassisId?: string, virtualChassisMember?: string, consolePorts?: string, consoleServerPorts?: string, powerPorts?: string, powerOutlets?: string, interfaces?: string, passThroughPorts?: string, deviceBays?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, faceN?: string, positionN?: string, positionLte?: string, positionLt?: string, positionGte?: string, positionGt?: string, vcPositionN?: string, vcPositionLte?: string, vcPositionLt?: string, vcPositionGte?: string, vcPositionGt?: string, vcPriorityN?: string, vcPriorityLte?: string, vcPriorityLt?: string, vcPriorityGte?: string, vcPriorityGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, manufacturerIdN?: string, manufacturerN?: string, deviceTypeIdN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, rackIdN?: string, clusterIdN?: string, modelN?: string, statusN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, virtualChassisIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20013> {
            return localVarFp.dcimDevicesList(id, name, assetTag, face, position, vcPosition, vcPriority, tenantGroupId, tenantGroup, tenantId, tenant, localContextData, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, manufacturerId, manufacturer, deviceTypeId, roleId, role, platformId, platform, regionId, region, siteId, site, rackGroupId, rackId, clusterId, model, status, isFullDepth, macAddress, serial, hasPrimaryIp, virtualChassisId, virtualChassisMember, consolePorts, consoleServerPorts, powerPorts, powerOutlets, interfaces, passThroughPorts, deviceBays, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, faceN, positionN, positionLte, positionLt, positionGte, positionGt, vcPositionN, vcPositionLte, vcPositionLt, vcPositionGte, vcPositionGt, vcPriorityN, vcPriorityLte, vcPriorityLt, vcPriorityGte, vcPriorityGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, manufacturerIdN, manufacturerN, deviceTypeIdN, roleIdN, roleN, platformIdN, platformN, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, rackIdN, clusterIdN, modelN, statusN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, virtualChassisIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Execute a NAPALM method on a Device
         * @param {number} id A unique integer value identifying this device.
         * @param {string} method 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesNapalm(id: number, method: string, options?: any): AxiosPromise<DeviceNAPALM> {
            return localVarFp.dcimDevicesNapalm(id, method, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesPartialUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesRead(id: number, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this device.
         * @param {WritableDeviceWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimDevicesUpdate(id: number, data: WritableDeviceWithConfigContext, options?: any): AxiosPromise<DeviceWithConfigContext> {
            return localVarFp.dcimDevicesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkPartialUpdate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesBulkUpdate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesCreate(data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesList(id?: string, name?: string, type?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20014> {
            return localVarFp.dcimFrontPortTemplatesList(id, name, type, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesPartialUpdate(id: number, data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesRead(id: number, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port template.
         * @param {WritableFrontPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortTemplatesUpdate(id: number, data: WritableFrontPortTemplate, options?: any): AxiosPromise<FrontPortTemplate> {
            return localVarFp.dcimFrontPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkPartialUpdate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsBulkUpdate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsCreate(data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimFrontPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsList(id?: string, name?: string, type?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20015> {
            return localVarFp.dcimFrontPortsList(id, name, type, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPartialUpdate(id: number, data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsPaths(id: number, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsPaths(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsRead(id: number, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this front port.
         * @param {WritableFrontPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimFrontPortsUpdate(id: number, data: WritableFrontPort, options?: any): AxiosPromise<FrontPort> {
            return localVarFp.dcimFrontPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceConnectionsList(site?: string, deviceId?: string, device?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20016> {
            return localVarFp.dcimInterfaceConnectionsList(site, deviceId, device, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfaceTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkPartialUpdate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesBulkUpdate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesCreate(data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfaceTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [mgmtOnly] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesList(id?: string, name?: string, type?: string, mgmtOnly?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20017> {
            return localVarFp.dcimInterfaceTemplatesList(id, name, type, mgmtOnly, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesPartialUpdate(id: number, data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesRead(id: number, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface template.
         * @param {WritableInterfaceTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfaceTemplatesUpdate(id: number, data: WritableInterfaceTemplate, options?: any): AxiosPromise<InterfaceTemplate> {
            return localVarFp.dcimInterfaceTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfacesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkPartialUpdate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesBulkUpdate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesCreate(data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInterfacesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [mgmtOnly] 
         * @param {string} [mode] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [kind] 
         * @param {string} [lagId] 
         * @param {string} [macAddress] 
         * @param {string} [vlanId] 
         * @param {string} [vlan] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [modeN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tagN] 
         * @param {string} [lagIdN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesList(id?: string, name?: string, type?: string, enabled?: string, mtu?: string, mgmtOnly?: string, mode?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, kind?: string, lagId?: string, macAddress?: string, vlanId?: string, vlan?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, modeN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tagN?: string, lagIdN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20018> {
            return localVarFp.dcimInterfacesList(id, name, type, enabled, mtu, mgmtOnly, mode, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, kind, lagId, macAddress, vlanId, vlan, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, modeN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, tagN, lagIdN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesPartialUpdate(id: number, data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesRead(id: number, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesTrace(id: number, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInterfacesUpdate(id: number, data: WritableInterface, options?: any): AxiosPromise<Interface> {
            return localVarFp.dcimInterfacesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimInventoryItemsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkPartialUpdate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsBulkUpdate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsCreate(data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimInventoryItemsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [partId] 
         * @param {string} [assetTag] 
         * @param {string} [discovered] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [parentId] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [serial] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [partIdN] 
         * @param {string} [partIdIc] 
         * @param {string} [partIdNic] 
         * @param {string} [partIdIew] 
         * @param {string} [partIdNiew] 
         * @param {string} [partIdIsw] 
         * @param {string} [partIdNisw] 
         * @param {string} [partIdIe] 
         * @param {string} [partIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [parentIdN] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsList(id?: string, name?: string, partId?: string, assetTag?: string, discovered?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, parentId?: string, manufacturerId?: string, manufacturer?: string, serial?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, partIdN?: string, partIdIc?: string, partIdNic?: string, partIdIew?: string, partIdNiew?: string, partIdIsw?: string, partIdNisw?: string, partIdIe?: string, partIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, parentIdN?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20019> {
            return localVarFp.dcimInventoryItemsList(id, name, partId, assetTag, discovered, q, regionId, region, siteId, site, deviceId, device, tag, parentId, manufacturerId, manufacturer, serial, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, partIdN, partIdIc, partIdNic, partIdIew, partIdNiew, partIdIsw, partIdNisw, partIdIe, partIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, parentIdN, manufacturerIdN, manufacturerN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsPartialUpdate(id: number, data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsRead(id: number, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this inventory item.
         * @param {WritableInventoryItem} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimInventoryItemsUpdate(id: number, data: WritableInventoryItem, options?: any): AxiosPromise<InventoryItem> {
            return localVarFp.dcimInventoryItemsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimManufacturersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkPartialUpdate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersBulkUpdate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersCreate(data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimManufacturersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20020> {
            return localVarFp.dcimManufacturersList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersPartialUpdate(id: number, data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersRead(id: number, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this manufacturer.
         * @param {Manufacturer} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimManufacturersUpdate(id: number, data: Manufacturer, options?: any): AxiosPromise<Manufacturer> {
            return localVarFp.dcimManufacturersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPlatformsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkPartialUpdate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsBulkUpdate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsCreate(data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPlatformsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [napalmDriver] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [manufacturerId] 
         * @param {string} [manufacturer] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [napalmDriverN] 
         * @param {string} [napalmDriverIc] 
         * @param {string} [napalmDriverNic] 
         * @param {string} [napalmDriverIew] 
         * @param {string} [napalmDriverNiew] 
         * @param {string} [napalmDriverIsw] 
         * @param {string} [napalmDriverNisw] 
         * @param {string} [napalmDriverIe] 
         * @param {string} [napalmDriverNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [manufacturerIdN] 
         * @param {string} [manufacturerN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsList(id?: string, name?: string, slug?: string, napalmDriver?: string, description?: string, q?: string, manufacturerId?: string, manufacturer?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, napalmDriverN?: string, napalmDriverIc?: string, napalmDriverNic?: string, napalmDriverIew?: string, napalmDriverNiew?: string, napalmDriverIsw?: string, napalmDriverNisw?: string, napalmDriverIe?: string, napalmDriverNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, manufacturerIdN?: string, manufacturerN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20021> {
            return localVarFp.dcimPlatformsList(id, name, slug, napalmDriver, description, q, manufacturerId, manufacturer, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, napalmDriverN, napalmDriverIc, napalmDriverNic, napalmDriverIew, napalmDriverNiew, napalmDriverIsw, napalmDriverNisw, napalmDriverIe, napalmDriverNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, manufacturerIdN, manufacturerN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsPartialUpdate(id: number, data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsRead(id: number, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this platform.
         * @param {WritablePlatform} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPlatformsUpdate(id: number, data: WritablePlatform, options?: any): AxiosPromise<Platform> {
            return localVarFp.dcimPlatformsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [name] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerConnectionsList(name?: string, site?: string, deviceId?: string, device?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.dcimPowerConnectionsList(name, site, deviceId, device, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerFeedsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkPartialUpdate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsBulkUpdate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsCreate(data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerFeedsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [type] 
         * @param {string} [supply] 
         * @param {string} [phase] 
         * @param {string} [voltage] 
         * @param {string} [amperage] 
         * @param {string} [maxUtilization] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [powerPanelId] 
         * @param {string} [rackId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [statusN] 
         * @param {string} [typeN] 
         * @param {string} [supplyN] 
         * @param {string} [phaseN] 
         * @param {string} [voltageN] 
         * @param {string} [voltageLte] 
         * @param {string} [voltageLt] 
         * @param {string} [voltageGte] 
         * @param {string} [voltageGt] 
         * @param {string} [amperageN] 
         * @param {string} [amperageLte] 
         * @param {string} [amperageLt] 
         * @param {string} [amperageGte] 
         * @param {string} [amperageGt] 
         * @param {string} [maxUtilizationN] 
         * @param {string} [maxUtilizationLte] 
         * @param {string} [maxUtilizationLt] 
         * @param {string} [maxUtilizationGte] 
         * @param {string} [maxUtilizationGt] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [powerPanelIdN] 
         * @param {string} [rackIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsList(id?: string, name?: string, status?: string, type?: string, supply?: string, phase?: string, voltage?: string, amperage?: string, maxUtilization?: string, cabled?: string, connected?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, powerPanelId?: string, rackId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, statusN?: string, typeN?: string, supplyN?: string, phaseN?: string, voltageN?: string, voltageLte?: string, voltageLt?: string, voltageGte?: string, voltageGt?: string, amperageN?: string, amperageLte?: string, amperageLt?: string, amperageGte?: string, amperageGt?: string, maxUtilizationN?: string, maxUtilizationLte?: string, maxUtilizationLt?: string, maxUtilizationGte?: string, maxUtilizationGt?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, powerPanelIdN?: string, rackIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20023> {
            return localVarFp.dcimPowerFeedsList(id, name, status, type, supply, phase, voltage, amperage, maxUtilization, cabled, connected, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, powerPanelId, rackId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, statusN, typeN, supplyN, phaseN, voltageN, voltageLte, voltageLt, voltageGte, voltageGt, amperageN, amperageLte, amperageLt, amperageGte, amperageGt, maxUtilizationN, maxUtilizationLte, maxUtilizationLt, maxUtilizationGte, maxUtilizationGt, regionIdN, regionN, siteIdN, siteN, powerPanelIdN, rackIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsPartialUpdate(id: number, data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsRead(id: number, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power feed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsTrace(id: number, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power feed.
         * @param {WritablePowerFeed} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerFeedsUpdate(id: number, data: WritablePowerFeed, options?: any): AxiosPromise<PowerFeed> {
            return localVarFp.dcimPowerFeedsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkPartialUpdate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesBulkUpdate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesCreate(data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [feedLeg] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [feedLegN] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesList(id?: string, name?: string, type?: string, feedLeg?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, feedLegN?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20024> {
            return localVarFp.dcimPowerOutletTemplatesList(id, name, type, feedLeg, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, feedLegN, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesPartialUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesRead(id: number, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet template.
         * @param {WritablePowerOutletTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletTemplatesUpdate(id: number, data: WritablePowerOutletTemplate, options?: any): AxiosPromise<PowerOutletTemplate> {
            return localVarFp.dcimPowerOutletTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkPartialUpdate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsBulkUpdate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsCreate(data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerOutletsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [feedLeg] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [feedLegN] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsList(id?: string, name?: string, feedLeg?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, feedLegN?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20025> {
            return localVarFp.dcimPowerOutletsList(id, name, feedLeg, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, feedLegN, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsPartialUpdate(id: number, data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsRead(id: number, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsTrace(id: number, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power outlet.
         * @param {WritablePowerOutlet} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerOutletsUpdate(id: number, data: WritablePowerOutlet, options?: any): AxiosPromise<PowerOutlet> {
            return localVarFp.dcimPowerOutletsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPanelsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkPartialUpdate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsBulkUpdate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsCreate(data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPanelsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [rackGroupId] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [rackGroupIdN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsList(id?: string, name?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, rackGroupId?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, rackGroupIdN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20026> {
            return localVarFp.dcimPowerPanelsList(id, name, q, regionId, region, siteId, site, rackGroupId, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, regionIdN, regionN, siteIdN, siteN, rackGroupIdN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsPartialUpdate(id: number, data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsRead(id: number, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power panel.
         * @param {WritablePowerPanel} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPanelsUpdate(id: number, data: WritablePowerPanel, options?: any): AxiosPromise<PowerPanel> {
            return localVarFp.dcimPowerPanelsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkPartialUpdate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesBulkUpdate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesCreate(data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesList(id?: string, name?: string, type?: string, maximumDraw?: string, allocatedDraw?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20027> {
            return localVarFp.dcimPowerPortTemplatesList(id, name, type, maximumDraw, allocatedDraw, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesPartialUpdate(id: number, data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesRead(id: number, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port template.
         * @param {WritablePowerPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortTemplatesUpdate(id: number, data: WritablePowerPortTemplate, options?: any): AxiosPromise<PowerPortTemplate> {
            return localVarFp.dcimPowerPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkPartialUpdate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsBulkUpdate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsCreate(data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimPowerPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [maximumDraw] 
         * @param {string} [allocatedDraw] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [connected] 
         * @param {string} [type] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [maximumDrawN] 
         * @param {string} [maximumDrawLte] 
         * @param {string} [maximumDrawLt] 
         * @param {string} [maximumDrawGte] 
         * @param {string} [maximumDrawGt] 
         * @param {string} [allocatedDrawN] 
         * @param {string} [allocatedDrawLte] 
         * @param {string} [allocatedDrawLt] 
         * @param {string} [allocatedDrawGte] 
         * @param {string} [allocatedDrawGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {string} [typeN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsList(id?: string, name?: string, maximumDraw?: string, allocatedDraw?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, connected?: string, type?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, maximumDrawN?: string, maximumDrawLte?: string, maximumDrawLt?: string, maximumDrawGte?: string, maximumDrawGt?: string, allocatedDrawN?: string, allocatedDrawLte?: string, allocatedDrawLt?: string, allocatedDrawGte?: string, allocatedDrawGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, typeN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20022> {
            return localVarFp.dcimPowerPortsList(id, name, maximumDraw, allocatedDraw, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, connected, type, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, maximumDrawN, maximumDrawLte, maximumDrawLt, maximumDrawGte, maximumDrawGt, allocatedDrawN, allocatedDrawLte, allocatedDrawLt, allocatedDrawGte, allocatedDrawGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, typeN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsPartialUpdate(id: number, data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsRead(id: number, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
         * @param {number} id A unique integer value identifying this power port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsTrace(id: number, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsTrace(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this power port.
         * @param {WritablePowerPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimPowerPortsUpdate(id: number, data: WritablePowerPort, options?: any): AxiosPromise<PowerPort> {
            return localVarFp.dcimPowerPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkPartialUpdate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsBulkUpdate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsCreate(data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20028> {
            return localVarFp.dcimRackGroupsList(id, name, slug, description, q, regionId, region, siteId, site, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, parentIdN, parentN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsPartialUpdate(id: number, data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsRead(id: number, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack group.
         * @param {WritableRackGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackGroupsUpdate(id: number, data: WritableRackGroup, options?: any): AxiosPromise<RackGroup> {
            return localVarFp.dcimRackGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackReservationsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkPartialUpdate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsBulkUpdate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsCreate(data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackReservationsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [created] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [q] 
         * @param {string} [rackId] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [userId] 
         * @param {string} [user] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [createdN] 
         * @param {string} [createdLte] 
         * @param {string} [createdLt] 
         * @param {string} [createdGte] 
         * @param {string} [createdGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rackIdN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [userIdN] 
         * @param {string} [userN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsList(id?: string, created?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, q?: string, rackId?: string, siteId?: string, site?: string, groupId?: string, group?: string, userId?: string, user?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, createdN?: string, createdLte?: string, createdLt?: string, createdGte?: string, createdGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rackIdN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, userIdN?: string, userN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20029> {
            return localVarFp.dcimRackReservationsList(id, created, tenantGroupId, tenantGroup, tenantId, tenant, q, rackId, siteId, site, groupId, group, userId, user, tag, idN, idLte, idLt, idGte, idGt, createdN, createdLte, createdLt, createdGte, createdGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rackIdN, siteIdN, siteN, groupIdN, groupN, userIdN, userN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsPartialUpdate(id: number, data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsRead(id: number, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack reservation.
         * @param {WritableRackReservation} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackReservationsUpdate(id: number, data: WritableRackReservation, options?: any): AxiosPromise<RackReservation> {
            return localVarFp.dcimRackReservationsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkPartialUpdate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesBulkUpdate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesCreate(data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRackRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [color] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [colorN] 
         * @param {string} [colorIc] 
         * @param {string} [colorNic] 
         * @param {string} [colorIew] 
         * @param {string} [colorNiew] 
         * @param {string} [colorIsw] 
         * @param {string} [colorNisw] 
         * @param {string} [colorIe] 
         * @param {string} [colorNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesList(id?: string, name?: string, slug?: string, color?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, colorN?: string, colorIc?: string, colorNic?: string, colorIew?: string, colorNiew?: string, colorIsw?: string, colorNisw?: string, colorIe?: string, colorNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20030> {
            return localVarFp.dcimRackRolesList(id, name, slug, color, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, colorN, colorIc, colorNic, colorIew, colorNiew, colorIsw, colorNisw, colorIe, colorNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesPartialUpdate(id: number, data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesRead(id: number, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack role.
         * @param {RackRole} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRackRolesUpdate(id: number, data: RackRole, options?: any): AxiosPromise<RackRole> {
            return localVarFp.dcimRackRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRacksBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkPartialUpdate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksBulkUpdate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksCreate(data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRacksDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
         * @param {number} id A unique integer value identifying this rack.
         * @param {string} [q] 
         * @param {'front' | 'rear'} [face] 
         * @param {'json' | 'svg'} [render] 
         * @param {number} [unitWidth] 
         * @param {number} [unitHeight] 
         * @param {number} [legendWidth] 
         * @param {number} [exclude] 
         * @param {boolean} [expandDevices] 
         * @param {boolean} [includeImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksElevationRead(id: number, q?: string, face?: 'front' | 'rear', render?: 'json' | 'svg', unitWidth?: number, unitHeight?: number, legendWidth?: number, exclude?: number, expandDevices?: boolean, includeImages?: boolean, options?: any): AxiosPromise<Array<RackUnit>> {
            return localVarFp.dcimRacksElevationRead(id, q, face, render, unitWidth, unitHeight, legendWidth, exclude, expandDevices, includeImages, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [facilityId] 
         * @param {string} [assetTag] 
         * @param {string} [type] 
         * @param {string} [width] 
         * @param {string} [uHeight] 
         * @param {string} [descUnits] 
         * @param {string} [outerWidth] 
         * @param {string} [outerDepth] 
         * @param {string} [outerUnit] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [status] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [serial] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [facilityIdN] 
         * @param {string} [facilityIdIc] 
         * @param {string} [facilityIdNic] 
         * @param {string} [facilityIdIew] 
         * @param {string} [facilityIdNiew] 
         * @param {string} [facilityIdIsw] 
         * @param {string} [facilityIdNisw] 
         * @param {string} [facilityIdIe] 
         * @param {string} [facilityIdNie] 
         * @param {string} [assetTagN] 
         * @param {string} [assetTagIc] 
         * @param {string} [assetTagNic] 
         * @param {string} [assetTagIew] 
         * @param {string} [assetTagNiew] 
         * @param {string} [assetTagIsw] 
         * @param {string} [assetTagNisw] 
         * @param {string} [assetTagIe] 
         * @param {string} [assetTagNie] 
         * @param {string} [typeN] 
         * @param {string} [widthN] 
         * @param {string} [uHeightN] 
         * @param {string} [uHeightLte] 
         * @param {string} [uHeightLt] 
         * @param {string} [uHeightGte] 
         * @param {string} [uHeightGt] 
         * @param {string} [outerWidthN] 
         * @param {string} [outerWidthLte] 
         * @param {string} [outerWidthLt] 
         * @param {string} [outerWidthGte] 
         * @param {string} [outerWidthGt] 
         * @param {string} [outerDepthN] 
         * @param {string} [outerDepthLte] 
         * @param {string} [outerDepthLt] 
         * @param {string} [outerDepthGte] 
         * @param {string} [outerDepthGt] 
         * @param {string} [outerUnitN] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [statusN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksList(id?: string, name?: string, facilityId?: string, assetTag?: string, type?: string, width?: string, uHeight?: string, descUnits?: string, outerWidth?: string, outerDepth?: string, outerUnit?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, status?: string, roleId?: string, role?: string, serial?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, facilityIdN?: string, facilityIdIc?: string, facilityIdNic?: string, facilityIdIew?: string, facilityIdNiew?: string, facilityIdIsw?: string, facilityIdNisw?: string, facilityIdIe?: string, facilityIdNie?: string, assetTagN?: string, assetTagIc?: string, assetTagNic?: string, assetTagIew?: string, assetTagNiew?: string, assetTagIsw?: string, assetTagNisw?: string, assetTagIe?: string, assetTagNie?: string, typeN?: string, widthN?: string, uHeightN?: string, uHeightLte?: string, uHeightLt?: string, uHeightGte?: string, uHeightGt?: string, outerWidthN?: string, outerWidthLte?: string, outerWidthLt?: string, outerWidthGte?: string, outerWidthGt?: string, outerDepthN?: string, outerDepthLte?: string, outerDepthLt?: string, outerDepthGte?: string, outerDepthGt?: string, outerUnitN?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, statusN?: string, roleIdN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20031> {
            return localVarFp.dcimRacksList(id, name, facilityId, assetTag, type, width, uHeight, descUnits, outerWidth, outerDepth, outerUnit, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, status, roleId, role, serial, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, facilityIdN, facilityIdIc, facilityIdNic, facilityIdIew, facilityIdNiew, facilityIdIsw, facilityIdNisw, facilityIdIe, facilityIdNie, assetTagN, assetTagIc, assetTagNic, assetTagIew, assetTagNiew, assetTagIsw, assetTagNisw, assetTagIe, assetTagNie, typeN, widthN, uHeightN, uHeightLte, uHeightLt, uHeightGte, uHeightGt, outerWidthN, outerWidthLte, outerWidthLt, outerWidthGte, outerWidthGt, outerDepthN, outerDepthLte, outerDepthLt, outerDepthGte, outerDepthGt, outerUnitN, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, statusN, roleIdN, roleN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksPartialUpdate(id: number, data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksRead(id: number, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rack.
         * @param {WritableRack} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRacksUpdate(id: number, data: WritableRack, options?: any): AxiosPromise<Rack> {
            return localVarFp.dcimRacksUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortTemplatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkPartialUpdate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesBulkUpdate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesCreate(data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortTemplatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [q] 
         * @param {string} [devicetypeId] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [devicetypeIdN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesList(id?: string, name?: string, type?: string, positions?: string, q?: string, devicetypeId?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, devicetypeIdN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20032> {
            return localVarFp.dcimRearPortTemplatesList(id, name, type, positions, q, devicetypeId, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, devicetypeIdN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesPartialUpdate(id: number, data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesRead(id: number, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port template.
         * @param {WritableRearPortTemplate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortTemplatesUpdate(id: number, data: WritableRearPortTemplate, options?: any): AxiosPromise<RearPortTemplate> {
            return localVarFp.dcimRearPortTemplatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkPartialUpdate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsBulkUpdate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsCreate(data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRearPortsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [type] 
         * @param {string} [positions] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [tag] 
         * @param {string} [cabled] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [typeN] 
         * @param {string} [positionsN] 
         * @param {string} [positionsLte] 
         * @param {string} [positionsLt] 
         * @param {string} [positionsGte] 
         * @param {string} [positionsGt] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsList(id?: string, name?: string, type?: string, positions?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, deviceId?: string, device?: string, tag?: string, cabled?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, typeN?: string, positionsN?: string, positionsLte?: string, positionsLt?: string, positionsGte?: string, positionsGt?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, deviceIdN?: string, deviceN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20033> {
            return localVarFp.dcimRearPortsList(id, name, type, positions, description, q, regionId, region, siteId, site, deviceId, device, tag, cabled, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, typeN, positionsN, positionsLte, positionsLt, positionsGte, positionsGt, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, deviceIdN, deviceN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPartialUpdate(id: number, data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * Return all CablePaths which traverse a given pass-through port.
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsPaths(id: number, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsPaths(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsRead(id: number, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this rear port.
         * @param {WritableRearPort} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRearPortsUpdate(id: number, data: WritableRearPort, options?: any): AxiosPromise<RearPort> {
            return localVarFp.dcimRearPortsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimRegionsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkPartialUpdate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsBulkUpdate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsCreate(data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimRegionsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [parentId] 
         * @param {string} [parent] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [parentIdN] 
         * @param {string} [parentN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsList(id?: string, name?: string, slug?: string, description?: string, q?: string, parentId?: string, parent?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, parentIdN?: string, parentN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20034> {
            return localVarFp.dcimRegionsList(id, name, slug, description, q, parentId, parent, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, parentIdN, parentN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsPartialUpdate(id: number, data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsRead(id: number, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this region.
         * @param {WritableRegion} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimRegionsUpdate(id: number, data: WritableRegion, options?: any): AxiosPromise<Region> {
            return localVarFp.dcimRegionsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimSitesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkPartialUpdate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesBulkUpdate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesCreate(data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimSitesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [facility] 
         * @param {string} [asn] 
         * @param {string} [latitude] 
         * @param {string} [longitude] 
         * @param {string} [contactName] 
         * @param {string} [contactPhone] 
         * @param {string} [contactEmail] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [facilityN] 
         * @param {string} [facilityIc] 
         * @param {string} [facilityNic] 
         * @param {string} [facilityIew] 
         * @param {string} [facilityNiew] 
         * @param {string} [facilityIsw] 
         * @param {string} [facilityNisw] 
         * @param {string} [facilityIe] 
         * @param {string} [facilityNie] 
         * @param {string} [asnN] 
         * @param {string} [asnLte] 
         * @param {string} [asnLt] 
         * @param {string} [asnGte] 
         * @param {string} [asnGt] 
         * @param {string} [latitudeN] 
         * @param {string} [latitudeLte] 
         * @param {string} [latitudeLt] 
         * @param {string} [latitudeGte] 
         * @param {string} [latitudeGt] 
         * @param {string} [longitudeN] 
         * @param {string} [longitudeLte] 
         * @param {string} [longitudeLt] 
         * @param {string} [longitudeGte] 
         * @param {string} [longitudeGt] 
         * @param {string} [contactNameN] 
         * @param {string} [contactNameIc] 
         * @param {string} [contactNameNic] 
         * @param {string} [contactNameIew] 
         * @param {string} [contactNameNiew] 
         * @param {string} [contactNameIsw] 
         * @param {string} [contactNameNisw] 
         * @param {string} [contactNameIe] 
         * @param {string} [contactNameNie] 
         * @param {string} [contactPhoneN] 
         * @param {string} [contactPhoneIc] 
         * @param {string} [contactPhoneNic] 
         * @param {string} [contactPhoneIew] 
         * @param {string} [contactPhoneNiew] 
         * @param {string} [contactPhoneIsw] 
         * @param {string} [contactPhoneNisw] 
         * @param {string} [contactPhoneIe] 
         * @param {string} [contactPhoneNie] 
         * @param {string} [contactEmailN] 
         * @param {string} [contactEmailIc] 
         * @param {string} [contactEmailNic] 
         * @param {string} [contactEmailIew] 
         * @param {string} [contactEmailNiew] 
         * @param {string} [contactEmailIsw] 
         * @param {string} [contactEmailNisw] 
         * @param {string} [contactEmailIe] 
         * @param {string} [contactEmailNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesList(id?: string, name?: string, slug?: string, facility?: string, asn?: string, latitude?: string, longitude?: string, contactName?: string, contactPhone?: string, contactEmail?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, regionId?: string, region?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, facilityN?: string, facilityIc?: string, facilityNic?: string, facilityIew?: string, facilityNiew?: string, facilityIsw?: string, facilityNisw?: string, facilityIe?: string, facilityNie?: string, asnN?: string, asnLte?: string, asnLt?: string, asnGte?: string, asnGt?: string, latitudeN?: string, latitudeLte?: string, latitudeLt?: string, latitudeGte?: string, latitudeGt?: string, longitudeN?: string, longitudeLte?: string, longitudeLt?: string, longitudeGte?: string, longitudeGt?: string, contactNameN?: string, contactNameIc?: string, contactNameNic?: string, contactNameIew?: string, contactNameNiew?: string, contactNameIsw?: string, contactNameNisw?: string, contactNameIe?: string, contactNameNie?: string, contactPhoneN?: string, contactPhoneIc?: string, contactPhoneNic?: string, contactPhoneIew?: string, contactPhoneNiew?: string, contactPhoneIsw?: string, contactPhoneNisw?: string, contactPhoneIe?: string, contactPhoneNie?: string, contactEmailN?: string, contactEmailIc?: string, contactEmailNic?: string, contactEmailIew?: string, contactEmailNiew?: string, contactEmailIsw?: string, contactEmailNisw?: string, contactEmailIe?: string, contactEmailNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, regionIdN?: string, regionN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20035> {
            return localVarFp.dcimSitesList(id, name, slug, facility, asn, latitude, longitude, contactName, contactPhone, contactEmail, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, regionId, region, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, facilityN, facilityIc, facilityNic, facilityIew, facilityNiew, facilityIsw, facilityNisw, facilityIe, facilityNie, asnN, asnLte, asnLt, asnGte, asnGt, latitudeN, latitudeLte, latitudeLt, latitudeGte, latitudeGt, longitudeN, longitudeLte, longitudeLt, longitudeGte, longitudeGt, contactNameN, contactNameIc, contactNameNic, contactNameIew, contactNameNiew, contactNameIsw, contactNameNisw, contactNameIe, contactNameNie, contactPhoneN, contactPhoneIc, contactPhoneNic, contactPhoneIew, contactPhoneNiew, contactPhoneIsw, contactPhoneNisw, contactPhoneIe, contactPhoneNie, contactEmailN, contactEmailIc, contactEmailNic, contactEmailIew, contactEmailNiew, contactEmailIsw, contactEmailNisw, contactEmailIe, contactEmailNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, regionIdN, regionN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesPartialUpdate(id: number, data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesRead(id: number, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this site.
         * @param {WritableSite} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimSitesUpdate(id: number, data: WritableSite, options?: any): AxiosPromise<Site> {
            return localVarFp.dcimSitesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.dcimVirtualChassisBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkPartialUpdate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisBulkUpdate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisCreate(data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.dcimVirtualChassisDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [domain] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [domainN] 
         * @param {string} [domainIc] 
         * @param {string} [domainNic] 
         * @param {string} [domainIew] 
         * @param {string} [domainNiew] 
         * @param {string} [domainIsw] 
         * @param {string} [domainNisw] 
         * @param {string} [domainIe] 
         * @param {string} [domainNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisList(id?: string, domain?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, tenantId?: string, tenant?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, domainN?: string, domainIc?: string, domainNic?: string, domainIew?: string, domainNiew?: string, domainIsw?: string, domainNisw?: string, domainIe?: string, domainNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, tenantIdN?: string, tenantN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20036> {
            return localVarFp.dcimVirtualChassisList(id, domain, q, regionId, region, siteId, site, tenantId, tenant, tag, idN, idLte, idLt, idGte, idGt, domainN, domainIc, domainNic, domainIew, domainNiew, domainIsw, domainNisw, domainIe, domainNie, regionIdN, regionN, siteIdN, siteN, tenantIdN, tenantN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisPartialUpdate(id: number, data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisRead(id: number, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual chassis.
         * @param {WritableVirtualChassis} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dcimVirtualChassisUpdate(id: number, data: WritableVirtualChassis, options?: any): AxiosPromise<VirtualChassis> {
            return localVarFp.dcimVirtualChassisUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for dcimCablesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesBulkPartialUpdateRequest
 */
export interface DcimApiDcimCablesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesBulkPartialUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesBulkUpdateRequest
 */
export interface DcimApiDcimCablesBulkUpdateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesBulkUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesCreateRequest
 */
export interface DcimApiDcimCablesCreateRequest {
    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesCreate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesDeleteRequest
 */
export interface DcimApiDcimCablesDeleteRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimCablesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesListRequest
 */
export interface DcimApiDcimCablesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly label?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly length?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthUnit?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly rack?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly labelNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly lengthUnitN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimCablesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimCablesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimCablesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimCablesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesPartialUpdateRequest
 */
export interface DcimApiDcimCablesPartialUpdateRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesPartialUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimCablesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesReadRequest
 */
export interface DcimApiDcimCablesReadRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimCablesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimCablesUpdateRequest
 */
export interface DcimApiDcimCablesUpdateRequest {
    /**
     * A unique integer value identifying this cable.
     * @type {number}
     * @memberof DcimApiDcimCablesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCable}
     * @memberof DcimApiDcimCablesUpdate
     */
    readonly data: WritableCable
}

/**
 * Request parameters for dcimConnectedDeviceList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConnectedDeviceListRequest
 */
export interface DcimApiDcimConnectedDeviceListRequest {
    /**
     * The name of the peer device
     * @type {string}
     * @memberof DcimApiDcimConnectedDeviceList
     */
    readonly peerDevice: string

    /**
     * The name of the peer interface
     * @type {string}
     * @memberof DcimApiDcimConnectedDeviceList
     */
    readonly peerInterface: string
}

/**
 * Request parameters for dcimConsoleConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleConnectionsListRequest
 */
export interface DcimApiDcimConsoleConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesBulkPartialUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesBulkUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesCreateRequest
 */
export interface DcimApiDcimConsolePortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesCreate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesDeleteRequest
 */
export interface DcimApiDcimConsolePortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesListRequest
 */
export interface DcimApiDcimConsolePortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesPartialUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesReadRequest
 */
export interface DcimApiDcimConsolePortTemplatesReadRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortTemplatesUpdateRequest
 */
export interface DcimApiDcimConsolePortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this console port template.
     * @type {number}
     * @memberof DcimApiDcimConsolePortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePortTemplate}
     * @memberof DcimApiDcimConsolePortTemplatesUpdate
     */
    readonly data: WritableConsolePortTemplate
}

/**
 * Request parameters for dcimConsolePortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsBulkPartialUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsBulkUpdateRequest
 */
export interface DcimApiDcimConsolePortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsBulkUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsCreateRequest
 */
export interface DcimApiDcimConsolePortsCreateRequest {
    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsCreate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsDeleteRequest
 */
export interface DcimApiDcimConsolePortsDeleteRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsListRequest
 */
export interface DcimApiDcimConsolePortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsolePortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsPartialUpdateRequest
 */
export interface DcimApiDcimConsolePortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsPartialUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsolePortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsReadRequest
 */
export interface DcimApiDcimConsolePortsReadRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsTraceRequest
 */
export interface DcimApiDcimConsolePortsTraceRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsolePortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsolePortsUpdateRequest
 */
export interface DcimApiDcimConsolePortsUpdateRequest {
    /**
     * A unique integer value identifying this console port.
     * @type {number}
     * @memberof DcimApiDcimConsolePortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsolePort}
     * @memberof DcimApiDcimConsolePortsUpdate
     */
    readonly data: WritableConsolePort
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesBulkUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesCreateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesCreate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesDeleteRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesListRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesPartialUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesReadRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortTemplatesUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this console server port template.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPortTemplate}
     * @memberof DcimApiDcimConsoleServerPortTemplatesUpdate
     */
    readonly data: WritableConsoleServerPortTemplate
}

/**
 * Request parameters for dcimConsoleServerPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsBulkPartialUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsBulkUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsBulkUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsCreateRequest
 */
export interface DcimApiDcimConsoleServerPortsCreateRequest {
    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsCreate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsDeleteRequest
 */
export interface DcimApiDcimConsoleServerPortsDeleteRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsListRequest
 */
export interface DcimApiDcimConsoleServerPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimConsoleServerPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsPartialUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsPartialUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimConsoleServerPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsReadRequest
 */
export interface DcimApiDcimConsoleServerPortsReadRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsTraceRequest
 */
export interface DcimApiDcimConsoleServerPortsTraceRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimConsoleServerPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimConsoleServerPortsUpdateRequest
 */
export interface DcimApiDcimConsoleServerPortsUpdateRequest {
    /**
     * A unique integer value identifying this console server port.
     * @type {number}
     * @memberof DcimApiDcimConsoleServerPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableConsoleServerPort}
     * @memberof DcimApiDcimConsoleServerPortsUpdate
     */
    readonly data: WritableConsoleServerPort
}

/**
 * Request parameters for dcimDeviceBayTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesBulkPartialUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesBulkUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesCreateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesCreateRequest {
    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesCreate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesDeleteRequest
 */
export interface DcimApiDcimDeviceBayTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesListRequest
 */
export interface DcimApiDcimDeviceBayTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesPartialUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBayTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesReadRequest
 */
export interface DcimApiDcimDeviceBayTemplatesReadRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBayTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBayTemplatesUpdateRequest
 */
export interface DcimApiDcimDeviceBayTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this device bay template.
     * @type {number}
     * @memberof DcimApiDcimDeviceBayTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBayTemplate}
     * @memberof DcimApiDcimDeviceBayTemplatesUpdate
     */
    readonly data: WritableDeviceBayTemplate
}

/**
 * Request parameters for dcimDeviceBaysBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBaysBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysBulkPartialUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysBulkUpdateRequest
 */
export interface DcimApiDcimDeviceBaysBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysBulkUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysCreateRequest
 */
export interface DcimApiDcimDeviceBaysCreateRequest {
    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysCreate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysDeleteRequest
 */
export interface DcimApiDcimDeviceBaysDeleteRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBaysList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysListRequest
 */
export interface DcimApiDcimDeviceBaysListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceBaysPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysPartialUpdateRequest
 */
export interface DcimApiDcimDeviceBaysPartialUpdateRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysPartialUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceBaysRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysReadRequest
 */
export interface DcimApiDcimDeviceBaysReadRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceBaysUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceBaysUpdateRequest
 */
export interface DcimApiDcimDeviceBaysUpdateRequest {
    /**
     * A unique integer value identifying this device bay.
     * @type {number}
     * @memberof DcimApiDcimDeviceBaysUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceBay}
     * @memberof DcimApiDcimDeviceBaysUpdate
     */
    readonly data: WritableDeviceBay
}

/**
 * Request parameters for dcimDeviceRolesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesBulkPartialUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceRolesBulkUpdateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesBulkUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesCreateRequest
 */
export interface DcimApiDcimDeviceRolesCreateRequest {
    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesCreate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesDeleteRequest
 */
export interface DcimApiDcimDeviceRolesDeleteRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceRolesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesListRequest
 */
export interface DcimApiDcimDeviceRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly vmRole?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly colorNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceRolesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesPartialUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceRolesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesReadRequest
 */
export interface DcimApiDcimDeviceRolesReadRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceRolesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceRolesUpdateRequest
 */
export interface DcimApiDcimDeviceRolesUpdateRequest {
    /**
     * A unique integer value identifying this device role.
     * @type {number}
     * @memberof DcimApiDcimDeviceRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {DeviceRole}
     * @memberof DcimApiDcimDeviceRolesUpdate
     */
    readonly data: DeviceRole
}

/**
 * Request parameters for dcimDeviceTypesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDeviceTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesBulkPartialUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesBulkUpdateRequest
 */
export interface DcimApiDcimDeviceTypesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesBulkUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesCreateRequest
 */
export interface DcimApiDcimDeviceTypesCreateRequest {
    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesCreate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesDeleteRequest
 */
export interface DcimApiDcimDeviceTypesDeleteRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceTypesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesListRequest
 */
export interface DcimApiDcimDeviceTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly model?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumber?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeight?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly isFullDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly subdeviceRole?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly consolePorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly consoleServerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly powerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly powerOutlets?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly interfaces?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly passThroughPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly deviceBays?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly modelNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly partNumberNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly uHeightGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly subdeviceRoleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly manufacturerN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDeviceTypesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesPartialUpdateRequest
 */
export interface DcimApiDcimDeviceTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesPartialUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDeviceTypesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesReadRequest
 */
export interface DcimApiDcimDeviceTypesReadRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDeviceTypesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDeviceTypesUpdateRequest
 */
export interface DcimApiDcimDeviceTypesUpdateRequest {
    /**
     * A unique integer value identifying this device type.
     * @type {number}
     * @memberof DcimApiDcimDeviceTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceType}
     * @memberof DcimApiDcimDeviceTypesUpdate
     */
    readonly data: WritableDeviceType
}

/**
 * Request parameters for dcimDevicesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesBulkPartialUpdateRequest
 */
export interface DcimApiDcimDevicesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesBulkPartialUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesBulkUpdateRequest
 */
export interface DcimApiDcimDevicesBulkUpdateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesBulkUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesCreateRequest
 */
export interface DcimApiDcimDevicesCreateRequest {
    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesCreate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesDeleteRequest
 */
export interface DcimApiDcimDevicesDeleteRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimDevicesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesListRequest
 */
export interface DcimApiDcimDevicesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly face?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly position?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPosition?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriority?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly localContextData?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platform?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly model?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly isFullDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly hasPrimaryIp?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisMember?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly consolePorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly consoleServerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly powerPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly powerOutlets?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly interfaces?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly passThroughPorts?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceBays?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly faceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly positionGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPositionGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly vcPriorityGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly manufacturerN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly deviceTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly platformN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly modelN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly virtualChassisIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimDevicesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimDevicesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimDevicesNapalm operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesNapalmRequest
 */
export interface DcimApiDcimDevicesNapalmRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesNapalm
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimDevicesNapalm
     */
    readonly method: string
}

/**
 * Request parameters for dcimDevicesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesPartialUpdateRequest
 */
export interface DcimApiDcimDevicesPartialUpdateRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesPartialUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimDevicesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesReadRequest
 */
export interface DcimApiDcimDevicesReadRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimDevicesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimDevicesUpdateRequest
 */
export interface DcimApiDcimDevicesUpdateRequest {
    /**
     * A unique integer value identifying this device.
     * @type {number}
     * @memberof DcimApiDcimDevicesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableDeviceWithConfigContext}
     * @memberof DcimApiDcimDevicesUpdate
     */
    readonly data: WritableDeviceWithConfigContext
}

/**
 * Request parameters for dcimFrontPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesBulkUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesCreateRequest
 */
export interface DcimApiDcimFrontPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesCreate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesDeleteRequest
 */
export interface DcimApiDcimFrontPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesListRequest
 */
export interface DcimApiDcimFrontPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimFrontPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesPartialUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesReadRequest
 */
export interface DcimApiDcimFrontPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortTemplatesUpdateRequest
 */
export interface DcimApiDcimFrontPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this front port template.
     * @type {number}
     * @memberof DcimApiDcimFrontPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPortTemplate}
     * @memberof DcimApiDcimFrontPortTemplatesUpdate
     */
    readonly data: WritableFrontPortTemplate
}

/**
 * Request parameters for dcimFrontPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsBulkPartialUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsBulkUpdateRequest
 */
export interface DcimApiDcimFrontPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsBulkUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsCreateRequest
 */
export interface DcimApiDcimFrontPortsCreateRequest {
    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsCreate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsDeleteRequest
 */
export interface DcimApiDcimFrontPortsDeleteRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsListRequest
 */
export interface DcimApiDcimFrontPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimFrontPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsPartialUpdateRequest
 */
export interface DcimApiDcimFrontPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsPartialUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimFrontPortsPaths operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsPathsRequest
 */
export interface DcimApiDcimFrontPortsPathsRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsPaths
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsReadRequest
 */
export interface DcimApiDcimFrontPortsReadRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimFrontPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimFrontPortsUpdateRequest
 */
export interface DcimApiDcimFrontPortsUpdateRequest {
    /**
     * A unique integer value identifying this front port.
     * @type {number}
     * @memberof DcimApiDcimFrontPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableFrontPort}
     * @memberof DcimApiDcimFrontPortsUpdate
     */
    readonly data: WritableFrontPort
}

/**
 * Request parameters for dcimInterfaceConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceConnectionsListRequest
 */
export interface DcimApiDcimInterfaceConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly device?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfaceConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfaceTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesBulkPartialUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesBulkUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesCreateRequest
 */
export interface DcimApiDcimInterfaceTemplatesCreateRequest {
    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesCreate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesDeleteRequest
 */
export interface DcimApiDcimInterfaceTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfaceTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesListRequest
 */
export interface DcimApiDcimInterfaceTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly mgmtOnly?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfaceTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesPartialUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfaceTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesReadRequest
 */
export interface DcimApiDcimInterfaceTemplatesReadRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfaceTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfaceTemplatesUpdateRequest
 */
export interface DcimApiDcimInterfaceTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this interface template.
     * @type {number}
     * @memberof DcimApiDcimInterfaceTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterfaceTemplate}
     * @memberof DcimApiDcimInterfaceTemplatesUpdate
     */
    readonly data: WritableInterfaceTemplate
}

/**
 * Request parameters for dcimInterfacesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesBulkPartialUpdateRequest
 */
export interface DcimApiDcimInterfacesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesBulkPartialUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesBulkUpdateRequest
 */
export interface DcimApiDcimInterfacesBulkUpdateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesBulkUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesCreateRequest
 */
export interface DcimApiDcimInterfacesCreateRequest {
    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesCreate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesDeleteRequest
 */
export interface DcimApiDcimInterfacesDeleteRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesListRequest
 */
export interface DcimApiDcimInterfacesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtu?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mgmtOnly?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mode?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly kind?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly lagId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly vlanId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly vlan?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly mtuGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly modeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly lagIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly macAddressNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInterfacesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInterfacesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesPartialUpdateRequest
 */
export interface DcimApiDcimInterfacesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesPartialUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInterfacesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesReadRequest
 */
export interface DcimApiDcimInterfacesReadRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesTraceRequest
 */
export interface DcimApiDcimInterfacesTraceRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimInterfacesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInterfacesUpdateRequest
 */
export interface DcimApiDcimInterfacesUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof DcimApiDcimInterfacesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInterface}
     * @memberof DcimApiDcimInterfacesUpdate
     */
    readonly data: WritableInterface
}

/**
 * Request parameters for dcimInventoryItemsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsBulkPartialUpdateRequest
 */
export interface DcimApiDcimInventoryItemsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsBulkPartialUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsBulkUpdateRequest
 */
export interface DcimApiDcimInventoryItemsBulkUpdateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsBulkUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsCreateRequest
 */
export interface DcimApiDcimInventoryItemsCreateRequest {
    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsCreate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsDeleteRequest
 */
export interface DcimApiDcimInventoryItemsDeleteRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimInventoryItemsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsListRequest
 */
export interface DcimApiDcimInventoryItemsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly discovered?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly partIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly manufacturerN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimInventoryItemsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsPartialUpdateRequest
 */
export interface DcimApiDcimInventoryItemsPartialUpdateRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsPartialUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimInventoryItemsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsReadRequest
 */
export interface DcimApiDcimInventoryItemsReadRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimInventoryItemsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimInventoryItemsUpdateRequest
 */
export interface DcimApiDcimInventoryItemsUpdateRequest {
    /**
     * A unique integer value identifying this inventory item.
     * @type {number}
     * @memberof DcimApiDcimInventoryItemsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableInventoryItem}
     * @memberof DcimApiDcimInventoryItemsUpdate
     */
    readonly data: WritableInventoryItem
}

/**
 * Request parameters for dcimManufacturersBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersBulkPartialUpdateRequest
 */
export interface DcimApiDcimManufacturersBulkPartialUpdateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersBulkPartialUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersBulkUpdateRequest
 */
export interface DcimApiDcimManufacturersBulkUpdateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersBulkUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersCreateRequest
 */
export interface DcimApiDcimManufacturersCreateRequest {
    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersCreate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersDeleteRequest
 */
export interface DcimApiDcimManufacturersDeleteRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimManufacturersList operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersListRequest
 */
export interface DcimApiDcimManufacturersListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimManufacturersList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimManufacturersPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersPartialUpdateRequest
 */
export interface DcimApiDcimManufacturersPartialUpdateRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersPartialUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimManufacturersRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersReadRequest
 */
export interface DcimApiDcimManufacturersReadRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimManufacturersUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimManufacturersUpdateRequest
 */
export interface DcimApiDcimManufacturersUpdateRequest {
    /**
     * A unique integer value identifying this manufacturer.
     * @type {number}
     * @memberof DcimApiDcimManufacturersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Manufacturer}
     * @memberof DcimApiDcimManufacturersUpdate
     */
    readonly data: Manufacturer
}

/**
 * Request parameters for dcimPlatformsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPlatformsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsBulkPartialUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsBulkUpdateRequest
 */
export interface DcimApiDcimPlatformsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsBulkUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsCreateRequest
 */
export interface DcimApiDcimPlatformsCreateRequest {
    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsCreate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsDeleteRequest
 */
export interface DcimApiDcimPlatformsDeleteRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPlatformsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsListRequest
 */
export interface DcimApiDcimPlatformsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriver?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturer?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly napalmDriverNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly manufacturerN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPlatformsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPlatformsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsPartialUpdateRequest
 */
export interface DcimApiDcimPlatformsPartialUpdateRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsPartialUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPlatformsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsReadRequest
 */
export interface DcimApiDcimPlatformsReadRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPlatformsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPlatformsUpdateRequest
 */
export interface DcimApiDcimPlatformsUpdateRequest {
    /**
     * A unique integer value identifying this platform.
     * @type {number}
     * @memberof DcimApiDcimPlatformsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePlatform}
     * @memberof DcimApiDcimPlatformsUpdate
     */
    readonly data: WritablePlatform
}

/**
 * Request parameters for dcimPowerConnectionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerConnectionsListRequest
 */
export interface DcimApiDcimPowerConnectionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly nameNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerConnectionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerFeedsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerFeedsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsBulkPartialUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsBulkUpdateRequest
 */
export interface DcimApiDcimPowerFeedsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsBulkUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsCreateRequest
 */
export interface DcimApiDcimPowerFeedsCreateRequest {
    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsCreate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsDeleteRequest
 */
export interface DcimApiDcimPowerFeedsDeleteRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsListRequest
 */
export interface DcimApiDcimPowerFeedsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly supply?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly phase?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltage?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperage?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilization?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly powerPanelId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly supplyN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly phaseN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly voltageGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly amperageGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly maxUtilizationGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly powerPanelIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerFeedsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsPartialUpdateRequest
 */
export interface DcimApiDcimPowerFeedsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsPartialUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerFeedsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsReadRequest
 */
export interface DcimApiDcimPowerFeedsReadRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsTraceRequest
 */
export interface DcimApiDcimPowerFeedsTraceRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerFeedsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerFeedsUpdateRequest
 */
export interface DcimApiDcimPowerFeedsUpdateRequest {
    /**
     * A unique integer value identifying this power feed.
     * @type {number}
     * @memberof DcimApiDcimPowerFeedsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerFeed}
     * @memberof DcimApiDcimPowerFeedsUpdate
     */
    readonly data: WritablePowerFeed
}

/**
 * Request parameters for dcimPowerOutletTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesBulkPartialUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesBulkUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesCreateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesCreateRequest {
    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesCreate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesDeleteRequest
 */
export interface DcimApiDcimPowerOutletTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesListRequest
 */
export interface DcimApiDcimPowerOutletTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly feedLeg?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly feedLegN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesPartialUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesReadRequest
 */
export interface DcimApiDcimPowerOutletTemplatesReadRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletTemplatesUpdateRequest
 */
export interface DcimApiDcimPowerOutletTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this power outlet template.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutletTemplate}
     * @memberof DcimApiDcimPowerOutletTemplatesUpdate
     */
    readonly data: WritablePowerOutletTemplate
}

/**
 * Request parameters for dcimPowerOutletsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsBulkPartialUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsBulkUpdateRequest
 */
export interface DcimApiDcimPowerOutletsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsBulkUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsCreateRequest
 */
export interface DcimApiDcimPowerOutletsCreateRequest {
    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsCreate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsDeleteRequest
 */
export interface DcimApiDcimPowerOutletsDeleteRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsListRequest
 */
export interface DcimApiDcimPowerOutletsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly feedLeg?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly feedLegN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerOutletsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsPartialUpdateRequest
 */
export interface DcimApiDcimPowerOutletsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsPartialUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerOutletsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsReadRequest
 */
export interface DcimApiDcimPowerOutletsReadRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsTraceRequest
 */
export interface DcimApiDcimPowerOutletsTraceRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerOutletsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerOutletsUpdateRequest
 */
export interface DcimApiDcimPowerOutletsUpdateRequest {
    /**
     * A unique integer value identifying this power outlet.
     * @type {number}
     * @memberof DcimApiDcimPowerOutletsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerOutlet}
     * @memberof DcimApiDcimPowerOutletsUpdate
     */
    readonly data: WritablePowerOutlet
}

/**
 * Request parameters for dcimPowerPanelsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPanelsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsBulkPartialUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsBulkUpdateRequest
 */
export interface DcimApiDcimPowerPanelsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsBulkUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsCreateRequest
 */
export interface DcimApiDcimPowerPanelsCreateRequest {
    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsCreate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsDeleteRequest
 */
export interface DcimApiDcimPowerPanelsDeleteRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPanelsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsListRequest
 */
export interface DcimApiDcimPowerPanelsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly rackGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly rackGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPanelsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsPartialUpdateRequest
 */
export interface DcimApiDcimPowerPanelsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsPartialUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPanelsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsReadRequest
 */
export interface DcimApiDcimPowerPanelsReadRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPanelsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPanelsUpdateRequest
 */
export interface DcimApiDcimPowerPanelsUpdateRequest {
    /**
     * A unique integer value identifying this power panel.
     * @type {number}
     * @memberof DcimApiDcimPowerPanelsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPanel}
     * @memberof DcimApiDcimPowerPanelsUpdate
     */
    readonly data: WritablePowerPanel
}

/**
 * Request parameters for dcimPowerPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesBulkPartialUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesBulkUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesCreateRequest
 */
export interface DcimApiDcimPowerPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesCreate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesDeleteRequest
 */
export interface DcimApiDcimPowerPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesListRequest
 */
export interface DcimApiDcimPowerPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly maximumDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly allocatedDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesPartialUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesReadRequest
 */
export interface DcimApiDcimPowerPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortTemplatesUpdateRequest
 */
export interface DcimApiDcimPowerPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this power port template.
     * @type {number}
     * @memberof DcimApiDcimPowerPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPortTemplate}
     * @memberof DcimApiDcimPowerPortTemplatesUpdate
     */
    readonly data: WritablePowerPortTemplate
}

/**
 * Request parameters for dcimPowerPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsBulkPartialUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsBulkUpdateRequest
 */
export interface DcimApiDcimPowerPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsBulkUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsCreateRequest
 */
export interface DcimApiDcimPowerPortsCreateRequest {
    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsCreate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsDeleteRequest
 */
export interface DcimApiDcimPowerPortsDeleteRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsListRequest
 */
export interface DcimApiDcimPowerPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDraw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly connected?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly maximumDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly allocatedDrawGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly tagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly typeN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimPowerPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsPartialUpdateRequest
 */
export interface DcimApiDcimPowerPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsPartialUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimPowerPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsReadRequest
 */
export interface DcimApiDcimPowerPortsReadRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsTrace operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsTraceRequest
 */
export interface DcimApiDcimPowerPortsTraceRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsTrace
     */
    readonly id: number
}

/**
 * Request parameters for dcimPowerPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimPowerPortsUpdateRequest
 */
export interface DcimApiDcimPowerPortsUpdateRequest {
    /**
     * A unique integer value identifying this power port.
     * @type {number}
     * @memberof DcimApiDcimPowerPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePowerPort}
     * @memberof DcimApiDcimPowerPortsUpdate
     */
    readonly data: WritablePowerPort
}

/**
 * Request parameters for dcimRackGroupsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsBulkPartialUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsBulkUpdateRequest
 */
export interface DcimApiDcimRackGroupsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsBulkUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsCreateRequest
 */
export interface DcimApiDcimRackGroupsCreateRequest {
    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsCreate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsDeleteRequest
 */
export interface DcimApiDcimRackGroupsDeleteRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackGroupsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsListRequest
 */
export interface DcimApiDcimRackGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly parentN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackGroupsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsPartialUpdateRequest
 */
export interface DcimApiDcimRackGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsPartialUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackGroupsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsReadRequest
 */
export interface DcimApiDcimRackGroupsReadRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackGroupsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackGroupsUpdateRequest
 */
export interface DcimApiDcimRackGroupsUpdateRequest {
    /**
     * A unique integer value identifying this rack group.
     * @type {number}
     * @memberof DcimApiDcimRackGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackGroup}
     * @memberof DcimApiDcimRackGroupsUpdate
     */
    readonly data: WritableRackGroup
}

/**
 * Request parameters for dcimRackReservationsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackReservationsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsBulkPartialUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsBulkUpdateRequest
 */
export interface DcimApiDcimRackReservationsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsBulkUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsCreateRequest
 */
export interface DcimApiDcimRackReservationsCreateRequest {
    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsCreate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsDeleteRequest
 */
export interface DcimApiDcimRackReservationsDeleteRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackReservationsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsListRequest
 */
export interface DcimApiDcimRackReservationsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly rackId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly user?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly createdGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly rackIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly userN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackReservationsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsPartialUpdateRequest
 */
export interface DcimApiDcimRackReservationsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsPartialUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackReservationsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsReadRequest
 */
export interface DcimApiDcimRackReservationsReadRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackReservationsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackReservationsUpdateRequest
 */
export interface DcimApiDcimRackReservationsUpdateRequest {
    /**
     * A unique integer value identifying this rack reservation.
     * @type {number}
     * @memberof DcimApiDcimRackReservationsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRackReservation}
     * @memberof DcimApiDcimRackReservationsUpdate
     */
    readonly data: WritableRackReservation
}

/**
 * Request parameters for dcimRackRolesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesBulkPartialUpdateRequest
 */
export interface DcimApiDcimRackRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesBulkPartialUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesBulkUpdateRequest
 */
export interface DcimApiDcimRackRolesBulkUpdateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesBulkUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesCreateRequest
 */
export interface DcimApiDcimRackRolesCreateRequest {
    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesCreate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesDeleteRequest
 */
export interface DcimApiDcimRackRolesDeleteRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackRolesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesListRequest
 */
export interface DcimApiDcimRackRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly color?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly colorNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRackRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRackRolesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesPartialUpdateRequest
 */
export interface DcimApiDcimRackRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesPartialUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRackRolesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesReadRequest
 */
export interface DcimApiDcimRackRolesReadRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRackRolesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRackRolesUpdateRequest
 */
export interface DcimApiDcimRackRolesUpdateRequest {
    /**
     * A unique integer value identifying this rack role.
     * @type {number}
     * @memberof DcimApiDcimRackRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RackRole}
     * @memberof DcimApiDcimRackRolesUpdate
     */
    readonly data: RackRole
}

/**
 * Request parameters for dcimRacksBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksBulkPartialUpdateRequest
 */
export interface DcimApiDcimRacksBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksBulkPartialUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksBulkUpdateRequest
 */
export interface DcimApiDcimRacksBulkUpdateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksBulkUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksCreateRequest
 */
export interface DcimApiDcimRacksCreateRequest {
    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksCreate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksDeleteRequest
 */
export interface DcimApiDcimRacksDeleteRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRacksElevationRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksElevationReadRequest
 */
export interface DcimApiDcimRacksElevationReadRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly id: number

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly q?: string

    /**
     * 
     * @type {'front' | 'rear'}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly face?: 'front' | 'rear'

    /**
     * 
     * @type {'json' | 'svg'}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly render?: 'json' | 'svg'

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly unitWidth?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly unitHeight?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly legendWidth?: number

    /**
     * 
     * @type {number}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly exclude?: number

    /**
     * 
     * @type {boolean}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly expandDevices?: boolean

    /**
     * 
     * @type {boolean}
     * @memberof DcimApiDcimRacksElevationRead
     */
    readonly includeImages?: boolean
}

/**
 * Request parameters for dcimRacksList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksListRequest
 */
export interface DcimApiDcimRacksListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly width?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeight?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly descUnits?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepth?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerUnit?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly serial?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly facilityIdNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly assetTagNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly widthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly uHeightGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerWidthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerDepthGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly outerUnitN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRacksList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRacksList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRacksList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRacksPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksPartialUpdateRequest
 */
export interface DcimApiDcimRacksPartialUpdateRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksPartialUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRacksRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksReadRequest
 */
export interface DcimApiDcimRacksReadRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRacksUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRacksUpdateRequest
 */
export interface DcimApiDcimRacksUpdateRequest {
    /**
     * A unique integer value identifying this rack.
     * @type {number}
     * @memberof DcimApiDcimRacksUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRack}
     * @memberof DcimApiDcimRacksUpdate
     */
    readonly data: WritableRack
}

/**
 * Request parameters for dcimRearPortTemplatesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesBulkPartialUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesBulkUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesBulkUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesCreateRequest
 */
export interface DcimApiDcimRearPortTemplatesCreateRequest {
    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesCreate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesDeleteRequest
 */
export interface DcimApiDcimRearPortTemplatesDeleteRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortTemplatesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesListRequest
 */
export interface DcimApiDcimRearPortTemplatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positions?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly devicetypeId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly positionsGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly devicetypeIdN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRearPortTemplatesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesPartialUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesPartialUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortTemplatesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesReadRequest
 */
export interface DcimApiDcimRearPortTemplatesReadRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortTemplatesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortTemplatesUpdateRequest
 */
export interface DcimApiDcimRearPortTemplatesUpdateRequest {
    /**
     * A unique integer value identifying this rear port template.
     * @type {number}
     * @memberof DcimApiDcimRearPortTemplatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPortTemplate}
     * @memberof DcimApiDcimRearPortTemplatesUpdate
     */
    readonly data: WritableRearPortTemplate
}

/**
 * Request parameters for dcimRearPortsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRearPortsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsBulkPartialUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsBulkUpdateRequest
 */
export interface DcimApiDcimRearPortsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsBulkUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsCreateRequest
 */
export interface DcimApiDcimRearPortsCreateRequest {
    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsCreate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsDeleteRequest
 */
export interface DcimApiDcimRearPortsDeleteRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsListRequest
 */
export interface DcimApiDcimRearPortsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positions?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly cabled?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly positionsGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRearPortsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRearPortsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsPartialUpdateRequest
 */
export interface DcimApiDcimRearPortsPartialUpdateRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsPartialUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRearPortsPaths operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsPathsRequest
 */
export interface DcimApiDcimRearPortsPathsRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsPaths
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsReadRequest
 */
export interface DcimApiDcimRearPortsReadRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRearPortsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRearPortsUpdateRequest
 */
export interface DcimApiDcimRearPortsUpdateRequest {
    /**
     * A unique integer value identifying this rear port.
     * @type {number}
     * @memberof DcimApiDcimRearPortsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRearPort}
     * @memberof DcimApiDcimRearPortsUpdate
     */
    readonly data: WritableRearPort
}

/**
 * Request parameters for dcimRegionsBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsBulkPartialUpdateRequest
 */
export interface DcimApiDcimRegionsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsBulkPartialUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsBulkUpdateRequest
 */
export interface DcimApiDcimRegionsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsBulkUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsCreateRequest
 */
export interface DcimApiDcimRegionsCreateRequest {
    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsCreate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsDeleteRequest
 */
export interface DcimApiDcimRegionsDeleteRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimRegionsList operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsListRequest
 */
export interface DcimApiDcimRegionsListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimRegionsList
     */
    readonly parentN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimRegionsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimRegionsList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimRegionsPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsPartialUpdateRequest
 */
export interface DcimApiDcimRegionsPartialUpdateRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsPartialUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimRegionsRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsReadRequest
 */
export interface DcimApiDcimRegionsReadRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimRegionsUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimRegionsUpdateRequest
 */
export interface DcimApiDcimRegionsUpdateRequest {
    /**
     * A unique integer value identifying this region.
     * @type {number}
     * @memberof DcimApiDcimRegionsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRegion}
     * @memberof DcimApiDcimRegionsUpdate
     */
    readonly data: WritableRegion
}

/**
 * Request parameters for dcimSitesBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesBulkPartialUpdateRequest
 */
export interface DcimApiDcimSitesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesBulkPartialUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesBulkUpdateRequest
 */
export interface DcimApiDcimSitesBulkUpdateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesBulkUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesCreateRequest
 */
export interface DcimApiDcimSitesCreateRequest {
    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesCreate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesDeleteRequest
 */
export interface DcimApiDcimSitesDeleteRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimSitesList operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesListRequest
 */
export interface DcimApiDcimSitesListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facility?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asn?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitude?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitude?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactName?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhone?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmail?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly facilityNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly asnGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly latitudeGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly longitudeGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactPhoneNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly contactEmailNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimSitesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimSitesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimSitesList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimSitesPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesPartialUpdateRequest
 */
export interface DcimApiDcimSitesPartialUpdateRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesPartialUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimSitesRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesReadRequest
 */
export interface DcimApiDcimSitesReadRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimSitesUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimSitesUpdateRequest
 */
export interface DcimApiDcimSitesUpdateRequest {
    /**
     * A unique integer value identifying this site.
     * @type {number}
     * @memberof DcimApiDcimSitesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableSite}
     * @memberof DcimApiDcimSitesUpdate
     */
    readonly data: WritableSite
}

/**
 * Request parameters for dcimVirtualChassisBulkPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisBulkPartialUpdateRequest
 */
export interface DcimApiDcimVirtualChassisBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisBulkPartialUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisBulkUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisBulkUpdateRequest
 */
export interface DcimApiDcimVirtualChassisBulkUpdateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisBulkUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisCreate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisCreateRequest
 */
export interface DcimApiDcimVirtualChassisCreateRequest {
    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisCreate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisDelete operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisDeleteRequest
 */
export interface DcimApiDcimVirtualChassisDeleteRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisDelete
     */
    readonly id: number
}

/**
 * Request parameters for dcimVirtualChassisList operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisListRequest
 */
export interface DcimApiDcimVirtualChassisListRequest {
    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domain?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIc?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNic?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNiew?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIsw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNisw?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainIe?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly domainNie?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisList
     */
    readonly offset?: number
}

/**
 * Request parameters for dcimVirtualChassisPartialUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisPartialUpdateRequest
 */
export interface DcimApiDcimVirtualChassisPartialUpdateRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisPartialUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * Request parameters for dcimVirtualChassisRead operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisReadRequest
 */
export interface DcimApiDcimVirtualChassisReadRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisRead
     */
    readonly id: number
}

/**
 * Request parameters for dcimVirtualChassisUpdate operation in DcimApi.
 * @export
 * @interface DcimApiDcimVirtualChassisUpdateRequest
 */
export interface DcimApiDcimVirtualChassisUpdateRequest {
    /**
     * A unique integer value identifying this virtual chassis.
     * @type {number}
     * @memberof DcimApiDcimVirtualChassisUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualChassis}
     * @memberof DcimApiDcimVirtualChassisUpdate
     */
    readonly data: WritableVirtualChassis
}

/**
 * DcimApi - object-oriented interface
 * @export
 * @class DcimApi
 * @extends {BaseAPI}
 */
export class DcimApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkPartialUpdate(requestParameters: DcimApiDcimCablesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesBulkUpdate(requestParameters: DcimApiDcimCablesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesCreate(requestParameters: DcimApiDcimCablesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesDelete(requestParameters: DcimApiDcimCablesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesList(requestParameters: DcimApiDcimCablesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesList(requestParameters.id, requestParameters.label, requestParameters.length, requestParameters.lengthUnit, requestParameters.q, requestParameters.type, requestParameters.status, requestParameters.color, requestParameters.deviceId, requestParameters.device, requestParameters.rackId, requestParameters.rack, requestParameters.siteId, requestParameters.site, requestParameters.tenantId, requestParameters.tenant, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.labelN, requestParameters.labelIc, requestParameters.labelNic, requestParameters.labelIew, requestParameters.labelNiew, requestParameters.labelIsw, requestParameters.labelNisw, requestParameters.labelIe, requestParameters.labelNie, requestParameters.lengthN, requestParameters.lengthLte, requestParameters.lengthLt, requestParameters.lengthGte, requestParameters.lengthGt, requestParameters.lengthUnitN, requestParameters.typeN, requestParameters.statusN, requestParameters.colorN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesPartialUpdate(requestParameters: DcimApiDcimCablesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesRead(requestParameters: DcimApiDcimCablesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimCablesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimCablesUpdate(requestParameters: DcimApiDcimCablesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimCablesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint allows a user to determine what device (if any) is connected to a given peer device and peer interface. This is useful in a situation where a device boots with no configuration, but can detect its neighbors via a protocol such as LLDP. Two query parameters must be included in the request:  * `peer_device`: The name of the peer device * `peer_interface`: The name of the peer interface
     * @param {DcimApiDcimConnectedDeviceListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConnectedDeviceList(requestParameters: DcimApiDcimConnectedDeviceListRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConnectedDeviceList(requestParameters.peerDevice, requestParameters.peerInterface, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleConnectionsList(requestParameters: DcimApiDcimConsoleConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleConnectionsList(requestParameters.name, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimConsolePortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesBulkUpdate(requestParameters: DcimApiDcimConsolePortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesCreate(requestParameters: DcimApiDcimConsolePortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesDelete(requestParameters: DcimApiDcimConsolePortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesList(requestParameters: DcimApiDcimConsolePortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesPartialUpdate(requestParameters: DcimApiDcimConsolePortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesRead(requestParameters: DcimApiDcimConsolePortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortTemplatesUpdate(requestParameters: DcimApiDcimConsolePortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkPartialUpdate(requestParameters: DcimApiDcimConsolePortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsBulkUpdate(requestParameters: DcimApiDcimConsolePortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsCreate(requestParameters: DcimApiDcimConsolePortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsDelete(requestParameters: DcimApiDcimConsolePortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsList(requestParameters: DcimApiDcimConsolePortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsPartialUpdate(requestParameters: DcimApiDcimConsolePortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsRead(requestParameters: DcimApiDcimConsolePortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimConsolePortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsTrace(requestParameters: DcimApiDcimConsolePortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsolePortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsolePortsUpdate(requestParameters: DcimApiDcimConsolePortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsolePortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesBulkUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesCreate(requestParameters: DcimApiDcimConsoleServerPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesDelete(requestParameters: DcimApiDcimConsoleServerPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesList(requestParameters: DcimApiDcimConsoleServerPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesRead(requestParameters: DcimApiDcimConsoleServerPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortTemplatesUpdate(requestParameters: DcimApiDcimConsoleServerPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsBulkUpdate(requestParameters: DcimApiDcimConsoleServerPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsCreate(requestParameters: DcimApiDcimConsoleServerPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsDelete(requestParameters: DcimApiDcimConsoleServerPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsList(requestParameters: DcimApiDcimConsoleServerPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsPartialUpdate(requestParameters: DcimApiDcimConsoleServerPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsRead(requestParameters: DcimApiDcimConsoleServerPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimConsoleServerPortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsTrace(requestParameters: DcimApiDcimConsoleServerPortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimConsoleServerPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimConsoleServerPortsUpdate(requestParameters: DcimApiDcimConsoleServerPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimConsoleServerPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesBulkUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesCreate(requestParameters: DcimApiDcimDeviceBayTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesDelete(requestParameters: DcimApiDcimDeviceBayTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesList(requestParameters: DcimApiDcimDeviceBayTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesPartialUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesRead(requestParameters: DcimApiDcimDeviceBayTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBayTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBayTemplatesUpdate(requestParameters: DcimApiDcimDeviceBayTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBayTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkPartialUpdate(requestParameters: DcimApiDcimDeviceBaysBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysBulkUpdate(requestParameters: DcimApiDcimDeviceBaysBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysCreate(requestParameters: DcimApiDcimDeviceBaysCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysDelete(requestParameters: DcimApiDcimDeviceBaysDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysList(requestParameters: DcimApiDcimDeviceBaysListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysList(requestParameters.id, requestParameters.name, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysPartialUpdate(requestParameters: DcimApiDcimDeviceBaysPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysRead(requestParameters: DcimApiDcimDeviceBaysReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceBaysUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceBaysUpdate(requestParameters: DcimApiDcimDeviceBaysUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceBaysUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceRolesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesBulkUpdate(requestParameters: DcimApiDcimDeviceRolesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesCreate(requestParameters: DcimApiDcimDeviceRolesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesDelete(requestParameters: DcimApiDcimDeviceRolesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesList(requestParameters: DcimApiDcimDeviceRolesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.color, requestParameters.vmRole, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.colorN, requestParameters.colorIc, requestParameters.colorNic, requestParameters.colorIew, requestParameters.colorNiew, requestParameters.colorIsw, requestParameters.colorNisw, requestParameters.colorIe, requestParameters.colorNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesPartialUpdate(requestParameters: DcimApiDcimDeviceRolesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesRead(requestParameters: DcimApiDcimDeviceRolesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceRolesUpdate(requestParameters: DcimApiDcimDeviceRolesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkPartialUpdate(requestParameters: DcimApiDcimDeviceTypesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesBulkUpdate(requestParameters: DcimApiDcimDeviceTypesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesCreate(requestParameters: DcimApiDcimDeviceTypesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesDelete(requestParameters: DcimApiDcimDeviceTypesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesList(requestParameters: DcimApiDcimDeviceTypesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesList(requestParameters.id, requestParameters.model, requestParameters.slug, requestParameters.partNumber, requestParameters.uHeight, requestParameters.isFullDepth, requestParameters.subdeviceRole, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.consolePorts, requestParameters.consoleServerPorts, requestParameters.powerPorts, requestParameters.powerOutlets, requestParameters.interfaces, requestParameters.passThroughPorts, requestParameters.deviceBays, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.modelN, requestParameters.modelIc, requestParameters.modelNic, requestParameters.modelIew, requestParameters.modelNiew, requestParameters.modelIsw, requestParameters.modelNisw, requestParameters.modelIe, requestParameters.modelNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.partNumberN, requestParameters.partNumberIc, requestParameters.partNumberNic, requestParameters.partNumberIew, requestParameters.partNumberNiew, requestParameters.partNumberIsw, requestParameters.partNumberNisw, requestParameters.partNumberIe, requestParameters.partNumberNie, requestParameters.uHeightN, requestParameters.uHeightLte, requestParameters.uHeightLt, requestParameters.uHeightGte, requestParameters.uHeightGt, requestParameters.subdeviceRoleN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesPartialUpdate(requestParameters: DcimApiDcimDeviceTypesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesRead(requestParameters: DcimApiDcimDeviceTypesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDeviceTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDeviceTypesUpdate(requestParameters: DcimApiDcimDeviceTypesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDeviceTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkPartialUpdate(requestParameters: DcimApiDcimDevicesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesBulkUpdate(requestParameters: DcimApiDcimDevicesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesCreate(requestParameters: DcimApiDcimDevicesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesDelete(requestParameters: DcimApiDcimDevicesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesList(requestParameters: DcimApiDcimDevicesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesList(requestParameters.id, requestParameters.name, requestParameters.assetTag, requestParameters.face, requestParameters.position, requestParameters.vcPosition, requestParameters.vcPriority, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.localContextData, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.deviceTypeId, requestParameters.roleId, requestParameters.role, requestParameters.platformId, requestParameters.platform, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.rackGroupId, requestParameters.rackId, requestParameters.clusterId, requestParameters.model, requestParameters.status, requestParameters.isFullDepth, requestParameters.macAddress, requestParameters.serial, requestParameters.hasPrimaryIp, requestParameters.virtualChassisId, requestParameters.virtualChassisMember, requestParameters.consolePorts, requestParameters.consoleServerPorts, requestParameters.powerPorts, requestParameters.powerOutlets, requestParameters.interfaces, requestParameters.passThroughPorts, requestParameters.deviceBays, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.faceN, requestParameters.positionN, requestParameters.positionLte, requestParameters.positionLt, requestParameters.positionGte, requestParameters.positionGt, requestParameters.vcPositionN, requestParameters.vcPositionLte, requestParameters.vcPositionLt, requestParameters.vcPositionGte, requestParameters.vcPositionGt, requestParameters.vcPriorityN, requestParameters.vcPriorityLte, requestParameters.vcPriorityLt, requestParameters.vcPriorityGte, requestParameters.vcPriorityGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.deviceTypeIdN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.platformIdN, requestParameters.platformN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.rackGroupIdN, requestParameters.rackIdN, requestParameters.clusterIdN, requestParameters.modelN, requestParameters.statusN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.virtualChassisIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Execute a NAPALM method on a Device
     * @param {DcimApiDcimDevicesNapalmRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesNapalm(requestParameters: DcimApiDcimDevicesNapalmRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesNapalm(requestParameters.id, requestParameters.method, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesPartialUpdate(requestParameters: DcimApiDcimDevicesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesRead(requestParameters: DcimApiDcimDevicesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimDevicesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimDevicesUpdate(requestParameters: DcimApiDcimDevicesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimDevicesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimFrontPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesBulkUpdate(requestParameters: DcimApiDcimFrontPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesCreate(requestParameters: DcimApiDcimFrontPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesDelete(requestParameters: DcimApiDcimFrontPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesList(requestParameters: DcimApiDcimFrontPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesPartialUpdate(requestParameters: DcimApiDcimFrontPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesRead(requestParameters: DcimApiDcimFrontPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortTemplatesUpdate(requestParameters: DcimApiDcimFrontPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkPartialUpdate(requestParameters: DcimApiDcimFrontPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsBulkUpdate(requestParameters: DcimApiDcimFrontPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsCreate(requestParameters: DcimApiDcimFrontPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsDelete(requestParameters: DcimApiDcimFrontPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsList(requestParameters: DcimApiDcimFrontPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsPartialUpdate(requestParameters: DcimApiDcimFrontPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all CablePaths which traverse a given pass-through port.
     * @param {DcimApiDcimFrontPortsPathsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsPaths(requestParameters: DcimApiDcimFrontPortsPathsRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsPaths(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsRead(requestParameters: DcimApiDcimFrontPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimFrontPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimFrontPortsUpdate(requestParameters: DcimApiDcimFrontPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimFrontPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceConnectionsList(requestParameters: DcimApiDcimInterfaceConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceConnectionsList(requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimInterfaceTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesBulkUpdate(requestParameters: DcimApiDcimInterfaceTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesCreate(requestParameters: DcimApiDcimInterfaceTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesDelete(requestParameters: DcimApiDcimInterfaceTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesList(requestParameters: DcimApiDcimInterfaceTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.mgmtOnly, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesPartialUpdate(requestParameters: DcimApiDcimInterfaceTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesRead(requestParameters: DcimApiDcimInterfaceTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfaceTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfaceTemplatesUpdate(requestParameters: DcimApiDcimInterfaceTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfaceTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkPartialUpdate(requestParameters: DcimApiDcimInterfacesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesBulkUpdate(requestParameters: DcimApiDcimInterfacesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesCreate(requestParameters: DcimApiDcimInterfacesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesDelete(requestParameters: DcimApiDcimInterfacesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesList(requestParameters: DcimApiDcimInterfacesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.enabled, requestParameters.mtu, requestParameters.mgmtOnly, requestParameters.mode, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.kind, requestParameters.lagId, requestParameters.macAddress, requestParameters.vlanId, requestParameters.vlan, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.mtuN, requestParameters.mtuLte, requestParameters.mtuLt, requestParameters.mtuGte, requestParameters.mtuGt, requestParameters.modeN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tagN, requestParameters.lagIdN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesPartialUpdate(requestParameters: DcimApiDcimInterfacesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesRead(requestParameters: DcimApiDcimInterfacesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimInterfacesTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesTrace(requestParameters: DcimApiDcimInterfacesTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInterfacesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInterfacesUpdate(requestParameters: DcimApiDcimInterfacesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInterfacesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkPartialUpdate(requestParameters: DcimApiDcimInventoryItemsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsBulkUpdate(requestParameters: DcimApiDcimInventoryItemsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsCreate(requestParameters: DcimApiDcimInventoryItemsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsDelete(requestParameters: DcimApiDcimInventoryItemsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsList(requestParameters: DcimApiDcimInventoryItemsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsList(requestParameters.id, requestParameters.name, requestParameters.partId, requestParameters.assetTag, requestParameters.discovered, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.parentId, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.serial, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.partIdN, requestParameters.partIdIc, requestParameters.partIdNic, requestParameters.partIdIew, requestParameters.partIdNiew, requestParameters.partIdIsw, requestParameters.partIdNisw, requestParameters.partIdIe, requestParameters.partIdNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.parentIdN, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsPartialUpdate(requestParameters: DcimApiDcimInventoryItemsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsRead(requestParameters: DcimApiDcimInventoryItemsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimInventoryItemsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimInventoryItemsUpdate(requestParameters: DcimApiDcimInventoryItemsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimInventoryItemsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkPartialUpdate(requestParameters: DcimApiDcimManufacturersBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersBulkUpdate(requestParameters: DcimApiDcimManufacturersBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersCreate(requestParameters: DcimApiDcimManufacturersCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersDelete(requestParameters: DcimApiDcimManufacturersDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersList(requestParameters: DcimApiDcimManufacturersListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersPartialUpdate(requestParameters: DcimApiDcimManufacturersPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersRead(requestParameters: DcimApiDcimManufacturersReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimManufacturersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimManufacturersUpdate(requestParameters: DcimApiDcimManufacturersUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimManufacturersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkPartialUpdate(requestParameters: DcimApiDcimPlatformsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsBulkUpdate(requestParameters: DcimApiDcimPlatformsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsCreate(requestParameters: DcimApiDcimPlatformsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsDelete(requestParameters: DcimApiDcimPlatformsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsList(requestParameters: DcimApiDcimPlatformsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.napalmDriver, requestParameters.description, requestParameters.q, requestParameters.manufacturerId, requestParameters.manufacturer, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.napalmDriverN, requestParameters.napalmDriverIc, requestParameters.napalmDriverNic, requestParameters.napalmDriverIew, requestParameters.napalmDriverNiew, requestParameters.napalmDriverIsw, requestParameters.napalmDriverNisw, requestParameters.napalmDriverIe, requestParameters.napalmDriverNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.manufacturerIdN, requestParameters.manufacturerN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsPartialUpdate(requestParameters: DcimApiDcimPlatformsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsRead(requestParameters: DcimApiDcimPlatformsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPlatformsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPlatformsUpdate(requestParameters: DcimApiDcimPlatformsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPlatformsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerConnectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerConnectionsList(requestParameters: DcimApiDcimPowerConnectionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerConnectionsList(requestParameters.name, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkPartialUpdate(requestParameters: DcimApiDcimPowerFeedsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsBulkUpdate(requestParameters: DcimApiDcimPowerFeedsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsCreate(requestParameters: DcimApiDcimPowerFeedsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsDelete(requestParameters: DcimApiDcimPowerFeedsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsList(requestParameters: DcimApiDcimPowerFeedsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsList(requestParameters.id, requestParameters.name, requestParameters.status, requestParameters.type, requestParameters.supply, requestParameters.phase, requestParameters.voltage, requestParameters.amperage, requestParameters.maxUtilization, requestParameters.cabled, requestParameters.connected, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.powerPanelId, requestParameters.rackId, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.statusN, requestParameters.typeN, requestParameters.supplyN, requestParameters.phaseN, requestParameters.voltageN, requestParameters.voltageLte, requestParameters.voltageLt, requestParameters.voltageGte, requestParameters.voltageGt, requestParameters.amperageN, requestParameters.amperageLte, requestParameters.amperageLt, requestParameters.amperageGte, requestParameters.amperageGt, requestParameters.maxUtilizationN, requestParameters.maxUtilizationLte, requestParameters.maxUtilizationLt, requestParameters.maxUtilizationGte, requestParameters.maxUtilizationGt, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.powerPanelIdN, requestParameters.rackIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsPartialUpdate(requestParameters: DcimApiDcimPowerFeedsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsRead(requestParameters: DcimApiDcimPowerFeedsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerFeedsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsTrace(requestParameters: DcimApiDcimPowerFeedsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerFeedsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerFeedsUpdate(requestParameters: DcimApiDcimPowerFeedsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerFeedsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesBulkUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesCreate(requestParameters: DcimApiDcimPowerOutletTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesDelete(requestParameters: DcimApiDcimPowerOutletTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesList(requestParameters: DcimApiDcimPowerOutletTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.feedLeg, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.feedLegN, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesPartialUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesRead(requestParameters: DcimApiDcimPowerOutletTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletTemplatesUpdate(requestParameters: DcimApiDcimPowerOutletTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkPartialUpdate(requestParameters: DcimApiDcimPowerOutletsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsBulkUpdate(requestParameters: DcimApiDcimPowerOutletsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsCreate(requestParameters: DcimApiDcimPowerOutletsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsDelete(requestParameters: DcimApiDcimPowerOutletsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsList(requestParameters: DcimApiDcimPowerOutletsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsList(requestParameters.id, requestParameters.name, requestParameters.feedLeg, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.feedLegN, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsPartialUpdate(requestParameters: DcimApiDcimPowerOutletsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsRead(requestParameters: DcimApiDcimPowerOutletsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerOutletsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsTrace(requestParameters: DcimApiDcimPowerOutletsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerOutletsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerOutletsUpdate(requestParameters: DcimApiDcimPowerOutletsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerOutletsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkPartialUpdate(requestParameters: DcimApiDcimPowerPanelsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsBulkUpdate(requestParameters: DcimApiDcimPowerPanelsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsCreate(requestParameters: DcimApiDcimPowerPanelsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsDelete(requestParameters: DcimApiDcimPowerPanelsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsList(requestParameters: DcimApiDcimPowerPanelsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsList(requestParameters.id, requestParameters.name, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.rackGroupId, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.rackGroupIdN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsPartialUpdate(requestParameters: DcimApiDcimPowerPanelsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsRead(requestParameters: DcimApiDcimPowerPanelsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPanelsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPanelsUpdate(requestParameters: DcimApiDcimPowerPanelsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPanelsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimPowerPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesBulkUpdate(requestParameters: DcimApiDcimPowerPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesCreate(requestParameters: DcimApiDcimPowerPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesDelete(requestParameters: DcimApiDcimPowerPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesList(requestParameters: DcimApiDcimPowerPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.maximumDraw, requestParameters.allocatedDraw, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.maximumDrawN, requestParameters.maximumDrawLte, requestParameters.maximumDrawLt, requestParameters.maximumDrawGte, requestParameters.maximumDrawGt, requestParameters.allocatedDrawN, requestParameters.allocatedDrawLte, requestParameters.allocatedDrawLt, requestParameters.allocatedDrawGte, requestParameters.allocatedDrawGt, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesPartialUpdate(requestParameters: DcimApiDcimPowerPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesRead(requestParameters: DcimApiDcimPowerPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortTemplatesUpdate(requestParameters: DcimApiDcimPowerPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkPartialUpdate(requestParameters: DcimApiDcimPowerPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsBulkUpdate(requestParameters: DcimApiDcimPowerPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsCreate(requestParameters: DcimApiDcimPowerPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsDelete(requestParameters: DcimApiDcimPowerPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsList(requestParameters: DcimApiDcimPowerPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsList(requestParameters.id, requestParameters.name, requestParameters.maximumDraw, requestParameters.allocatedDraw, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.connected, requestParameters.type, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.maximumDrawN, requestParameters.maximumDrawLte, requestParameters.maximumDrawLt, requestParameters.maximumDrawGte, requestParameters.maximumDrawGt, requestParameters.allocatedDrawN, requestParameters.allocatedDrawLte, requestParameters.allocatedDrawLt, requestParameters.allocatedDrawGte, requestParameters.allocatedDrawGt, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.typeN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsPartialUpdate(requestParameters: DcimApiDcimPowerPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsRead(requestParameters: DcimApiDcimPowerPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trace a complete cable path and return each segment as a three-tuple of (termination, cable, termination).
     * @param {DcimApiDcimPowerPortsTraceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsTrace(requestParameters: DcimApiDcimPowerPortsTraceRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsTrace(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimPowerPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimPowerPortsUpdate(requestParameters: DcimApiDcimPowerPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimPowerPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkPartialUpdate(requestParameters: DcimApiDcimRackGroupsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsBulkUpdate(requestParameters: DcimApiDcimRackGroupsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsCreate(requestParameters: DcimApiDcimRackGroupsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsDelete(requestParameters: DcimApiDcimRackGroupsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsList(requestParameters: DcimApiDcimRackGroupsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.parentId, requestParameters.parent, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.parentIdN, requestParameters.parentN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsPartialUpdate(requestParameters: DcimApiDcimRackGroupsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsRead(requestParameters: DcimApiDcimRackGroupsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackGroupsUpdate(requestParameters: DcimApiDcimRackGroupsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkPartialUpdate(requestParameters: DcimApiDcimRackReservationsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsBulkUpdate(requestParameters: DcimApiDcimRackReservationsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsCreate(requestParameters: DcimApiDcimRackReservationsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsDelete(requestParameters: DcimApiDcimRackReservationsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsList(requestParameters: DcimApiDcimRackReservationsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsList(requestParameters.id, requestParameters.created, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.q, requestParameters.rackId, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.userId, requestParameters.user, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.createdN, requestParameters.createdLte, requestParameters.createdLt, requestParameters.createdGte, requestParameters.createdGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.rackIdN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.userIdN, requestParameters.userN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsPartialUpdate(requestParameters: DcimApiDcimRackReservationsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsRead(requestParameters: DcimApiDcimRackReservationsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackReservationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackReservationsUpdate(requestParameters: DcimApiDcimRackReservationsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackReservationsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkPartialUpdate(requestParameters: DcimApiDcimRackRolesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesBulkUpdate(requestParameters: DcimApiDcimRackRolesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesCreate(requestParameters: DcimApiDcimRackRolesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesDelete(requestParameters: DcimApiDcimRackRolesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesList(requestParameters: DcimApiDcimRackRolesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.color, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.colorN, requestParameters.colorIc, requestParameters.colorNic, requestParameters.colorIew, requestParameters.colorNiew, requestParameters.colorIsw, requestParameters.colorNisw, requestParameters.colorIe, requestParameters.colorNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesPartialUpdate(requestParameters: DcimApiDcimRackRolesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesRead(requestParameters: DcimApiDcimRackRolesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRackRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRackRolesUpdate(requestParameters: DcimApiDcimRackRolesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRackRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkPartialUpdate(requestParameters: DcimApiDcimRacksBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksBulkUpdate(requestParameters: DcimApiDcimRacksBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksCreate(requestParameters: DcimApiDcimRacksCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksDelete(requestParameters: DcimApiDcimRacksDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Rack elevation representing the list of rack units. Also supports rendering the elevation as an SVG.
     * @param {DcimApiDcimRacksElevationReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksElevationRead(requestParameters: DcimApiDcimRacksElevationReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksElevationRead(requestParameters.id, requestParameters.q, requestParameters.face, requestParameters.render, requestParameters.unitWidth, requestParameters.unitHeight, requestParameters.legendWidth, requestParameters.exclude, requestParameters.expandDevices, requestParameters.includeImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksList(requestParameters: DcimApiDcimRacksListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksList(requestParameters.id, requestParameters.name, requestParameters.facilityId, requestParameters.assetTag, requestParameters.type, requestParameters.width, requestParameters.uHeight, requestParameters.descUnits, requestParameters.outerWidth, requestParameters.outerDepth, requestParameters.outerUnit, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.status, requestParameters.roleId, requestParameters.role, requestParameters.serial, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.facilityIdN, requestParameters.facilityIdIc, requestParameters.facilityIdNic, requestParameters.facilityIdIew, requestParameters.facilityIdNiew, requestParameters.facilityIdIsw, requestParameters.facilityIdNisw, requestParameters.facilityIdIe, requestParameters.facilityIdNie, requestParameters.assetTagN, requestParameters.assetTagIc, requestParameters.assetTagNic, requestParameters.assetTagIew, requestParameters.assetTagNiew, requestParameters.assetTagIsw, requestParameters.assetTagNisw, requestParameters.assetTagIe, requestParameters.assetTagNie, requestParameters.typeN, requestParameters.widthN, requestParameters.uHeightN, requestParameters.uHeightLte, requestParameters.uHeightLt, requestParameters.uHeightGte, requestParameters.uHeightGt, requestParameters.outerWidthN, requestParameters.outerWidthLte, requestParameters.outerWidthLt, requestParameters.outerWidthGte, requestParameters.outerWidthGt, requestParameters.outerDepthN, requestParameters.outerDepthLte, requestParameters.outerDepthLt, requestParameters.outerDepthGte, requestParameters.outerDepthGt, requestParameters.outerUnitN, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.statusN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksPartialUpdate(requestParameters: DcimApiDcimRacksPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksRead(requestParameters: DcimApiDcimRacksReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRacksUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRacksUpdate(requestParameters: DcimApiDcimRacksUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRacksUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkPartialUpdate(requestParameters: DcimApiDcimRearPortTemplatesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesBulkUpdate(requestParameters: DcimApiDcimRearPortTemplatesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesCreate(requestParameters: DcimApiDcimRearPortTemplatesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesDelete(requestParameters: DcimApiDcimRearPortTemplatesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesList(requestParameters: DcimApiDcimRearPortTemplatesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.positions, requestParameters.q, requestParameters.devicetypeId, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.positionsN, requestParameters.positionsLte, requestParameters.positionsLt, requestParameters.positionsGte, requestParameters.positionsGt, requestParameters.devicetypeIdN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesPartialUpdate(requestParameters: DcimApiDcimRearPortTemplatesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesRead(requestParameters: DcimApiDcimRearPortTemplatesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortTemplatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortTemplatesUpdate(requestParameters: DcimApiDcimRearPortTemplatesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortTemplatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkPartialUpdate(requestParameters: DcimApiDcimRearPortsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsBulkUpdate(requestParameters: DcimApiDcimRearPortsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsCreate(requestParameters: DcimApiDcimRearPortsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsDelete(requestParameters: DcimApiDcimRearPortsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsList(requestParameters: DcimApiDcimRearPortsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsList(requestParameters.id, requestParameters.name, requestParameters.type, requestParameters.positions, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.deviceId, requestParameters.device, requestParameters.tag, requestParameters.cabled, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.typeN, requestParameters.positionsN, requestParameters.positionsLte, requestParameters.positionsLt, requestParameters.positionsGte, requestParameters.positionsGt, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsPartialUpdate(requestParameters: DcimApiDcimRearPortsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return all CablePaths which traverse a given pass-through port.
     * @param {DcimApiDcimRearPortsPathsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsPaths(requestParameters: DcimApiDcimRearPortsPathsRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsPaths(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsRead(requestParameters: DcimApiDcimRearPortsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRearPortsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRearPortsUpdate(requestParameters: DcimApiDcimRearPortsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRearPortsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkPartialUpdate(requestParameters: DcimApiDcimRegionsBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsBulkUpdate(requestParameters: DcimApiDcimRegionsBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsCreate(requestParameters: DcimApiDcimRegionsCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsDelete(requestParameters: DcimApiDcimRegionsDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsList(requestParameters: DcimApiDcimRegionsListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.parentId, requestParameters.parent, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.parentIdN, requestParameters.parentN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsPartialUpdate(requestParameters: DcimApiDcimRegionsPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsRead(requestParameters: DcimApiDcimRegionsReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimRegionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimRegionsUpdate(requestParameters: DcimApiDcimRegionsUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimRegionsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkPartialUpdate(requestParameters: DcimApiDcimSitesBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesBulkUpdate(requestParameters: DcimApiDcimSitesBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesCreate(requestParameters: DcimApiDcimSitesCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesDelete(requestParameters: DcimApiDcimSitesDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesList(requestParameters: DcimApiDcimSitesListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.facility, requestParameters.asn, requestParameters.latitude, requestParameters.longitude, requestParameters.contactName, requestParameters.contactPhone, requestParameters.contactEmail, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.status, requestParameters.regionId, requestParameters.region, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.facilityN, requestParameters.facilityIc, requestParameters.facilityNic, requestParameters.facilityIew, requestParameters.facilityNiew, requestParameters.facilityIsw, requestParameters.facilityNisw, requestParameters.facilityIe, requestParameters.facilityNie, requestParameters.asnN, requestParameters.asnLte, requestParameters.asnLt, requestParameters.asnGte, requestParameters.asnGt, requestParameters.latitudeN, requestParameters.latitudeLte, requestParameters.latitudeLt, requestParameters.latitudeGte, requestParameters.latitudeGt, requestParameters.longitudeN, requestParameters.longitudeLte, requestParameters.longitudeLt, requestParameters.longitudeGte, requestParameters.longitudeGt, requestParameters.contactNameN, requestParameters.contactNameIc, requestParameters.contactNameNic, requestParameters.contactNameIew, requestParameters.contactNameNiew, requestParameters.contactNameIsw, requestParameters.contactNameNisw, requestParameters.contactNameIe, requestParameters.contactNameNie, requestParameters.contactPhoneN, requestParameters.contactPhoneIc, requestParameters.contactPhoneNic, requestParameters.contactPhoneIew, requestParameters.contactPhoneNiew, requestParameters.contactPhoneIsw, requestParameters.contactPhoneNisw, requestParameters.contactPhoneIe, requestParameters.contactPhoneNie, requestParameters.contactEmailN, requestParameters.contactEmailIc, requestParameters.contactEmailNic, requestParameters.contactEmailIew, requestParameters.contactEmailNiew, requestParameters.contactEmailIsw, requestParameters.contactEmailNisw, requestParameters.contactEmailIe, requestParameters.contactEmailNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.statusN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesPartialUpdate(requestParameters: DcimApiDcimSitesPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesRead(requestParameters: DcimApiDcimSitesReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimSitesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimSitesUpdate(requestParameters: DcimApiDcimSitesUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimSitesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkDelete(options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkPartialUpdate(requestParameters: DcimApiDcimVirtualChassisBulkPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisBulkUpdate(requestParameters: DcimApiDcimVirtualChassisBulkUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisCreate(requestParameters: DcimApiDcimVirtualChassisCreateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisDelete(requestParameters: DcimApiDcimVirtualChassisDeleteRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisList(requestParameters: DcimApiDcimVirtualChassisListRequest = {}, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisList(requestParameters.id, requestParameters.domain, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.tenantId, requestParameters.tenant, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.domainN, requestParameters.domainIc, requestParameters.domainNic, requestParameters.domainIew, requestParameters.domainNiew, requestParameters.domainIsw, requestParameters.domainNisw, requestParameters.domainIe, requestParameters.domainNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisPartialUpdate(requestParameters: DcimApiDcimVirtualChassisPartialUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisRead(requestParameters: DcimApiDcimVirtualChassisReadRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DcimApiDcimVirtualChassisUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DcimApi
     */
    public dcimVirtualChassisUpdate(requestParameters: DcimApiDcimVirtualChassisUpdateRequest, options?: any) {
        return DcimApiFp(this.configuration).dcimVirtualChassisUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}
