/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Cluster } from '../models';
// @ts-ignore
import { ClusterGroup } from '../models';
// @ts-ignore
import { ClusterType } from '../models';
// @ts-ignore
import { InlineResponse20062 } from '../models';
// @ts-ignore
import { InlineResponse20063 } from '../models';
// @ts-ignore
import { InlineResponse20064 } from '../models';
// @ts-ignore
import { InlineResponse20065 } from '../models';
// @ts-ignore
import { InlineResponse20066 } from '../models';
// @ts-ignore
import { VMInterface } from '../models';
// @ts-ignore
import { VirtualMachineWithConfigContext } from '../models';
// @ts-ignore
import { WritableCluster } from '../models';
// @ts-ignore
import { WritableVMInterface } from '../models';
// @ts-ignore
import { WritableVirtualMachineWithConfigContext } from '../models';
/**
 * VirtualizationApi - axios parameter creator
 * @export
 */
export const VirtualizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkPartialUpdate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkUpdate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsCreate: async (data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsCreate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsDelete', 'id', id)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsPartialUpdate: async (id: number, data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsRead', 'id', id)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsUpdate: async (id: number, data: ClusterGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterGroupsUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkPartialUpdate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkUpdate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesCreate: async (data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesCreate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesDelete', 'id', id)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/cluster-types/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesPartialUpdate: async (id: number, data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesRead', 'id', id)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesUpdate: async (id: number, data: ClusterType, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClusterTypesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClusterTypesUpdate', 'data', data)
            const localVarPath = `/virtualization/cluster-types/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkPartialUpdate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkUpdate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersCreate: async (data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersCreate', 'data', data)
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersDelete', 'id', id)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersList: async (id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/clusters/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (typeId !== undefined) {
                localVarQueryParameter['type_id'] = typeId;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (typeIdN !== undefined) {
                localVarQueryParameter['type_id__n'] = typeIdN;
            }

            if (typeN !== undefined) {
                localVarQueryParameter['type__n'] = typeN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersPartialUpdate: async (id: number, data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersRead', 'id', id)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersUpdate: async (id: number, data: WritableCluster, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationClustersUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationClustersUpdate', 'data', data)
            const localVarPath = `/virtualization/clusters/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkPartialUpdate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkUpdate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesCreate: async (data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesCreate', 'data', data)
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesDelete', 'id', id)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesList: async (id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/interfaces/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (mtu !== undefined) {
                localVarQueryParameter['mtu'] = mtu;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (mtuN !== undefined) {
                localVarQueryParameter['mtu__n'] = mtuN;
            }

            if (mtuLte !== undefined) {
                localVarQueryParameter['mtu__lte'] = mtuLte;
            }

            if (mtuLt !== undefined) {
                localVarQueryParameter['mtu__lt'] = mtuLt;
            }

            if (mtuGte !== undefined) {
                localVarQueryParameter['mtu__gte'] = mtuGte;
            }

            if (mtuGt !== undefined) {
                localVarQueryParameter['mtu__gt'] = mtuGt;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (clusterN !== undefined) {
                localVarQueryParameter['cluster__n'] = clusterN;
            }

            if (virtualMachineIdN !== undefined) {
                localVarQueryParameter['virtual_machine_id__n'] = virtualMachineIdN;
            }

            if (virtualMachineN !== undefined) {
                localVarQueryParameter['virtual_machine__n'] = virtualMachineN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesPartialUpdate: async (id: number, data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesRead', 'id', id)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesUpdate: async (id: number, data: WritableVMInterface, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationInterfacesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationInterfacesUpdate', 'data', data)
            const localVarPath = `/virtualization/interfaces/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkPartialUpdate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesBulkPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkUpdate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesBulkUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesCreate: async (data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesCreate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesDelete', 'id', id)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesList: async (id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/virtualization/virtual-machines/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (cluster !== undefined) {
                localVarQueryParameter['cluster'] = cluster;
            }

            if (vcpus !== undefined) {
                localVarQueryParameter['vcpus'] = vcpus;
            }

            if (memory !== undefined) {
                localVarQueryParameter['memory'] = memory;
            }

            if (disk !== undefined) {
                localVarQueryParameter['disk'] = disk;
            }

            if (localContextData !== undefined) {
                localVarQueryParameter['local_context_data'] = localContextData;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (clusterGroupId !== undefined) {
                localVarQueryParameter['cluster_group_id'] = clusterGroupId;
            }

            if (clusterGroup !== undefined) {
                localVarQueryParameter['cluster_group'] = clusterGroup;
            }

            if (clusterTypeId !== undefined) {
                localVarQueryParameter['cluster_type_id'] = clusterTypeId;
            }

            if (clusterType !== undefined) {
                localVarQueryParameter['cluster_type'] = clusterType;
            }

            if (clusterId !== undefined) {
                localVarQueryParameter['cluster_id'] = clusterId;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (platformId !== undefined) {
                localVarQueryParameter['platform_id'] = platformId;
            }

            if (platform !== undefined) {
                localVarQueryParameter['platform'] = platform;
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (hasPrimaryIp !== undefined) {
                localVarQueryParameter['has_primary_ip'] = hasPrimaryIp;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (clusterN !== undefined) {
                localVarQueryParameter['cluster__n'] = clusterN;
            }

            if (vcpusN !== undefined) {
                localVarQueryParameter['vcpus__n'] = vcpusN;
            }

            if (vcpusLte !== undefined) {
                localVarQueryParameter['vcpus__lte'] = vcpusLte;
            }

            if (vcpusLt !== undefined) {
                localVarQueryParameter['vcpus__lt'] = vcpusLt;
            }

            if (vcpusGte !== undefined) {
                localVarQueryParameter['vcpus__gte'] = vcpusGte;
            }

            if (vcpusGt !== undefined) {
                localVarQueryParameter['vcpus__gt'] = vcpusGt;
            }

            if (memoryN !== undefined) {
                localVarQueryParameter['memory__n'] = memoryN;
            }

            if (memoryLte !== undefined) {
                localVarQueryParameter['memory__lte'] = memoryLte;
            }

            if (memoryLt !== undefined) {
                localVarQueryParameter['memory__lt'] = memoryLt;
            }

            if (memoryGte !== undefined) {
                localVarQueryParameter['memory__gte'] = memoryGte;
            }

            if (memoryGt !== undefined) {
                localVarQueryParameter['memory__gt'] = memoryGt;
            }

            if (diskN !== undefined) {
                localVarQueryParameter['disk__n'] = diskN;
            }

            if (diskLte !== undefined) {
                localVarQueryParameter['disk__lte'] = diskLte;
            }

            if (diskLt !== undefined) {
                localVarQueryParameter['disk__lt'] = diskLt;
            }

            if (diskGte !== undefined) {
                localVarQueryParameter['disk__gte'] = diskGte;
            }

            if (diskGt !== undefined) {
                localVarQueryParameter['disk__gt'] = diskGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (clusterGroupIdN !== undefined) {
                localVarQueryParameter['cluster_group_id__n'] = clusterGroupIdN;
            }

            if (clusterGroupN !== undefined) {
                localVarQueryParameter['cluster_group__n'] = clusterGroupN;
            }

            if (clusterTypeIdN !== undefined) {
                localVarQueryParameter['cluster_type_id__n'] = clusterTypeIdN;
            }

            if (clusterTypeN !== undefined) {
                localVarQueryParameter['cluster_type__n'] = clusterTypeN;
            }

            if (clusterIdN !== undefined) {
                localVarQueryParameter['cluster_id__n'] = clusterIdN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (platformIdN !== undefined) {
                localVarQueryParameter['platform_id__n'] = platformIdN;
            }

            if (platformN !== undefined) {
                localVarQueryParameter['platform__n'] = platformN;
            }

            if (macAddressN !== undefined) {
                localVarQueryParameter['mac_address__n'] = macAddressN;
            }

            if (macAddressIc !== undefined) {
                localVarQueryParameter['mac_address__ic'] = macAddressIc;
            }

            if (macAddressNic !== undefined) {
                localVarQueryParameter['mac_address__nic'] = macAddressNic;
            }

            if (macAddressIew !== undefined) {
                localVarQueryParameter['mac_address__iew'] = macAddressIew;
            }

            if (macAddressNiew !== undefined) {
                localVarQueryParameter['mac_address__niew'] = macAddressNiew;
            }

            if (macAddressIsw !== undefined) {
                localVarQueryParameter['mac_address__isw'] = macAddressIsw;
            }

            if (macAddressNisw !== undefined) {
                localVarQueryParameter['mac_address__nisw'] = macAddressNisw;
            }

            if (macAddressIe !== undefined) {
                localVarQueryParameter['mac_address__ie'] = macAddressIe;
            }

            if (macAddressNie !== undefined) {
                localVarQueryParameter['mac_address__nie'] = macAddressNie;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesPartialUpdate: async (id: number, data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesPartialUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesRead', 'id', id)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesUpdate: async (id: number, data: WritableVirtualMachineWithConfigContext, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('virtualizationVirtualMachinesUpdate', 'data', data)
            const localVarPath = `/virtualization/virtual-machines/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VirtualizationApi - functional programming interface
 * @export
 */
export const VirtualizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VirtualizationApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkPartialUpdate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsBulkUpdate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsCreate(data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20062>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsPartialUpdate(id: number, data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterGroupsUpdate(id: number, data: ClusterGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkPartialUpdate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesBulkUpdate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesCreate(data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20063>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesPartialUpdate(id: number, data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClusterTypesUpdate(id: number, data: ClusterType, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterType>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClusterTypesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkPartialUpdate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersBulkUpdate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersCreate(data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20064>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, typeId, type, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, typeIdN, typeN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersPartialUpdate(id: number, data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationClustersUpdate(id: number, data: WritableCluster, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Cluster>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationClustersUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkPartialUpdate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesBulkUpdate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesCreate(data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesList(id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20065>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesList(id, name, enabled, mtu, q, clusterId, cluster, virtualMachineId, virtualMachine, macAddress, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, clusterIdN, clusterN, virtualMachineIdN, virtualMachineN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesPartialUpdate(id: number, data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationInterfacesUpdate(id: number, data: WritableVMInterface, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VMInterface>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationInterfacesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkPartialUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesBulkUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesCreate(data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesList(id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20066>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesList(id, name, cluster, vcpus, memory, disk, localContextData, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, clusterGroupId, clusterGroup, clusterTypeId, clusterType, clusterId, regionId, region, siteId, site, roleId, role, platformId, platform, macAddress, hasPrimaryIp, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, clusterN, vcpusN, vcpusLte, vcpusLt, vcpusGte, vcpusGt, memoryN, memoryLte, memoryLt, memoryGte, memoryGt, diskN, diskLte, diskLt, diskGte, diskGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, clusterGroupIdN, clusterGroupN, clusterTypeIdN, clusterTypeN, clusterIdN, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesPartialUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async virtualizationVirtualMachinesUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VirtualMachineWithConfigContext>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.virtualizationVirtualMachinesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VirtualizationApi - factory interface
 * @export
 */
export const VirtualizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VirtualizationApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkPartialUpdate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsBulkUpdate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsCreate(data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20062> {
            return localVarFp.virtualizationClusterGroupsList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsPartialUpdate(id: number, data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsRead(id: number, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster group.
         * @param {ClusterGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterGroupsUpdate(id: number, data: ClusterGroup, options?: any): AxiosPromise<ClusterGroup> {
            return localVarFp.virtualizationClusterGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterTypesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkPartialUpdate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesBulkUpdate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesCreate(data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClusterTypesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesList(id?: string, name?: string, slug?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20063> {
            return localVarFp.virtualizationClusterTypesList(id, name, slug, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesPartialUpdate(id: number, data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesRead(id: number, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster type.
         * @param {ClusterType} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClusterTypesUpdate(id: number, data: ClusterType, options?: any): AxiosPromise<ClusterType> {
            return localVarFp.virtualizationClusterTypesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClustersBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkPartialUpdate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersBulkUpdate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersCreate(data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationClustersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [typeId] 
         * @param {string} [type] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [typeIdN] 
         * @param {string} [typeN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, typeId?: string, type?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, typeIdN?: string, typeN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20064> {
            return localVarFp.virtualizationClustersList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, typeId, type, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, typeIdN, typeN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersPartialUpdate(id: number, data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersRead(id: number, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this cluster.
         * @param {WritableCluster} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationClustersUpdate(id: number, data: WritableCluster, options?: any): AxiosPromise<Cluster> {
            return localVarFp.virtualizationClustersUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationInterfacesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkPartialUpdate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesBulkUpdate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesCreate(data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationInterfacesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [enabled] 
         * @param {string} [mtu] 
         * @param {string} [q] 
         * @param {string} [clusterId] 
         * @param {string} [cluster] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {string} [macAddress] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [mtuN] 
         * @param {string} [mtuLte] 
         * @param {string} [mtuLt] 
         * @param {string} [mtuGte] 
         * @param {string} [mtuGt] 
         * @param {string} [clusterIdN] 
         * @param {string} [clusterN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesList(id?: string, name?: string, enabled?: string, mtu?: string, q?: string, clusterId?: string, cluster?: string, virtualMachineId?: string, virtualMachine?: string, macAddress?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, mtuN?: string, mtuLte?: string, mtuLt?: string, mtuGte?: string, mtuGt?: string, clusterIdN?: string, clusterN?: string, virtualMachineIdN?: string, virtualMachineN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20065> {
            return localVarFp.virtualizationInterfacesList(id, name, enabled, mtu, q, clusterId, cluster, virtualMachineId, virtualMachine, macAddress, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, mtuN, mtuLte, mtuLt, mtuGte, mtuGt, clusterIdN, clusterN, virtualMachineIdN, virtualMachineN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesPartialUpdate(id: number, data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesRead(id: number, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this interface.
         * @param {WritableVMInterface} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationInterfacesUpdate(id: number, data: WritableVMInterface, options?: any): AxiosPromise<VMInterface> {
            return localVarFp.virtualizationInterfacesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationVirtualMachinesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkPartialUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesBulkUpdate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesCreate(data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.virtualizationVirtualMachinesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [cluster] 
         * @param {string} [vcpus] 
         * @param {string} [memory] 
         * @param {string} [disk] 
         * @param {string} [localContextData] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [status] 
         * @param {string} [clusterGroupId] 
         * @param {string} [clusterGroup] 
         * @param {string} [clusterTypeId] 
         * @param {string} [clusterType] 
         * @param {string} [clusterId] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [platformId] 
         * @param {string} [platform] 
         * @param {string} [macAddress] 
         * @param {string} [hasPrimaryIp] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [clusterN] 
         * @param {string} [vcpusN] 
         * @param {string} [vcpusLte] 
         * @param {string} [vcpusLt] 
         * @param {string} [vcpusGte] 
         * @param {string} [vcpusGt] 
         * @param {string} [memoryN] 
         * @param {string} [memoryLte] 
         * @param {string} [memoryLt] 
         * @param {string} [memoryGte] 
         * @param {string} [memoryGt] 
         * @param {string} [diskN] 
         * @param {string} [diskLte] 
         * @param {string} [diskLt] 
         * @param {string} [diskGte] 
         * @param {string} [diskGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [statusN] 
         * @param {string} [clusterGroupIdN] 
         * @param {string} [clusterGroupN] 
         * @param {string} [clusterTypeIdN] 
         * @param {string} [clusterTypeN] 
         * @param {string} [clusterIdN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [platformIdN] 
         * @param {string} [platformN] 
         * @param {string} [macAddressN] 
         * @param {string} [macAddressIc] 
         * @param {string} [macAddressNic] 
         * @param {string} [macAddressIew] 
         * @param {string} [macAddressNiew] 
         * @param {string} [macAddressIsw] 
         * @param {string} [macAddressNisw] 
         * @param {string} [macAddressIe] 
         * @param {string} [macAddressNie] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesList(id?: string, name?: string, cluster?: string, vcpus?: string, memory?: string, disk?: string, localContextData?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, status?: string, clusterGroupId?: string, clusterGroup?: string, clusterTypeId?: string, clusterType?: string, clusterId?: string, regionId?: string, region?: string, siteId?: string, site?: string, roleId?: string, role?: string, platformId?: string, platform?: string, macAddress?: string, hasPrimaryIp?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, clusterN?: string, vcpusN?: string, vcpusLte?: string, vcpusLt?: string, vcpusGte?: string, vcpusGt?: string, memoryN?: string, memoryLte?: string, memoryLt?: string, memoryGte?: string, memoryGt?: string, diskN?: string, diskLte?: string, diskLt?: string, diskGte?: string, diskGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, statusN?: string, clusterGroupIdN?: string, clusterGroupN?: string, clusterTypeIdN?: string, clusterTypeN?: string, clusterIdN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, roleIdN?: string, roleN?: string, platformIdN?: string, platformN?: string, macAddressN?: string, macAddressIc?: string, macAddressNic?: string, macAddressIew?: string, macAddressNiew?: string, macAddressIsw?: string, macAddressNisw?: string, macAddressIe?: string, macAddressNie?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20066> {
            return localVarFp.virtualizationVirtualMachinesList(id, name, cluster, vcpus, memory, disk, localContextData, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, status, clusterGroupId, clusterGroup, clusterTypeId, clusterType, clusterId, regionId, region, siteId, site, roleId, role, platformId, platform, macAddress, hasPrimaryIp, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, clusterN, vcpusN, vcpusLte, vcpusLt, vcpusGte, vcpusGt, memoryN, memoryLte, memoryLt, memoryGte, memoryGt, diskN, diskLte, diskLt, diskGte, diskGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, statusN, clusterGroupIdN, clusterGroupN, clusterTypeIdN, clusterTypeN, clusterIdN, regionIdN, regionN, siteIdN, siteN, roleIdN, roleN, platformIdN, platformN, macAddressN, macAddressIc, macAddressNic, macAddressIew, macAddressNiew, macAddressIsw, macAddressNisw, macAddressIe, macAddressNie, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesPartialUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesRead(id: number, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this virtual machine.
         * @param {WritableVirtualMachineWithConfigContext} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        virtualizationVirtualMachinesUpdate(id: number, data: WritableVirtualMachineWithConfigContext, options?: any): AxiosPromise<VirtualMachineWithConfigContext> {
            return localVarFp.virtualizationVirtualMachinesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for virtualizationClusterGroupsBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsBulkUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsCreateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsCreateRequest {
    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsCreate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsDeleteRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsDeleteRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterGroupsList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsListRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClusterGroupsPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsPartialUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterGroupsRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsReadRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsReadRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterGroupsUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterGroupsUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterGroupsUpdateRequest {
    /**
     * A unique integer value identifying this cluster group.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterGroup}
     * @memberof VirtualizationApiVirtualizationClusterGroupsUpdate
     */
    readonly data: ClusterGroup
}

/**
 * Request parameters for virtualizationClusterTypesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesBulkPartialUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesBulkUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesCreateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesCreateRequest {
    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesCreate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesDeleteRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesDeleteRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterTypesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesListRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClusterTypesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesPartialUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClusterTypesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesReadRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesReadRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClusterTypesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClusterTypesUpdateRequest
 */
export interface VirtualizationApiVirtualizationClusterTypesUpdateRequest {
    /**
     * A unique integer value identifying this cluster type.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClusterTypesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {ClusterType}
     * @memberof VirtualizationApiVirtualizationClusterTypesUpdate
     */
    readonly data: ClusterType
}

/**
 * Request parameters for virtualizationClustersBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersBulkPartialUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersBulkUpdateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersBulkUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersCreateRequest
 */
export interface VirtualizationApiVirtualizationClustersCreateRequest {
    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersCreate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersDeleteRequest
 */
export interface VirtualizationApiVirtualizationClustersDeleteRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClustersList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersListRequest
 */
export interface VirtualizationApiVirtualizationClustersListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly type?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly typeN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationClustersPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersPartialUpdateRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersPartialUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationClustersRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersReadRequest
 */
export interface VirtualizationApiVirtualizationClustersReadRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationClustersUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationClustersUpdateRequest
 */
export interface VirtualizationApiVirtualizationClustersUpdateRequest {
    /**
     * A unique integer value identifying this cluster.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationClustersUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableCluster}
     * @memberof VirtualizationApiVirtualizationClustersUpdate
     */
    readonly data: WritableCluster
}

/**
 * Request parameters for virtualizationInterfacesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesBulkPartialUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesBulkUpdateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesBulkUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesCreateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesCreateRequest {
    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesCreate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesDeleteRequest
 */
export interface VirtualizationApiVirtualizationInterfacesDeleteRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationInterfacesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesListRequest
 */
export interface VirtualizationApiVirtualizationInterfacesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly enabled?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtu?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly cluster?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly mtuGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly clusterN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly virtualMachineN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationInterfacesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesPartialUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesPartialUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationInterfacesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesReadRequest
 */
export interface VirtualizationApiVirtualizationInterfacesReadRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationInterfacesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationInterfacesUpdateRequest
 */
export interface VirtualizationApiVirtualizationInterfacesUpdateRequest {
    /**
     * A unique integer value identifying this interface.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationInterfacesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVMInterface}
     * @memberof VirtualizationApiVirtualizationInterfacesUpdate
     */
    readonly data: WritableVMInterface
}

/**
 * Request parameters for virtualizationVirtualMachinesBulkPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesBulkUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesBulkUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesCreate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesCreateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesCreateRequest {
    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesCreate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesDelete operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesDeleteRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesDeleteRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesDelete
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationVirtualMachinesList operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesListRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesListRequest {
    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly cluster?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpus?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memory?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly disk?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly localContextData?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroup?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterType?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformId?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platform?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddress?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly hasPrimaryIp?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly vcpusGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly memoryGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskLte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskLt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskGte?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly diskGt?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterTypeN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly clusterIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformIdN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly platformN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressN?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIc?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNic?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNiew?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIsw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNisw?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressIe?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly macAddressNie?: string

    /**
     * 
     * @type {string}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesList
     */
    readonly offset?: number
}

/**
 * Request parameters for virtualizationVirtualMachinesPartialUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesPartialUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * Request parameters for virtualizationVirtualMachinesRead operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesReadRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesReadRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesRead
     */
    readonly id: number
}

/**
 * Request parameters for virtualizationVirtualMachinesUpdate operation in VirtualizationApi.
 * @export
 * @interface VirtualizationApiVirtualizationVirtualMachinesUpdateRequest
 */
export interface VirtualizationApiVirtualizationVirtualMachinesUpdateRequest {
    /**
     * A unique integer value identifying this virtual machine.
     * @type {number}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVirtualMachineWithConfigContext}
     * @memberof VirtualizationApiVirtualizationVirtualMachinesUpdate
     */
    readonly data: WritableVirtualMachineWithConfigContext
}

/**
 * VirtualizationApi - object-oriented interface
 * @export
 * @class VirtualizationApi
 * @extends {BaseAPI}
 */
export class VirtualizationApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsBulkUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsCreate(requestParameters: VirtualizationApiVirtualizationClusterGroupsCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsDelete(requestParameters: VirtualizationApiVirtualizationClusterGroupsDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsList(requestParameters: VirtualizationApiVirtualizationClusterGroupsListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsRead(requestParameters: VirtualizationApiVirtualizationClusterGroupsReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterGroupsUpdate(requestParameters: VirtualizationApiVirtualizationClusterGroupsUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesBulkUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesCreate(requestParameters: VirtualizationApiVirtualizationClusterTypesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesDelete(requestParameters: VirtualizationApiVirtualizationClusterTypesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesList(requestParameters: VirtualizationApiVirtualizationClusterTypesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesPartialUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesRead(requestParameters: VirtualizationApiVirtualizationClusterTypesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClusterTypesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClusterTypesUpdate(requestParameters: VirtualizationApiVirtualizationClusterTypesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClusterTypesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationClustersBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersBulkUpdate(requestParameters: VirtualizationApiVirtualizationClustersBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersCreate(requestParameters: VirtualizationApiVirtualizationClustersCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersDelete(requestParameters: VirtualizationApiVirtualizationClustersDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersList(requestParameters: VirtualizationApiVirtualizationClustersListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersList(requestParameters.id, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.typeId, requestParameters.type, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.typeIdN, requestParameters.typeN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersPartialUpdate(requestParameters: VirtualizationApiVirtualizationClustersPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersRead(requestParameters: VirtualizationApiVirtualizationClustersReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationClustersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationClustersUpdate(requestParameters: VirtualizationApiVirtualizationClustersUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationClustersUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesBulkUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesCreate(requestParameters: VirtualizationApiVirtualizationInterfacesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesDelete(requestParameters: VirtualizationApiVirtualizationInterfacesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesList(requestParameters: VirtualizationApiVirtualizationInterfacesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesList(requestParameters.id, requestParameters.name, requestParameters.enabled, requestParameters.mtu, requestParameters.q, requestParameters.clusterId, requestParameters.cluster, requestParameters.virtualMachineId, requestParameters.virtualMachine, requestParameters.macAddress, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.mtuN, requestParameters.mtuLte, requestParameters.mtuLt, requestParameters.mtuGte, requestParameters.mtuGt, requestParameters.clusterIdN, requestParameters.clusterN, requestParameters.virtualMachineIdN, requestParameters.virtualMachineN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesPartialUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesRead(requestParameters: VirtualizationApiVirtualizationInterfacesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationInterfacesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationInterfacesUpdate(requestParameters: VirtualizationApiVirtualizationInterfacesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationInterfacesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkDelete(options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkPartialUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesBulkPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesBulkUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesBulkUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesCreate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesCreateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesDelete(requestParameters: VirtualizationApiVirtualizationVirtualMachinesDeleteRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesList(requestParameters: VirtualizationApiVirtualizationVirtualMachinesListRequest = {}, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesList(requestParameters.id, requestParameters.name, requestParameters.cluster, requestParameters.vcpus, requestParameters.memory, requestParameters.disk, requestParameters.localContextData, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.status, requestParameters.clusterGroupId, requestParameters.clusterGroup, requestParameters.clusterTypeId, requestParameters.clusterType, requestParameters.clusterId, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.roleId, requestParameters.role, requestParameters.platformId, requestParameters.platform, requestParameters.macAddress, requestParameters.hasPrimaryIp, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.clusterN, requestParameters.vcpusN, requestParameters.vcpusLte, requestParameters.vcpusLt, requestParameters.vcpusGte, requestParameters.vcpusGt, requestParameters.memoryN, requestParameters.memoryLte, requestParameters.memoryLt, requestParameters.memoryGte, requestParameters.memoryGt, requestParameters.diskN, requestParameters.diskLte, requestParameters.diskLt, requestParameters.diskGte, requestParameters.diskGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.statusN, requestParameters.clusterGroupIdN, requestParameters.clusterGroupN, requestParameters.clusterTypeIdN, requestParameters.clusterTypeN, requestParameters.clusterIdN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.platformIdN, requestParameters.platformN, requestParameters.macAddressN, requestParameters.macAddressIc, requestParameters.macAddressNic, requestParameters.macAddressIew, requestParameters.macAddressNiew, requestParameters.macAddressIsw, requestParameters.macAddressNisw, requestParameters.macAddressIe, requestParameters.macAddressNie, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesPartialUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesPartialUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesRead(requestParameters: VirtualizationApiVirtualizationVirtualMachinesReadRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {VirtualizationApiVirtualizationVirtualMachinesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VirtualizationApi
     */
    public virtualizationVirtualMachinesUpdate(requestParameters: VirtualizationApiVirtualizationVirtualMachinesUpdateRequest, options?: any) {
        return VirtualizationApiFp(this.configuration).virtualizationVirtualMachinesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}
