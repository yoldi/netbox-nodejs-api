/* tslint:disable */
/* eslint-disable */
/**
 * NetBox API
 * API to access NetBox
 *
 * The version of the OpenAPI document: 2.10
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { Aggregate } from '../models';
// @ts-ignore
import { AvailableIP } from '../models';
// @ts-ignore
import { AvailablePrefix } from '../models';
// @ts-ignore
import { IPAddress } from '../models';
// @ts-ignore
import { InlineResponse20045 } from '../models';
// @ts-ignore
import { InlineResponse20046 } from '../models';
// @ts-ignore
import { InlineResponse20047 } from '../models';
// @ts-ignore
import { InlineResponse20048 } from '../models';
// @ts-ignore
import { InlineResponse20049 } from '../models';
// @ts-ignore
import { InlineResponse20050 } from '../models';
// @ts-ignore
import { InlineResponse20051 } from '../models';
// @ts-ignore
import { InlineResponse20052 } from '../models';
// @ts-ignore
import { InlineResponse20053 } from '../models';
// @ts-ignore
import { InlineResponse20054 } from '../models';
// @ts-ignore
import { Prefix } from '../models';
// @ts-ignore
import { PrefixLength } from '../models';
// @ts-ignore
import { RIR } from '../models';
// @ts-ignore
import { Role } from '../models';
// @ts-ignore
import { RouteTarget } from '../models';
// @ts-ignore
import { Service } from '../models';
// @ts-ignore
import { VLAN } from '../models';
// @ts-ignore
import { VLANGroup } from '../models';
// @ts-ignore
import { VRF } from '../models';
// @ts-ignore
import { WritableAggregate } from '../models';
// @ts-ignore
import { WritableAvailableIP } from '../models';
// @ts-ignore
import { WritableIPAddress } from '../models';
// @ts-ignore
import { WritablePrefix } from '../models';
// @ts-ignore
import { WritableRouteTarget } from '../models';
// @ts-ignore
import { WritableService } from '../models';
// @ts-ignore
import { WritableVLAN } from '../models';
// @ts-ignore
import { WritableVLANGroup } from '../models';
// @ts-ignore
import { WritableVRF } from '../models';
/**
 * IpamApi - axios parameter creator
 * @export
 */
export const IpamApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkPartialUpdate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkUpdate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesCreate: async (data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesCreate', 'data', data)
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesDelete', 'id', id)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesList: async (id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/aggregates/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dateAdded !== undefined) {
                localVarQueryParameter['date_added'] = dateAdded;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (rirId !== undefined) {
                localVarQueryParameter['rir_id'] = rirId;
            }

            if (rir !== undefined) {
                localVarQueryParameter['rir'] = rir;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (dateAddedN !== undefined) {
                localVarQueryParameter['date_added__n'] = dateAddedN;
            }

            if (dateAddedLte !== undefined) {
                localVarQueryParameter['date_added__lte'] = dateAddedLte;
            }

            if (dateAddedLt !== undefined) {
                localVarQueryParameter['date_added__lt'] = dateAddedLt;
            }

            if (dateAddedGte !== undefined) {
                localVarQueryParameter['date_added__gte'] = dateAddedGte;
            }

            if (dateAddedGt !== undefined) {
                localVarQueryParameter['date_added__gt'] = dateAddedGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (rirIdN !== undefined) {
                localVarQueryParameter['rir_id__n'] = rirIdN;
            }

            if (rirN !== undefined) {
                localVarQueryParameter['rir__n'] = rirN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesPartialUpdate: async (id: number, data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesRead', 'id', id)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesUpdate: async (id: number, data: WritableAggregate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamAggregatesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamAggregatesUpdate', 'data', data)
            const localVarPath = `/ipam/aggregates/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkPartialUpdate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkUpdate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesCreate: async (data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesCreate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesDelete', 'id', id)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesList: async (id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/ip-addresses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dnsName !== undefined) {
                localVarQueryParameter['dns_name'] = dnsName;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (parent !== undefined) {
                localVarQueryParameter['parent'] = parent;
            }

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }

            if (maskLength !== undefined) {
                localVarQueryParameter['mask_length'] = maskLength;
            }

            if (vrfId !== undefined) {
                localVarQueryParameter['vrf_id'] = vrfId;
            }

            if (vrf !== undefined) {
                localVarQueryParameter['vrf'] = vrf;
            }

            if (presentInVrfId !== undefined) {
                localVarQueryParameter['present_in_vrf_id'] = presentInVrfId;
            }

            if (presentInVrf !== undefined) {
                localVarQueryParameter['present_in_vrf'] = presentInVrf;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (_interface !== undefined) {
                localVarQueryParameter['interface'] = _interface;
            }

            if (interfaceId !== undefined) {
                localVarQueryParameter['interface_id'] = interfaceId;
            }

            if (vminterface !== undefined) {
                localVarQueryParameter['vminterface'] = vminterface;
            }

            if (vminterfaceId !== undefined) {
                localVarQueryParameter['vminterface_id'] = vminterfaceId;
            }

            if (assignedToInterface !== undefined) {
                localVarQueryParameter['assigned_to_interface'] = assignedToInterface;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (dnsNameN !== undefined) {
                localVarQueryParameter['dns_name__n'] = dnsNameN;
            }

            if (dnsNameIc !== undefined) {
                localVarQueryParameter['dns_name__ic'] = dnsNameIc;
            }

            if (dnsNameNic !== undefined) {
                localVarQueryParameter['dns_name__nic'] = dnsNameNic;
            }

            if (dnsNameIew !== undefined) {
                localVarQueryParameter['dns_name__iew'] = dnsNameIew;
            }

            if (dnsNameNiew !== undefined) {
                localVarQueryParameter['dns_name__niew'] = dnsNameNiew;
            }

            if (dnsNameIsw !== undefined) {
                localVarQueryParameter['dns_name__isw'] = dnsNameIsw;
            }

            if (dnsNameNisw !== undefined) {
                localVarQueryParameter['dns_name__nisw'] = dnsNameNisw;
            }

            if (dnsNameIe !== undefined) {
                localVarQueryParameter['dns_name__ie'] = dnsNameIe;
            }

            if (dnsNameNie !== undefined) {
                localVarQueryParameter['dns_name__nie'] = dnsNameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (vrfIdN !== undefined) {
                localVarQueryParameter['vrf_id__n'] = vrfIdN;
            }

            if (vrfN !== undefined) {
                localVarQueryParameter['vrf__n'] = vrfN;
            }

            if (interfaceN !== undefined) {
                localVarQueryParameter['interface__n'] = interfaceN;
            }

            if (interfaceIdN !== undefined) {
                localVarQueryParameter['interface_id__n'] = interfaceIdN;
            }

            if (vminterfaceN !== undefined) {
                localVarQueryParameter['vminterface__n'] = vminterfaceN;
            }

            if (vminterfaceIdN !== undefined) {
                localVarQueryParameter['vminterface_id__n'] = vminterfaceIdN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesPartialUpdate: async (id: number, data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesRead', 'id', id)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesUpdate: async (id: number, data: WritableIPAddress, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamIpAddressesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamIpAddressesUpdate', 'data', data)
            const localVarPath = `/ipam/ip-addresses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsCreate: async (id: number, data: WritableAvailableIP, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsCreate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/available-ips/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailableIpsRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/available-ips/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesCreate: async (id: number, data: PrefixLength, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesCreate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/available-prefixes/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesAvailablePrefixesRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/available-prefixes/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkPartialUpdate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkUpdate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesCreate: async (data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesCreate', 'data', data)
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesDelete', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesList: async (id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/prefixes/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (isPool !== undefined) {
                localVarQueryParameter['is_pool'] = isPool;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (family !== undefined) {
                localVarQueryParameter['family'] = family;
            }

            if (prefix !== undefined) {
                localVarQueryParameter['prefix'] = prefix;
            }

            if (within !== undefined) {
                localVarQueryParameter['within'] = within;
            }

            if (withinInclude !== undefined) {
                localVarQueryParameter['within_include'] = withinInclude;
            }

            if (contains !== undefined) {
                localVarQueryParameter['contains'] = contains;
            }

            if (maskLength !== undefined) {
                localVarQueryParameter['mask_length'] = maskLength;
            }

            if (maskLengthGte !== undefined) {
                localVarQueryParameter['mask_length__gte'] = maskLengthGte;
            }

            if (maskLengthLte !== undefined) {
                localVarQueryParameter['mask_length__lte'] = maskLengthLte;
            }

            if (vrfId !== undefined) {
                localVarQueryParameter['vrf_id'] = vrfId;
            }

            if (vrf !== undefined) {
                localVarQueryParameter['vrf'] = vrf;
            }

            if (presentInVrfId !== undefined) {
                localVarQueryParameter['present_in_vrf_id'] = presentInVrfId;
            }

            if (presentInVrf !== undefined) {
                localVarQueryParameter['present_in_vrf'] = presentInVrf;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (vlanId !== undefined) {
                localVarQueryParameter['vlan_id'] = vlanId;
            }

            if (vlanVid !== undefined) {
                localVarQueryParameter['vlan_vid'] = vlanVid;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (vrfIdN !== undefined) {
                localVarQueryParameter['vrf_id__n'] = vrfIdN;
            }

            if (vrfN !== undefined) {
                localVarQueryParameter['vrf__n'] = vrfN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (vlanIdN !== undefined) {
                localVarQueryParameter['vlan_id__n'] = vlanIdN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesPartialUpdate: async (id: number, data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesRead', 'id', id)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesUpdate: async (id: number, data: WritablePrefix, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamPrefixesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamPrefixesUpdate', 'data', data)
            const localVarPath = `/ipam/prefixes/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkPartialUpdate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkUpdate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsCreate: async (data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsCreate', 'data', data)
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsDelete', 'id', id)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsList: async (id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/rirs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (isPrivate !== undefined) {
                localVarQueryParameter['is_private'] = isPrivate;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsPartialUpdate: async (id: number, data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsRead', 'id', id)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsUpdate: async (id: number, data: RIR, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRirsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRirsUpdate', 'data', data)
            const localVarPath = `/ipam/rirs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkPartialUpdate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkUpdate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesCreate: async (data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesCreate', 'data', data)
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesDelete', 'id', id)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesList: async (id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/roles/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesPartialUpdate: async (id: number, data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesRead', 'id', id)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesUpdate: async (id: number, data: Role, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRolesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRolesUpdate', 'data', data)
            const localVarPath = `/ipam/roles/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkPartialUpdate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkUpdate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsCreate: async (data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsCreate', 'data', data)
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsDelete', 'id', id)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsList: async (id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/route-targets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (importingVrfId !== undefined) {
                localVarQueryParameter['importing_vrf_id'] = importingVrfId;
            }

            if (importingVrf !== undefined) {
                localVarQueryParameter['importing_vrf'] = importingVrf;
            }

            if (exportingVrfId !== undefined) {
                localVarQueryParameter['exporting_vrf_id'] = exportingVrfId;
            }

            if (exportingVrf !== undefined) {
                localVarQueryParameter['exporting_vrf'] = exportingVrf;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (importingVrfIdN !== undefined) {
                localVarQueryParameter['importing_vrf_id__n'] = importingVrfIdN;
            }

            if (importingVrfN !== undefined) {
                localVarQueryParameter['importing_vrf__n'] = importingVrfN;
            }

            if (exportingVrfIdN !== undefined) {
                localVarQueryParameter['exporting_vrf_id__n'] = exportingVrfIdN;
            }

            if (exportingVrfN !== undefined) {
                localVarQueryParameter['exporting_vrf__n'] = exportingVrfN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsPartialUpdate: async (id: number, data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsRead', 'id', id)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsUpdate: async (id: number, data: WritableRouteTarget, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamRouteTargetsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamRouteTargetsUpdate', 'data', data)
            const localVarPath = `/ipam/route-targets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkPartialUpdate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkUpdate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesBulkUpdate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesCreate: async (data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesCreate', 'data', data)
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesDelete', 'id', id)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesList: async (id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/services/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (device !== undefined) {
                localVarQueryParameter['device'] = device;
            }

            if (virtualMachineId !== undefined) {
                localVarQueryParameter['virtual_machine_id'] = virtualMachineId;
            }

            if (virtualMachine !== undefined) {
                localVarQueryParameter['virtual_machine'] = virtualMachine;
            }

            if (port !== undefined) {
                localVarQueryParameter['port'] = port;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (protocolN !== undefined) {
                localVarQueryParameter['protocol__n'] = protocolN;
            }

            if (deviceIdN !== undefined) {
                localVarQueryParameter['device_id__n'] = deviceIdN;
            }

            if (deviceN !== undefined) {
                localVarQueryParameter['device__n'] = deviceN;
            }

            if (virtualMachineIdN !== undefined) {
                localVarQueryParameter['virtual_machine_id__n'] = virtualMachineIdN;
            }

            if (virtualMachineN !== undefined) {
                localVarQueryParameter['virtual_machine__n'] = virtualMachineN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesPartialUpdate: async (id: number, data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesPartialUpdate', 'data', data)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesRead', 'id', id)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesUpdate: async (id: number, data: WritableService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamServicesUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamServicesUpdate', 'data', data)
            const localVarPath = `/ipam/services/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkPartialUpdate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkUpdate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsCreate: async (data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsCreate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsDelete', 'id', id)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsList: async (id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlan-groups/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (slug !== undefined) {
                localVarQueryParameter['slug'] = slug;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (slugN !== undefined) {
                localVarQueryParameter['slug__n'] = slugN;
            }

            if (slugIc !== undefined) {
                localVarQueryParameter['slug__ic'] = slugIc;
            }

            if (slugNic !== undefined) {
                localVarQueryParameter['slug__nic'] = slugNic;
            }

            if (slugIew !== undefined) {
                localVarQueryParameter['slug__iew'] = slugIew;
            }

            if (slugNiew !== undefined) {
                localVarQueryParameter['slug__niew'] = slugNiew;
            }

            if (slugIsw !== undefined) {
                localVarQueryParameter['slug__isw'] = slugIsw;
            }

            if (slugNisw !== undefined) {
                localVarQueryParameter['slug__nisw'] = slugNisw;
            }

            if (slugIe !== undefined) {
                localVarQueryParameter['slug__ie'] = slugIe;
            }

            if (slugNie !== undefined) {
                localVarQueryParameter['slug__nie'] = slugNie;
            }

            if (descriptionN !== undefined) {
                localVarQueryParameter['description__n'] = descriptionN;
            }

            if (descriptionIc !== undefined) {
                localVarQueryParameter['description__ic'] = descriptionIc;
            }

            if (descriptionNic !== undefined) {
                localVarQueryParameter['description__nic'] = descriptionNic;
            }

            if (descriptionIew !== undefined) {
                localVarQueryParameter['description__iew'] = descriptionIew;
            }

            if (descriptionNiew !== undefined) {
                localVarQueryParameter['description__niew'] = descriptionNiew;
            }

            if (descriptionIsw !== undefined) {
                localVarQueryParameter['description__isw'] = descriptionIsw;
            }

            if (descriptionNisw !== undefined) {
                localVarQueryParameter['description__nisw'] = descriptionNisw;
            }

            if (descriptionIe !== undefined) {
                localVarQueryParameter['description__ie'] = descriptionIe;
            }

            if (descriptionNie !== undefined) {
                localVarQueryParameter['description__nie'] = descriptionNie;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsPartialUpdate: async (id: number, data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsRead', 'id', id)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsUpdate: async (id: number, data: WritableVLANGroup, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlanGroupsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlanGroupsUpdate', 'data', data)
            const localVarPath = `/ipam/vlan-groups/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkPartialUpdate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkUpdate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansCreate: async (data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansCreate', 'data', data)
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansDelete', 'id', id)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansList: async (id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vlans/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (vid !== undefined) {
                localVarQueryParameter['vid'] = vid;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (regionId !== undefined) {
                localVarQueryParameter['region_id'] = regionId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (siteId !== undefined) {
                localVarQueryParameter['site_id'] = siteId;
            }

            if (site !== undefined) {
                localVarQueryParameter['site'] = site;
            }

            if (groupId !== undefined) {
                localVarQueryParameter['group_id'] = groupId;
            }

            if (group !== undefined) {
                localVarQueryParameter['group'] = group;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role_id'] = roleId;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (vidN !== undefined) {
                localVarQueryParameter['vid__n'] = vidN;
            }

            if (vidLte !== undefined) {
                localVarQueryParameter['vid__lte'] = vidLte;
            }

            if (vidLt !== undefined) {
                localVarQueryParameter['vid__lt'] = vidLt;
            }

            if (vidGte !== undefined) {
                localVarQueryParameter['vid__gte'] = vidGte;
            }

            if (vidGt !== undefined) {
                localVarQueryParameter['vid__gt'] = vidGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (regionIdN !== undefined) {
                localVarQueryParameter['region_id__n'] = regionIdN;
            }

            if (regionN !== undefined) {
                localVarQueryParameter['region__n'] = regionN;
            }

            if (siteIdN !== undefined) {
                localVarQueryParameter['site_id__n'] = siteIdN;
            }

            if (siteN !== undefined) {
                localVarQueryParameter['site__n'] = siteN;
            }

            if (groupIdN !== undefined) {
                localVarQueryParameter['group_id__n'] = groupIdN;
            }

            if (groupN !== undefined) {
                localVarQueryParameter['group__n'] = groupN;
            }

            if (roleIdN !== undefined) {
                localVarQueryParameter['role_id__n'] = roleIdN;
            }

            if (roleN !== undefined) {
                localVarQueryParameter['role__n'] = roleN;
            }

            if (statusN !== undefined) {
                localVarQueryParameter['status__n'] = statusN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansPartialUpdate: async (id: number, data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansRead', 'id', id)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansUpdate: async (id: number, data: WritableVLAN, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVlansUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVlansUpdate', 'data', data)
            const localVarPath = `/ipam/vlans/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkDelete: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkPartialUpdate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsBulkPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkUpdate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsBulkUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsCreate: async (data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsCreate', 'data', data)
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsDelete: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsDelete', 'id', id)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsList: async (id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/ipam/vrfs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (rd !== undefined) {
                localVarQueryParameter['rd'] = rd;
            }

            if (enforceUnique !== undefined) {
                localVarQueryParameter['enforce_unique'] = enforceUnique;
            }

            if (tenantGroupId !== undefined) {
                localVarQueryParameter['tenant_group_id'] = tenantGroupId;
            }

            if (tenantGroup !== undefined) {
                localVarQueryParameter['tenant_group'] = tenantGroup;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (tenant !== undefined) {
                localVarQueryParameter['tenant'] = tenant;
            }

            if (created !== undefined) {
                localVarQueryParameter['created'] = created;
            }

            if (createdGte !== undefined) {
                localVarQueryParameter['created__gte'] = createdGte;
            }

            if (createdLte !== undefined) {
                localVarQueryParameter['created__lte'] = createdLte;
            }

            if (lastUpdated !== undefined) {
                localVarQueryParameter['last_updated'] = lastUpdated;
            }

            if (lastUpdatedGte !== undefined) {
                localVarQueryParameter['last_updated__gte'] = lastUpdatedGte;
            }

            if (lastUpdatedLte !== undefined) {
                localVarQueryParameter['last_updated__lte'] = lastUpdatedLte;
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }

            if (importTargetId !== undefined) {
                localVarQueryParameter['import_target_id'] = importTargetId;
            }

            if (importTarget !== undefined) {
                localVarQueryParameter['import_target'] = importTarget;
            }

            if (exportTargetId !== undefined) {
                localVarQueryParameter['export_target_id'] = exportTargetId;
            }

            if (exportTarget !== undefined) {
                localVarQueryParameter['export_target'] = exportTarget;
            }

            if (tag !== undefined) {
                localVarQueryParameter['tag'] = tag;
            }

            if (idN !== undefined) {
                localVarQueryParameter['id__n'] = idN;
            }

            if (idLte !== undefined) {
                localVarQueryParameter['id__lte'] = idLte;
            }

            if (idLt !== undefined) {
                localVarQueryParameter['id__lt'] = idLt;
            }

            if (idGte !== undefined) {
                localVarQueryParameter['id__gte'] = idGte;
            }

            if (idGt !== undefined) {
                localVarQueryParameter['id__gt'] = idGt;
            }

            if (nameN !== undefined) {
                localVarQueryParameter['name__n'] = nameN;
            }

            if (nameIc !== undefined) {
                localVarQueryParameter['name__ic'] = nameIc;
            }

            if (nameNic !== undefined) {
                localVarQueryParameter['name__nic'] = nameNic;
            }

            if (nameIew !== undefined) {
                localVarQueryParameter['name__iew'] = nameIew;
            }

            if (nameNiew !== undefined) {
                localVarQueryParameter['name__niew'] = nameNiew;
            }

            if (nameIsw !== undefined) {
                localVarQueryParameter['name__isw'] = nameIsw;
            }

            if (nameNisw !== undefined) {
                localVarQueryParameter['name__nisw'] = nameNisw;
            }

            if (nameIe !== undefined) {
                localVarQueryParameter['name__ie'] = nameIe;
            }

            if (nameNie !== undefined) {
                localVarQueryParameter['name__nie'] = nameNie;
            }

            if (rdN !== undefined) {
                localVarQueryParameter['rd__n'] = rdN;
            }

            if (rdIc !== undefined) {
                localVarQueryParameter['rd__ic'] = rdIc;
            }

            if (rdNic !== undefined) {
                localVarQueryParameter['rd__nic'] = rdNic;
            }

            if (rdIew !== undefined) {
                localVarQueryParameter['rd__iew'] = rdIew;
            }

            if (rdNiew !== undefined) {
                localVarQueryParameter['rd__niew'] = rdNiew;
            }

            if (rdIsw !== undefined) {
                localVarQueryParameter['rd__isw'] = rdIsw;
            }

            if (rdNisw !== undefined) {
                localVarQueryParameter['rd__nisw'] = rdNisw;
            }

            if (rdIe !== undefined) {
                localVarQueryParameter['rd__ie'] = rdIe;
            }

            if (rdNie !== undefined) {
                localVarQueryParameter['rd__nie'] = rdNie;
            }

            if (tenantGroupIdN !== undefined) {
                localVarQueryParameter['tenant_group_id__n'] = tenantGroupIdN;
            }

            if (tenantGroupN !== undefined) {
                localVarQueryParameter['tenant_group__n'] = tenantGroupN;
            }

            if (tenantIdN !== undefined) {
                localVarQueryParameter['tenant_id__n'] = tenantIdN;
            }

            if (tenantN !== undefined) {
                localVarQueryParameter['tenant__n'] = tenantN;
            }

            if (importTargetIdN !== undefined) {
                localVarQueryParameter['import_target_id__n'] = importTargetIdN;
            }

            if (importTargetN !== undefined) {
                localVarQueryParameter['import_target__n'] = importTargetN;
            }

            if (exportTargetIdN !== undefined) {
                localVarQueryParameter['export_target_id__n'] = exportTargetIdN;
            }

            if (exportTargetN !== undefined) {
                localVarQueryParameter['export_target__n'] = exportTargetN;
            }

            if (tagN !== undefined) {
                localVarQueryParameter['tag__n'] = tagN;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsPartialUpdate: async (id: number, data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsPartialUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsPartialUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsRead: async (id: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsRead', 'id', id)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsUpdate: async (id: number, data: WritableVRF, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ipamVrfsUpdate', 'id', id)
            // verify required parameter 'data' is not null or undefined
            assertParamExists('ipamVrfsUpdate', 'data', data)
            const localVarPath = `/ipam/vrfs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Bearer required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(data, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IpamApi - functional programming interface
 * @export
 */
export const IpamApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IpamApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkPartialUpdate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesBulkUpdate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesCreate(data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesList(id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20045>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesList(id, dateAdded, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, rirId, rir, tag, idN, idLte, idLt, idGte, idGt, dateAddedN, dateAddedLte, dateAddedLt, dateAddedGte, dateAddedGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rirIdN, rirN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesPartialUpdate(id: number, data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamAggregatesUpdate(id: number, data: WritableAggregate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Aggregate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamAggregatesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkPartialUpdate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesBulkUpdate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesCreate(data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesList(id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20046>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesList(id, dnsName, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, parent, address, maskLength, vrfId, vrf, presentInVrfId, presentInVrf, device, deviceId, virtualMachine, virtualMachineId, _interface, interfaceId, vminterface, vminterfaceId, assignedToInterface, status, role, tag, idN, idLte, idLt, idGte, idGt, dnsNameN, dnsNameIc, dnsNameNic, dnsNameIew, dnsNameNiew, dnsNameIsw, dnsNameNisw, dnsNameIe, dnsNameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, interfaceN, interfaceIdN, vminterfaceN, vminterfaceIdN, statusN, roleN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesPartialUpdate(id: number, data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamIpAddressesUpdate(id: number, data: WritableIPAddress, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IPAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamIpAddressesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailableIpsCreate(id: number, data: WritableAvailableIP, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableIP>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailableIpsCreate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailableIpsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailableIP>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailableIpsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailablePrefixesCreate(id: number, data: PrefixLength, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailablePrefixesCreate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesAvailablePrefixesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AvailablePrefix>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesAvailablePrefixesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkPartialUpdate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesBulkUpdate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesCreate(data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesList(id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20047>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesList(id, isPool, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, within, withinInclude, contains, maskLength, maskLengthGte, maskLengthLte, vrfId, vrf, presentInVrfId, presentInVrf, regionId, region, siteId, site, vlanId, vlanVid, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, regionIdN, regionN, siteIdN, siteN, vlanIdN, roleIdN, roleN, statusN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesPartialUpdate(id: number, data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamPrefixesUpdate(id: number, data: WritablePrefix, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Prefix>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamPrefixesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkPartialUpdate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsBulkUpdate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsCreate(data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsList(id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20048>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsList(id, name, slug, isPrivate, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsPartialUpdate(id: number, data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRirsUpdate(id: number, data: RIR, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RIR>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRirsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkPartialUpdate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesBulkUpdate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesCreate(data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20049>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesPartialUpdate(id: number, data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRolesUpdate(id: number, data: Role, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRolesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkPartialUpdate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsBulkUpdate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsCreate(data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20050>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importingVrfId, importingVrf, exportingVrfId, exportingVrf, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importingVrfIdN, importingVrfN, exportingVrfIdN, exportingVrfN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsPartialUpdate(id: number, data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamRouteTargetsUpdate(id: number, data: WritableRouteTarget, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouteTarget>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamRouteTargetsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkPartialUpdate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesBulkUpdate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesCreate(data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesList(id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20051>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesList(id, name, protocol, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, deviceId, device, virtualMachineId, virtualMachine, port, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, protocolN, deviceIdN, deviceN, virtualMachineIdN, virtualMachineN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesPartialUpdate(id: number, data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamServicesUpdate(id: number, data: WritableService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamServicesUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkPartialUpdate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsBulkUpdate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsCreate(data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20052>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsList(id, name, slug, description, q, regionId, region, siteId, site, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsPartialUpdate(id: number, data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlanGroupsUpdate(id: number, data: WritableVLANGroup, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLANGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlanGroupsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkPartialUpdate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansBulkUpdate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansCreate(data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansList(id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20053>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansList(id, vid, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, vidN, vidLte, vidLt, vidGte, vidGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, roleIdN, roleN, statusN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansPartialUpdate(id: number, data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVlansUpdate(id: number, data: WritableVLAN, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VLAN>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVlansUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkDelete(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkDelete(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkPartialUpdate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkPartialUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsBulkUpdate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsBulkUpdate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsCreate(data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsCreate(data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsDelete(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsList(id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20054>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsList(id, name, rd, enforceUnique, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importTargetId, importTarget, exportTargetId, exportTarget, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, rdN, rdIc, rdNic, rdIew, rdNiew, rdIsw, rdNisw, rdIe, rdNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importTargetIdN, importTargetN, exportTargetIdN, exportTargetN, tagN, limit, offset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsPartialUpdate(id: number, data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsPartialUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsRead(id: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsRead(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ipamVrfsUpdate(id: number, data: WritableVRF, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VRF>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ipamVrfsUpdate(id, data, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IpamApi - factory interface
 * @export
 */
export const IpamApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IpamApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamAggregatesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkPartialUpdate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesBulkUpdate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesCreate(data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamAggregatesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dateAdded] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [rirId] 
         * @param {string} [rir] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dateAddedN] 
         * @param {string} [dateAddedLte] 
         * @param {string} [dateAddedLt] 
         * @param {string} [dateAddedGte] 
         * @param {string} [dateAddedGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [rirIdN] 
         * @param {string} [rirN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesList(id?: string, dateAdded?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, rirId?: string, rir?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dateAddedN?: string, dateAddedLte?: string, dateAddedLt?: string, dateAddedGte?: string, dateAddedGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, rirIdN?: string, rirN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20045> {
            return localVarFp.ipamAggregatesList(id, dateAdded, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, rirId, rir, tag, idN, idLte, idLt, idGte, idGt, dateAddedN, dateAddedLte, dateAddedLt, dateAddedGte, dateAddedGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, rirIdN, rirN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesPartialUpdate(id: number, data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesRead(id: number, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this aggregate.
         * @param {WritableAggregate} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamAggregatesUpdate(id: number, data: WritableAggregate, options?: any): AxiosPromise<Aggregate> {
            return localVarFp.ipamAggregatesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamIpAddressesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkPartialUpdate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesBulkUpdate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesCreate(data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamIpAddressesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [dnsName] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [parent] 
         * @param {string} [address] 
         * @param {number} [maskLength] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [device] 
         * @param {string} [deviceId] 
         * @param {string} [virtualMachine] 
         * @param {string} [virtualMachineId] 
         * @param {string} [_interface] 
         * @param {string} [interfaceId] 
         * @param {string} [vminterface] 
         * @param {string} [vminterfaceId] 
         * @param {string} [assignedToInterface] 
         * @param {string} [status] 
         * @param {string} [role] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [dnsNameN] 
         * @param {string} [dnsNameIc] 
         * @param {string} [dnsNameNic] 
         * @param {string} [dnsNameIew] 
         * @param {string} [dnsNameNiew] 
         * @param {string} [dnsNameIsw] 
         * @param {string} [dnsNameNisw] 
         * @param {string} [dnsNameIe] 
         * @param {string} [dnsNameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [interfaceN] 
         * @param {string} [interfaceIdN] 
         * @param {string} [vminterfaceN] 
         * @param {string} [vminterfaceIdN] 
         * @param {string} [statusN] 
         * @param {string} [roleN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesList(id?: string, dnsName?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, parent?: string, address?: string, maskLength?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, device?: string, deviceId?: string, virtualMachine?: string, virtualMachineId?: string, _interface?: string, interfaceId?: string, vminterface?: string, vminterfaceId?: string, assignedToInterface?: string, status?: string, role?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, dnsNameN?: string, dnsNameIc?: string, dnsNameNic?: string, dnsNameIew?: string, dnsNameNiew?: string, dnsNameIsw?: string, dnsNameNisw?: string, dnsNameIe?: string, dnsNameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, interfaceN?: string, interfaceIdN?: string, vminterfaceN?: string, vminterfaceIdN?: string, statusN?: string, roleN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20046> {
            return localVarFp.ipamIpAddressesList(id, dnsName, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, parent, address, maskLength, vrfId, vrf, presentInVrfId, presentInVrf, device, deviceId, virtualMachine, virtualMachineId, _interface, interfaceId, vminterface, vminterfaceId, assignedToInterface, status, role, tag, idN, idLte, idLt, idGte, idGt, dnsNameN, dnsNameIc, dnsNameNic, dnsNameIew, dnsNameNiew, dnsNameIsw, dnsNameNisw, dnsNameIe, dnsNameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, interfaceN, interfaceIdN, vminterfaceN, vminterfaceIdN, statusN, roleN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesPartialUpdate(id: number, data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesRead(id: number, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this IP address.
         * @param {WritableIPAddress} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamIpAddressesUpdate(id: number, data: WritableIPAddress, options?: any): AxiosPromise<IPAddress> {
            return localVarFp.ipamIpAddressesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritableAvailableIP} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsCreate(id: number, data: WritableAvailableIP, options?: any): AxiosPromise<Array<AvailableIP>> {
            return localVarFp.ipamPrefixesAvailableIpsCreate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailableIpsRead(id: number, options?: any): AxiosPromise<Array<AvailableIP>> {
            return localVarFp.ipamPrefixesAvailableIpsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {PrefixLength} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesCreate(id: number, data: PrefixLength, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesAvailablePrefixesCreate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
         * @summary A convenience method for returning available child prefixes within a parent.
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesAvailablePrefixesRead(id: number, options?: any): AxiosPromise<Array<AvailablePrefix>> {
            return localVarFp.ipamPrefixesAvailablePrefixesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamPrefixesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkPartialUpdate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesBulkUpdate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesCreate(data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamPrefixesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [isPool] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {number} [family] 
         * @param {string} [prefix] 
         * @param {string} [within] 
         * @param {string} [withinInclude] 
         * @param {string} [contains] 
         * @param {number} [maskLength] 
         * @param {number} [maskLengthGte] 
         * @param {number} [maskLengthLte] 
         * @param {string} [vrfId] 
         * @param {string} [vrf] 
         * @param {string} [presentInVrfId] 
         * @param {string} [presentInVrf] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [vlanId] 
         * @param {number} [vlanVid] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [vrfIdN] 
         * @param {string} [vrfN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [vlanIdN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesList(id?: string, isPool?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, family?: number, prefix?: string, within?: string, withinInclude?: string, contains?: string, maskLength?: number, maskLengthGte?: number, maskLengthLte?: number, vrfId?: string, vrf?: string, presentInVrfId?: string, presentInVrf?: string, regionId?: string, region?: string, siteId?: string, site?: string, vlanId?: string, vlanVid?: number, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, vrfIdN?: string, vrfN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, vlanIdN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20047> {
            return localVarFp.ipamPrefixesList(id, isPool, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, family, prefix, within, withinInclude, contains, maskLength, maskLengthGte, maskLengthLte, vrfId, vrf, presentInVrfId, presentInVrf, regionId, region, siteId, site, vlanId, vlanVid, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, vrfIdN, vrfN, regionIdN, regionN, siteIdN, siteN, vlanIdN, roleIdN, roleN, statusN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesPartialUpdate(id: number, data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesRead(id: number, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this prefix.
         * @param {WritablePrefix} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamPrefixesUpdate(id: number, data: WritablePrefix, options?: any): AxiosPromise<Prefix> {
            return localVarFp.ipamPrefixesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRirsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkPartialUpdate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsBulkUpdate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsCreate(data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRirsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [isPrivate] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsList(id?: string, name?: string, slug?: string, isPrivate?: string, description?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20048> {
            return localVarFp.ipamRirsList(id, name, slug, isPrivate, description, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsPartialUpdate(id: number, data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsRead(id: number, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this RIR.
         * @param {RIR} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRirsUpdate(id: number, data: RIR, options?: any): AxiosPromise<RIR> {
            return localVarFp.ipamRirsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRolesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkPartialUpdate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesBulkUpdate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesCreate(data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRolesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [q] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesList(id?: string, name?: string, slug?: string, q?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20049> {
            return localVarFp.ipamRolesList(id, name, slug, q, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesPartialUpdate(id: number, data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesRead(id: number, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this role.
         * @param {Role} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRolesUpdate(id: number, data: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.ipamRolesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamRouteTargetsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkPartialUpdate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsBulkUpdate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsCreate(data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamRouteTargetsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importingVrfId] 
         * @param {string} [importingVrf] 
         * @param {string} [exportingVrfId] 
         * @param {string} [exportingVrf] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importingVrfIdN] 
         * @param {string} [importingVrfN] 
         * @param {string} [exportingVrfIdN] 
         * @param {string} [exportingVrfN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsList(id?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importingVrfId?: string, importingVrf?: string, exportingVrfId?: string, exportingVrf?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importingVrfIdN?: string, importingVrfN?: string, exportingVrfIdN?: string, exportingVrfN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20050> {
            return localVarFp.ipamRouteTargetsList(id, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importingVrfId, importingVrf, exportingVrfId, exportingVrf, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importingVrfIdN, importingVrfN, exportingVrfIdN, exportingVrfN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsPartialUpdate(id: number, data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsRead(id: number, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this route target.
         * @param {WritableRouteTarget} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamRouteTargetsUpdate(id: number, data: WritableRouteTarget, options?: any): AxiosPromise<RouteTarget> {
            return localVarFp.ipamRouteTargetsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamServicesBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkPartialUpdate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesBulkUpdate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesCreate(data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamServicesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [protocol] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [deviceId] 
         * @param {string} [device] 
         * @param {string} [virtualMachineId] 
         * @param {string} [virtualMachine] 
         * @param {number} [port] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [protocolN] 
         * @param {string} [deviceIdN] 
         * @param {string} [deviceN] 
         * @param {string} [virtualMachineIdN] 
         * @param {string} [virtualMachineN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesList(id?: string, name?: string, protocol?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, deviceId?: string, device?: string, virtualMachineId?: string, virtualMachine?: string, port?: number, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, protocolN?: string, deviceIdN?: string, deviceN?: string, virtualMachineIdN?: string, virtualMachineN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20051> {
            return localVarFp.ipamServicesList(id, name, protocol, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, deviceId, device, virtualMachineId, virtualMachine, port, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, protocolN, deviceIdN, deviceN, virtualMachineIdN, virtualMachineN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesPartialUpdate(id: number, data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesRead(id: number, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this service.
         * @param {WritableService} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamServicesUpdate(id: number, data: WritableService, options?: any): AxiosPromise<Service> {
            return localVarFp.ipamServicesUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlanGroupsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkPartialUpdate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsBulkUpdate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsCreate(data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlanGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [slug] 
         * @param {string} [description] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [slugN] 
         * @param {string} [slugIc] 
         * @param {string} [slugNic] 
         * @param {string} [slugIew] 
         * @param {string} [slugNiew] 
         * @param {string} [slugIsw] 
         * @param {string} [slugNisw] 
         * @param {string} [slugIe] 
         * @param {string} [slugNie] 
         * @param {string} [descriptionN] 
         * @param {string} [descriptionIc] 
         * @param {string} [descriptionNic] 
         * @param {string} [descriptionIew] 
         * @param {string} [descriptionNiew] 
         * @param {string} [descriptionIsw] 
         * @param {string} [descriptionNisw] 
         * @param {string} [descriptionIe] 
         * @param {string} [descriptionNie] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsList(id?: string, name?: string, slug?: string, description?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, slugN?: string, slugIc?: string, slugNic?: string, slugIew?: string, slugNiew?: string, slugIsw?: string, slugNisw?: string, slugIe?: string, slugNie?: string, descriptionN?: string, descriptionIc?: string, descriptionNic?: string, descriptionIew?: string, descriptionNiew?: string, descriptionIsw?: string, descriptionNisw?: string, descriptionIe?: string, descriptionNie?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20052> {
            return localVarFp.ipamVlanGroupsList(id, name, slug, description, q, regionId, region, siteId, site, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, slugN, slugIc, slugNic, slugIew, slugNiew, slugIsw, slugNisw, slugIe, slugNie, descriptionN, descriptionIc, descriptionNic, descriptionIew, descriptionNiew, descriptionIsw, descriptionNisw, descriptionIe, descriptionNie, regionIdN, regionN, siteIdN, siteN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsPartialUpdate(id: number, data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsRead(id: number, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN group.
         * @param {WritableVLANGroup} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlanGroupsUpdate(id: number, data: WritableVLANGroup, options?: any): AxiosPromise<VLANGroup> {
            return localVarFp.ipamVlanGroupsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlansBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkPartialUpdate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansBulkUpdate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansCreate(data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVlansDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [vid] 
         * @param {string} [name] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [regionId] 
         * @param {string} [region] 
         * @param {string} [siteId] 
         * @param {string} [site] 
         * @param {string} [groupId] 
         * @param {string} [group] 
         * @param {string} [roleId] 
         * @param {string} [role] 
         * @param {string} [status] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [vidN] 
         * @param {string} [vidLte] 
         * @param {string} [vidLt] 
         * @param {string} [vidGte] 
         * @param {string} [vidGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [regionIdN] 
         * @param {string} [regionN] 
         * @param {string} [siteIdN] 
         * @param {string} [siteN] 
         * @param {string} [groupIdN] 
         * @param {string} [groupN] 
         * @param {string} [roleIdN] 
         * @param {string} [roleN] 
         * @param {string} [statusN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansList(id?: string, vid?: string, name?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, regionId?: string, region?: string, siteId?: string, site?: string, groupId?: string, group?: string, roleId?: string, role?: string, status?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, vidN?: string, vidLte?: string, vidLt?: string, vidGte?: string, vidGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, regionIdN?: string, regionN?: string, siteIdN?: string, siteN?: string, groupIdN?: string, groupN?: string, roleIdN?: string, roleN?: string, statusN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20053> {
            return localVarFp.ipamVlansList(id, vid, name, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, regionId, region, siteId, site, groupId, group, roleId, role, status, tag, idN, idLte, idLt, idGte, idGt, vidN, vidLte, vidLt, vidGte, vidGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, regionIdN, regionN, siteIdN, siteN, groupIdN, groupN, roleIdN, roleN, statusN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansPartialUpdate(id: number, data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansRead(id: number, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VLAN.
         * @param {WritableVLAN} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVlansUpdate(id: number, data: WritableVLAN, options?: any): AxiosPromise<VLAN> {
            return localVarFp.ipamVlansUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkDelete(options?: any): AxiosPromise<void> {
            return localVarFp.ipamVrfsBulkDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkPartialUpdate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsBulkPartialUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsBulkUpdate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsBulkUpdate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsCreate(data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsCreate(data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsDelete(id: number, options?: any): AxiosPromise<void> {
            return localVarFp.ipamVrfsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] 
         * @param {string} [name] 
         * @param {string} [rd] 
         * @param {string} [enforceUnique] 
         * @param {string} [tenantGroupId] 
         * @param {string} [tenantGroup] 
         * @param {string} [tenantId] 
         * @param {string} [tenant] 
         * @param {string} [created] 
         * @param {string} [createdGte] 
         * @param {string} [createdLte] 
         * @param {string} [lastUpdated] 
         * @param {string} [lastUpdatedGte] 
         * @param {string} [lastUpdatedLte] 
         * @param {string} [q] 
         * @param {string} [importTargetId] 
         * @param {string} [importTarget] 
         * @param {string} [exportTargetId] 
         * @param {string} [exportTarget] 
         * @param {string} [tag] 
         * @param {string} [idN] 
         * @param {string} [idLte] 
         * @param {string} [idLt] 
         * @param {string} [idGte] 
         * @param {string} [idGt] 
         * @param {string} [nameN] 
         * @param {string} [nameIc] 
         * @param {string} [nameNic] 
         * @param {string} [nameIew] 
         * @param {string} [nameNiew] 
         * @param {string} [nameIsw] 
         * @param {string} [nameNisw] 
         * @param {string} [nameIe] 
         * @param {string} [nameNie] 
         * @param {string} [rdN] 
         * @param {string} [rdIc] 
         * @param {string} [rdNic] 
         * @param {string} [rdIew] 
         * @param {string} [rdNiew] 
         * @param {string} [rdIsw] 
         * @param {string} [rdNisw] 
         * @param {string} [rdIe] 
         * @param {string} [rdNie] 
         * @param {string} [tenantGroupIdN] 
         * @param {string} [tenantGroupN] 
         * @param {string} [tenantIdN] 
         * @param {string} [tenantN] 
         * @param {string} [importTargetIdN] 
         * @param {string} [importTargetN] 
         * @param {string} [exportTargetIdN] 
         * @param {string} [exportTargetN] 
         * @param {string} [tagN] 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsList(id?: string, name?: string, rd?: string, enforceUnique?: string, tenantGroupId?: string, tenantGroup?: string, tenantId?: string, tenant?: string, created?: string, createdGte?: string, createdLte?: string, lastUpdated?: string, lastUpdatedGte?: string, lastUpdatedLte?: string, q?: string, importTargetId?: string, importTarget?: string, exportTargetId?: string, exportTarget?: string, tag?: string, idN?: string, idLte?: string, idLt?: string, idGte?: string, idGt?: string, nameN?: string, nameIc?: string, nameNic?: string, nameIew?: string, nameNiew?: string, nameIsw?: string, nameNisw?: string, nameIe?: string, nameNie?: string, rdN?: string, rdIc?: string, rdNic?: string, rdIew?: string, rdNiew?: string, rdIsw?: string, rdNisw?: string, rdIe?: string, rdNie?: string, tenantGroupIdN?: string, tenantGroupN?: string, tenantIdN?: string, tenantN?: string, importTargetIdN?: string, importTargetN?: string, exportTargetIdN?: string, exportTargetN?: string, tagN?: string, limit?: number, offset?: number, options?: any): AxiosPromise<InlineResponse20054> {
            return localVarFp.ipamVrfsList(id, name, rd, enforceUnique, tenantGroupId, tenantGroup, tenantId, tenant, created, createdGte, createdLte, lastUpdated, lastUpdatedGte, lastUpdatedLte, q, importTargetId, importTarget, exportTargetId, exportTarget, tag, idN, idLte, idLt, idGte, idGt, nameN, nameIc, nameNic, nameIew, nameNiew, nameIsw, nameNisw, nameIe, nameNie, rdN, rdIc, rdNic, rdIew, rdNiew, rdIsw, rdNisw, rdIe, rdNie, tenantGroupIdN, tenantGroupN, tenantIdN, tenantN, importTargetIdN, importTargetN, exportTargetIdN, exportTargetN, tagN, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsPartialUpdate(id: number, data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsPartialUpdate(id, data, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsRead(id: number, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsRead(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id A unique integer value identifying this VRF.
         * @param {WritableVRF} data 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ipamVrfsUpdate(id: number, data: WritableVRF, options?: any): AxiosPromise<VRF> {
            return localVarFp.ipamVrfsUpdate(id, data, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for ipamAggregatesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesBulkPartialUpdateRequest
 */
export interface IpamApiIpamAggregatesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesBulkPartialUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesBulkUpdateRequest
 */
export interface IpamApiIpamAggregatesBulkUpdateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesBulkUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesCreateRequest
 */
export interface IpamApiIpamAggregatesCreateRequest {
    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesCreate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesDeleteRequest
 */
export interface IpamApiIpamAggregatesDeleteRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamAggregatesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesListRequest
 */
export interface IpamApiIpamAggregatesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAdded?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly prefix?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rir?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly dateAddedGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly rirN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamAggregatesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamAggregatesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesPartialUpdateRequest
 */
export interface IpamApiIpamAggregatesPartialUpdateRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesPartialUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamAggregatesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesReadRequest
 */
export interface IpamApiIpamAggregatesReadRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamAggregatesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamAggregatesUpdateRequest
 */
export interface IpamApiIpamAggregatesUpdateRequest {
    /**
     * A unique integer value identifying this aggregate.
     * @type {number}
     * @memberof IpamApiIpamAggregatesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAggregate}
     * @memberof IpamApiIpamAggregatesUpdate
     */
    readonly data: WritableAggregate
}

/**
 * Request parameters for ipamIpAddressesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesBulkPartialUpdateRequest
 */
export interface IpamApiIpamIpAddressesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesBulkPartialUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesBulkUpdateRequest
 */
export interface IpamApiIpamIpAddressesBulkUpdateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesBulkUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesCreateRequest
 */
export interface IpamApiIpamIpAddressesCreateRequest {
    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesCreate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesDeleteRequest
 */
export interface IpamApiIpamIpAddressesDeleteRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamIpAddressesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesListRequest
 */
export interface IpamApiIpamIpAddressesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsName?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly parent?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly address?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly maskLength?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly presentInVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly presentInVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly _interface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly assignedToInterface?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly dnsNameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly interfaceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly vminterfaceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamIpAddressesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesPartialUpdateRequest
 */
export interface IpamApiIpamIpAddressesPartialUpdateRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesPartialUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamIpAddressesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesReadRequest
 */
export interface IpamApiIpamIpAddressesReadRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamIpAddressesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamIpAddressesUpdateRequest
 */
export interface IpamApiIpamIpAddressesUpdateRequest {
    /**
     * A unique integer value identifying this IP address.
     * @type {number}
     * @memberof IpamApiIpamIpAddressesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableIPAddress}
     * @memberof IpamApiIpamIpAddressesUpdate
     */
    readonly data: WritableIPAddress
}

/**
 * Request parameters for ipamPrefixesAvailableIpsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailableIpsCreateRequest
 */
export interface IpamApiIpamPrefixesAvailableIpsCreateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailableIpsCreate
     */
    readonly id: number

    /**
     * 
     * @type {WritableAvailableIP}
     * @memberof IpamApiIpamPrefixesAvailableIpsCreate
     */
    readonly data: WritableAvailableIP
}

/**
 * Request parameters for ipamPrefixesAvailableIpsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailableIpsReadRequest
 */
export interface IpamApiIpamPrefixesAvailableIpsReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailableIpsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesAvailablePrefixesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailablePrefixesCreateRequest
 */
export interface IpamApiIpamPrefixesAvailablePrefixesCreateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesCreate
     */
    readonly id: number

    /**
     * 
     * @type {PrefixLength}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesCreate
     */
    readonly data: PrefixLength
}

/**
 * Request parameters for ipamPrefixesAvailablePrefixesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesAvailablePrefixesReadRequest
 */
export interface IpamApiIpamPrefixesAvailablePrefixesReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesAvailablePrefixesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesBulkPartialUpdateRequest
 */
export interface IpamApiIpamPrefixesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesBulkPartialUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesBulkUpdateRequest
 */
export interface IpamApiIpamPrefixesBulkUpdateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesBulkUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesCreateRequest
 */
export interface IpamApiIpamPrefixesCreateRequest {
    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesCreate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesDeleteRequest
 */
export interface IpamApiIpamPrefixesDeleteRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesListRequest
 */
export interface IpamApiIpamPrefixesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly isPool?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly q?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly family?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly prefix?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly within?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly withinInclude?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly contains?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLength?: number

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLengthGte?: number

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly maskLengthLte?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly presentInVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly presentInVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanId?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanVid?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly vlanIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamPrefixesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamPrefixesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesPartialUpdateRequest
 */
export interface IpamApiIpamPrefixesPartialUpdateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesPartialUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamPrefixesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesReadRequest
 */
export interface IpamApiIpamPrefixesReadRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamPrefixesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamPrefixesUpdateRequest
 */
export interface IpamApiIpamPrefixesUpdateRequest {
    /**
     * A unique integer value identifying this prefix.
     * @type {number}
     * @memberof IpamApiIpamPrefixesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritablePrefix}
     * @memberof IpamApiIpamPrefixesUpdate
     */
    readonly data: WritablePrefix
}

/**
 * Request parameters for ipamRirsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsBulkPartialUpdateRequest
 */
export interface IpamApiIpamRirsBulkPartialUpdateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsBulkPartialUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsBulkUpdateRequest
 */
export interface IpamApiIpamRirsBulkUpdateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsBulkUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsCreateRequest
 */
export interface IpamApiIpamRirsCreateRequest {
    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsCreate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsDeleteRequest
 */
export interface IpamApiIpamRirsDeleteRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRirsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsListRequest
 */
export interface IpamApiIpamRirsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly isPrivate?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRirsList
     */
    readonly descriptionNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRirsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRirsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRirsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsPartialUpdateRequest
 */
export interface IpamApiIpamRirsPartialUpdateRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsPartialUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRirsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsReadRequest
 */
export interface IpamApiIpamRirsReadRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRirsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRirsUpdateRequest
 */
export interface IpamApiIpamRirsUpdateRequest {
    /**
     * A unique integer value identifying this RIR.
     * @type {number}
     * @memberof IpamApiIpamRirsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {RIR}
     * @memberof IpamApiIpamRirsUpdate
     */
    readonly data: RIR
}

/**
 * Request parameters for ipamRolesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesBulkPartialUpdateRequest
 */
export interface IpamApiIpamRolesBulkPartialUpdateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesBulkPartialUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesBulkUpdateRequest
 */
export interface IpamApiIpamRolesBulkUpdateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesBulkUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesCreateRequest
 */
export interface IpamApiIpamRolesCreateRequest {
    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesCreate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesDeleteRequest
 */
export interface IpamApiIpamRolesDeleteRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRolesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesListRequest
 */
export interface IpamApiIpamRolesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRolesList
     */
    readonly slugNie?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRolesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRolesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRolesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesPartialUpdateRequest
 */
export interface IpamApiIpamRolesPartialUpdateRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesPartialUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRolesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesReadRequest
 */
export interface IpamApiIpamRolesReadRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRolesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRolesUpdateRequest
 */
export interface IpamApiIpamRolesUpdateRequest {
    /**
     * A unique integer value identifying this role.
     * @type {number}
     * @memberof IpamApiIpamRolesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {Role}
     * @memberof IpamApiIpamRolesUpdate
     */
    readonly data: Role
}

/**
 * Request parameters for ipamRouteTargetsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsBulkPartialUpdateRequest
 */
export interface IpamApiIpamRouteTargetsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsBulkPartialUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsBulkUpdateRequest
 */
export interface IpamApiIpamRouteTargetsBulkUpdateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsBulkUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsCreateRequest
 */
export interface IpamApiIpamRouteTargetsCreateRequest {
    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsCreate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsDeleteRequest
 */
export interface IpamApiIpamRouteTargetsDeleteRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamRouteTargetsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsListRequest
 */
export interface IpamApiIpamRouteTargetsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrf?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly importingVrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly exportingVrfN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamRouteTargetsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsPartialUpdateRequest
 */
export interface IpamApiIpamRouteTargetsPartialUpdateRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsPartialUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamRouteTargetsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsReadRequest
 */
export interface IpamApiIpamRouteTargetsReadRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamRouteTargetsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamRouteTargetsUpdateRequest
 */
export interface IpamApiIpamRouteTargetsUpdateRequest {
    /**
     * A unique integer value identifying this route target.
     * @type {number}
     * @memberof IpamApiIpamRouteTargetsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableRouteTarget}
     * @memberof IpamApiIpamRouteTargetsUpdate
     */
    readonly data: WritableRouteTarget
}

/**
 * Request parameters for ipamServicesBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesBulkPartialUpdateRequest
 */
export interface IpamApiIpamServicesBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesBulkPartialUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesBulkUpdateRequest
 */
export interface IpamApiIpamServicesBulkUpdateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesBulkUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesCreateRequest
 */
export interface IpamApiIpamServicesCreateRequest {
    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesCreate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesDeleteRequest
 */
export interface IpamApiIpamServicesDeleteRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamServicesList operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesListRequest
 */
export interface IpamApiIpamServicesListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly protocol?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly device?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachine?: string

    /**
     * 
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly port?: number

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly protocolN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly deviceN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly virtualMachineN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamServicesList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamServicesList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamServicesPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesPartialUpdateRequest
 */
export interface IpamApiIpamServicesPartialUpdateRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesPartialUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamServicesRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesReadRequest
 */
export interface IpamApiIpamServicesReadRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamServicesUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamServicesUpdateRequest
 */
export interface IpamApiIpamServicesUpdateRequest {
    /**
     * A unique integer value identifying this service.
     * @type {number}
     * @memberof IpamApiIpamServicesUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableService}
     * @memberof IpamApiIpamServicesUpdate
     */
    readonly data: WritableService
}

/**
 * Request parameters for ipamVlanGroupsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsBulkPartialUpdateRequest
 */
export interface IpamApiIpamVlanGroupsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsBulkPartialUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsBulkUpdateRequest
 */
export interface IpamApiIpamVlanGroupsBulkUpdateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsBulkUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsCreateRequest
 */
export interface IpamApiIpamVlanGroupsCreateRequest {
    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsCreate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsDeleteRequest
 */
export interface IpamApiIpamVlanGroupsDeleteRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlanGroupsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsListRequest
 */
export interface IpamApiIpamVlanGroupsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slug?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly description?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly slugNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly descriptionNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly siteN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVlanGroupsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsPartialUpdateRequest
 */
export interface IpamApiIpamVlanGroupsPartialUpdateRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsPartialUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlanGroupsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsReadRequest
 */
export interface IpamApiIpamVlanGroupsReadRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlanGroupsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlanGroupsUpdateRequest
 */
export interface IpamApiIpamVlanGroupsUpdateRequest {
    /**
     * A unique integer value identifying this VLAN group.
     * @type {number}
     * @memberof IpamApiIpamVlanGroupsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLANGroup}
     * @memberof IpamApiIpamVlanGroupsUpdate
     */
    readonly data: WritableVLANGroup
}

/**
 * Request parameters for ipamVlansBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansBulkPartialUpdateRequest
 */
export interface IpamApiIpamVlansBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansBulkPartialUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansBulkUpdateRequest
 */
export interface IpamApiIpamVlansBulkUpdateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansBulkUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansCreateRequest
 */
export interface IpamApiIpamVlansCreateRequest {
    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansCreate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansDeleteRequest
 */
export interface IpamApiIpamVlansDeleteRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlansList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansListRequest
 */
export interface IpamApiIpamVlansListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vid?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly region?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly site?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly group?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly role?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly status?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly vidGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly regionN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly siteN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly groupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly roleN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly statusN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVlansList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVlansList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVlansList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVlansPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansPartialUpdateRequest
 */
export interface IpamApiIpamVlansPartialUpdateRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansPartialUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVlansRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansReadRequest
 */
export interface IpamApiIpamVlansReadRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVlansUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVlansUpdateRequest
 */
export interface IpamApiIpamVlansUpdateRequest {
    /**
     * A unique integer value identifying this VLAN.
     * @type {number}
     * @memberof IpamApiIpamVlansUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVLAN}
     * @memberof IpamApiIpamVlansUpdate
     */
    readonly data: WritableVLAN
}

/**
 * Request parameters for ipamVrfsBulkPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsBulkPartialUpdateRequest
 */
export interface IpamApiIpamVrfsBulkPartialUpdateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsBulkPartialUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsBulkUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsBulkUpdateRequest
 */
export interface IpamApiIpamVrfsBulkUpdateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsBulkUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsCreate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsCreateRequest
 */
export interface IpamApiIpamVrfsCreateRequest {
    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsCreate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsDelete operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsDeleteRequest
 */
export interface IpamApiIpamVrfsDeleteRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsDelete
     */
    readonly id: number
}

/**
 * Request parameters for ipamVrfsList operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsListRequest
 */
export interface IpamApiIpamVrfsListRequest {
    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly id?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rd?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly enforceUnique?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroup?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenant?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly created?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly createdGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly createdLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdated?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdatedGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly lastUpdatedLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly q?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTarget?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetId?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTarget?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tag?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idLte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idLt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idGte?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly idGt?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly nameNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIc?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNic?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNiew?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIsw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNisw?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdIe?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly rdNie?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantGroupN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tenantN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly importTargetN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetIdN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly exportTargetN?: string

    /**
     * 
     * @type {string}
     * @memberof IpamApiIpamVrfsList
     */
    readonly tagN?: string

    /**
     * Number of results to return per page.
     * @type {number}
     * @memberof IpamApiIpamVrfsList
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     * @type {number}
     * @memberof IpamApiIpamVrfsList
     */
    readonly offset?: number
}

/**
 * Request parameters for ipamVrfsPartialUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsPartialUpdateRequest
 */
export interface IpamApiIpamVrfsPartialUpdateRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsPartialUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsPartialUpdate
     */
    readonly data: WritableVRF
}

/**
 * Request parameters for ipamVrfsRead operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsReadRequest
 */
export interface IpamApiIpamVrfsReadRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsRead
     */
    readonly id: number
}

/**
 * Request parameters for ipamVrfsUpdate operation in IpamApi.
 * @export
 * @interface IpamApiIpamVrfsUpdateRequest
 */
export interface IpamApiIpamVrfsUpdateRequest {
    /**
     * A unique integer value identifying this VRF.
     * @type {number}
     * @memberof IpamApiIpamVrfsUpdate
     */
    readonly id: number

    /**
     * 
     * @type {WritableVRF}
     * @memberof IpamApiIpamVrfsUpdate
     */
    readonly data: WritableVRF
}

/**
 * IpamApi - object-oriented interface
 * @export
 * @class IpamApi
 * @extends {BaseAPI}
 */
export class IpamApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkPartialUpdate(requestParameters: IpamApiIpamAggregatesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesBulkUpdate(requestParameters: IpamApiIpamAggregatesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesCreate(requestParameters: IpamApiIpamAggregatesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesDelete(requestParameters: IpamApiIpamAggregatesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesList(requestParameters: IpamApiIpamAggregatesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesList(requestParameters.id, requestParameters.dateAdded, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.prefix, requestParameters.rirId, requestParameters.rir, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.dateAddedN, requestParameters.dateAddedLte, requestParameters.dateAddedLt, requestParameters.dateAddedGte, requestParameters.dateAddedGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.rirIdN, requestParameters.rirN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesPartialUpdate(requestParameters: IpamApiIpamAggregatesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesRead(requestParameters: IpamApiIpamAggregatesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamAggregatesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamAggregatesUpdate(requestParameters: IpamApiIpamAggregatesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamAggregatesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkPartialUpdate(requestParameters: IpamApiIpamIpAddressesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesBulkUpdate(requestParameters: IpamApiIpamIpAddressesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesCreate(requestParameters: IpamApiIpamIpAddressesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesDelete(requestParameters: IpamApiIpamIpAddressesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesList(requestParameters: IpamApiIpamIpAddressesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesList(requestParameters.id, requestParameters.dnsName, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.parent, requestParameters.address, requestParameters.maskLength, requestParameters.vrfId, requestParameters.vrf, requestParameters.presentInVrfId, requestParameters.presentInVrf, requestParameters.device, requestParameters.deviceId, requestParameters.virtualMachine, requestParameters.virtualMachineId, requestParameters._interface, requestParameters.interfaceId, requestParameters.vminterface, requestParameters.vminterfaceId, requestParameters.assignedToInterface, requestParameters.status, requestParameters.role, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.dnsNameN, requestParameters.dnsNameIc, requestParameters.dnsNameNic, requestParameters.dnsNameIew, requestParameters.dnsNameNiew, requestParameters.dnsNameIsw, requestParameters.dnsNameNisw, requestParameters.dnsNameIe, requestParameters.dnsNameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.vrfIdN, requestParameters.vrfN, requestParameters.interfaceN, requestParameters.interfaceIdN, requestParameters.vminterfaceN, requestParameters.vminterfaceIdN, requestParameters.statusN, requestParameters.roleN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesPartialUpdate(requestParameters: IpamApiIpamIpAddressesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesRead(requestParameters: IpamApiIpamIpAddressesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamIpAddressesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamIpAddressesUpdate(requestParameters: IpamApiIpamIpAddressesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamIpAddressesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @param {IpamApiIpamPrefixesAvailableIpsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailableIpsCreate(requestParameters: IpamApiIpamPrefixesAvailableIpsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailableIpsCreate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * A convenience method for returning available IP addresses within a prefix. By default, the number of IPs returned will be equivalent to PAGINATE_COUNT. An arbitrary limit (up to MAX_PAGE_SIZE, if set) may be passed, however results will not be paginated.  The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @param {IpamApiIpamPrefixesAvailableIpsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailableIpsRead(requestParameters: IpamApiIpamPrefixesAvailableIpsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailableIpsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @summary A convenience method for returning available child prefixes within a parent.
     * @param {IpamApiIpamPrefixesAvailablePrefixesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailablePrefixesCreate(requestParameters: IpamApiIpamPrefixesAvailablePrefixesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailablePrefixesCreate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The advisory lock decorator uses a PostgreSQL advisory lock to prevent this API from being invoked in parallel, which results in a race condition where multiple insertions can occur.
     * @summary A convenience method for returning available child prefixes within a parent.
     * @param {IpamApiIpamPrefixesAvailablePrefixesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesAvailablePrefixesRead(requestParameters: IpamApiIpamPrefixesAvailablePrefixesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesAvailablePrefixesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkPartialUpdate(requestParameters: IpamApiIpamPrefixesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesBulkUpdate(requestParameters: IpamApiIpamPrefixesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesCreate(requestParameters: IpamApiIpamPrefixesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesDelete(requestParameters: IpamApiIpamPrefixesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesList(requestParameters: IpamApiIpamPrefixesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesList(requestParameters.id, requestParameters.isPool, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.family, requestParameters.prefix, requestParameters.within, requestParameters.withinInclude, requestParameters.contains, requestParameters.maskLength, requestParameters.maskLengthGte, requestParameters.maskLengthLte, requestParameters.vrfId, requestParameters.vrf, requestParameters.presentInVrfId, requestParameters.presentInVrf, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.vlanId, requestParameters.vlanVid, requestParameters.roleId, requestParameters.role, requestParameters.status, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.vrfIdN, requestParameters.vrfN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.vlanIdN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.statusN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesPartialUpdate(requestParameters: IpamApiIpamPrefixesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesRead(requestParameters: IpamApiIpamPrefixesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamPrefixesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamPrefixesUpdate(requestParameters: IpamApiIpamPrefixesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamPrefixesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkPartialUpdate(requestParameters: IpamApiIpamRirsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsBulkUpdate(requestParameters: IpamApiIpamRirsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsCreate(requestParameters: IpamApiIpamRirsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsDelete(requestParameters: IpamApiIpamRirsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsList(requestParameters: IpamApiIpamRirsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.isPrivate, requestParameters.description, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsPartialUpdate(requestParameters: IpamApiIpamRirsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsRead(requestParameters: IpamApiIpamRirsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRirsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRirsUpdate(requestParameters: IpamApiIpamRirsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRirsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkPartialUpdate(requestParameters: IpamApiIpamRolesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesBulkUpdate(requestParameters: IpamApiIpamRolesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesCreate(requestParameters: IpamApiIpamRolesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesDelete(requestParameters: IpamApiIpamRolesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesList(requestParameters: IpamApiIpamRolesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.q, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesPartialUpdate(requestParameters: IpamApiIpamRolesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesRead(requestParameters: IpamApiIpamRolesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRolesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRolesUpdate(requestParameters: IpamApiIpamRolesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRolesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkPartialUpdate(requestParameters: IpamApiIpamRouteTargetsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsBulkUpdate(requestParameters: IpamApiIpamRouteTargetsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsCreate(requestParameters: IpamApiIpamRouteTargetsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsDelete(requestParameters: IpamApiIpamRouteTargetsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsList(requestParameters: IpamApiIpamRouteTargetsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsList(requestParameters.id, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.importingVrfId, requestParameters.importingVrf, requestParameters.exportingVrfId, requestParameters.exportingVrf, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.importingVrfIdN, requestParameters.importingVrfN, requestParameters.exportingVrfIdN, requestParameters.exportingVrfN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsPartialUpdate(requestParameters: IpamApiIpamRouteTargetsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsRead(requestParameters: IpamApiIpamRouteTargetsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamRouteTargetsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamRouteTargetsUpdate(requestParameters: IpamApiIpamRouteTargetsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamRouteTargetsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkPartialUpdate(requestParameters: IpamApiIpamServicesBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesBulkUpdate(requestParameters: IpamApiIpamServicesBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesCreate(requestParameters: IpamApiIpamServicesCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesDelete(requestParameters: IpamApiIpamServicesDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesList(requestParameters: IpamApiIpamServicesListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesList(requestParameters.id, requestParameters.name, requestParameters.protocol, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.deviceId, requestParameters.device, requestParameters.virtualMachineId, requestParameters.virtualMachine, requestParameters.port, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.protocolN, requestParameters.deviceIdN, requestParameters.deviceN, requestParameters.virtualMachineIdN, requestParameters.virtualMachineN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesPartialUpdate(requestParameters: IpamApiIpamServicesPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesRead(requestParameters: IpamApiIpamServicesReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamServicesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamServicesUpdate(requestParameters: IpamApiIpamServicesUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamServicesUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkPartialUpdate(requestParameters: IpamApiIpamVlanGroupsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsBulkUpdate(requestParameters: IpamApiIpamVlanGroupsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsCreate(requestParameters: IpamApiIpamVlanGroupsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsDelete(requestParameters: IpamApiIpamVlanGroupsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsList(requestParameters: IpamApiIpamVlanGroupsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsList(requestParameters.id, requestParameters.name, requestParameters.slug, requestParameters.description, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.slugN, requestParameters.slugIc, requestParameters.slugNic, requestParameters.slugIew, requestParameters.slugNiew, requestParameters.slugIsw, requestParameters.slugNisw, requestParameters.slugIe, requestParameters.slugNie, requestParameters.descriptionN, requestParameters.descriptionIc, requestParameters.descriptionNic, requestParameters.descriptionIew, requestParameters.descriptionNiew, requestParameters.descriptionIsw, requestParameters.descriptionNisw, requestParameters.descriptionIe, requestParameters.descriptionNie, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsPartialUpdate(requestParameters: IpamApiIpamVlanGroupsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsRead(requestParameters: IpamApiIpamVlanGroupsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlanGroupsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlanGroupsUpdate(requestParameters: IpamApiIpamVlanGroupsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlanGroupsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkPartialUpdate(requestParameters: IpamApiIpamVlansBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansBulkUpdate(requestParameters: IpamApiIpamVlansBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansCreate(requestParameters: IpamApiIpamVlansCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansDelete(requestParameters: IpamApiIpamVlansDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansList(requestParameters: IpamApiIpamVlansListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansList(requestParameters.id, requestParameters.vid, requestParameters.name, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.regionId, requestParameters.region, requestParameters.siteId, requestParameters.site, requestParameters.groupId, requestParameters.group, requestParameters.roleId, requestParameters.role, requestParameters.status, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.vidN, requestParameters.vidLte, requestParameters.vidLt, requestParameters.vidGte, requestParameters.vidGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.regionIdN, requestParameters.regionN, requestParameters.siteIdN, requestParameters.siteN, requestParameters.groupIdN, requestParameters.groupN, requestParameters.roleIdN, requestParameters.roleN, requestParameters.statusN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansPartialUpdate(requestParameters: IpamApiIpamVlansPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansRead(requestParameters: IpamApiIpamVlansReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVlansUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVlansUpdate(requestParameters: IpamApiIpamVlansUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVlansUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkDelete(options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsBulkPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkPartialUpdate(requestParameters: IpamApiIpamVrfsBulkPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkPartialUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsBulkUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsBulkUpdate(requestParameters: IpamApiIpamVrfsBulkUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsBulkUpdate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsCreate(requestParameters: IpamApiIpamVrfsCreateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsCreate(requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsDelete(requestParameters: IpamApiIpamVrfsDeleteRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsDelete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsList(requestParameters: IpamApiIpamVrfsListRequest = {}, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsList(requestParameters.id, requestParameters.name, requestParameters.rd, requestParameters.enforceUnique, requestParameters.tenantGroupId, requestParameters.tenantGroup, requestParameters.tenantId, requestParameters.tenant, requestParameters.created, requestParameters.createdGte, requestParameters.createdLte, requestParameters.lastUpdated, requestParameters.lastUpdatedGte, requestParameters.lastUpdatedLte, requestParameters.q, requestParameters.importTargetId, requestParameters.importTarget, requestParameters.exportTargetId, requestParameters.exportTarget, requestParameters.tag, requestParameters.idN, requestParameters.idLte, requestParameters.idLt, requestParameters.idGte, requestParameters.idGt, requestParameters.nameN, requestParameters.nameIc, requestParameters.nameNic, requestParameters.nameIew, requestParameters.nameNiew, requestParameters.nameIsw, requestParameters.nameNisw, requestParameters.nameIe, requestParameters.nameNie, requestParameters.rdN, requestParameters.rdIc, requestParameters.rdNic, requestParameters.rdIew, requestParameters.rdNiew, requestParameters.rdIsw, requestParameters.rdNisw, requestParameters.rdIe, requestParameters.rdNie, requestParameters.tenantGroupIdN, requestParameters.tenantGroupN, requestParameters.tenantIdN, requestParameters.tenantN, requestParameters.importTargetIdN, requestParameters.importTargetN, requestParameters.exportTargetIdN, requestParameters.exportTargetN, requestParameters.tagN, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsPartialUpdate(requestParameters: IpamApiIpamVrfsPartialUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsPartialUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsReadRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsRead(requestParameters: IpamApiIpamVrfsReadRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsRead(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {IpamApiIpamVrfsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IpamApi
     */
    public ipamVrfsUpdate(requestParameters: IpamApiIpamVrfsUpdateRequest, options?: any) {
        return IpamApiFp(this.configuration).ipamVrfsUpdate(requestParameters.id, requestParameters.data, options).then((request) => request(this.axios, this.basePath));
    }
}
